// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Devices.Geolocation.h"

// ----- CivicAddress class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type;
static const char* _type_name_CivicAddress = "CivicAddress";

static PyObject* _new_CivicAddress(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_CivicAddress };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_CivicAddress(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* CivicAddress_get_City(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.City();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* CivicAddress_get_Country(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Country();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* CivicAddress_get_PostalCode(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.PostalCode();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* CivicAddress_get_State(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.State();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* CivicAddress_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Timestamp();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_CivicAddress(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::CivicAddress>());
    }, nullptr);
}

static PyMethodDef _methods_CivicAddress[] = {
    { "_from", (PyCFunction)_from_CivicAddress, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_CivicAddress[] = {
    { const_cast<char*>("city"), (getter)CivicAddress_get_City, nullptr, nullptr, nullptr },
    { const_cast<char*>("country"), (getter)CivicAddress_get_Country, nullptr, nullptr, nullptr },
    { const_cast<char*>("postal_code"), (getter)CivicAddress_get_PostalCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("state"), (getter)CivicAddress_get_State, nullptr, nullptr, nullptr },
    { const_cast<char*>("timestamp"), (getter)CivicAddress_get_Timestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_CivicAddress[] = 
{
    { Py_tp_new, _new_CivicAddress },
    { Py_tp_dealloc, _dealloc_CivicAddress },
    { Py_tp_methods, _methods_CivicAddress },
    { Py_tp_getset, _getset_CivicAddress },
    { 0, nullptr },
};

static PyType_Spec _type_spec_CivicAddress =
{
    "_winrt_Windows_Devices_Geolocation.CivicAddress",
    sizeof(py::wrapper::Windows::Devices::Geolocation::CivicAddress),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_CivicAddress
};

// ----- GeoboundingBox class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type;
static const char* _type_name_GeoboundingBox = "GeoboundingBox";

static PyObject* _new_GeoboundingBox(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 3)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 4)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_GeoboundingBox(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeoboundingBox_TryCompute(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            
            auto return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            
            auto return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count == 3)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            auto return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1, param2);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* GeoboundingBox_get_Center(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Center();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeoboundingBox_get_MaxAltitude(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.MaxAltitude();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeoboundingBox_get_MinAltitude(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.MinAltitude();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeoboundingBox_get_NorthwestCorner(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.NorthwestCorner();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeoboundingBox_get_SoutheastCorner(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SoutheastCorner();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeoboundingBox_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeoboundingBox_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.GeoshapeType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeoboundingBox_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_GeoboundingBox(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeoboundingBox>());
    }, nullptr);
}

static PyMethodDef _methods_GeoboundingBox[] = {
    { "try_compute", (PyCFunction)GeoboundingBox_TryCompute, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)_from_GeoboundingBox, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GeoboundingBox[] = {
    { const_cast<char*>("center"), (getter)GeoboundingBox_get_Center, nullptr, nullptr, nullptr },
    { const_cast<char*>("max_altitude"), (getter)GeoboundingBox_get_MaxAltitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("min_altitude"), (getter)GeoboundingBox_get_MinAltitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("northwest_corner"), (getter)GeoboundingBox_get_NorthwestCorner, nullptr, nullptr, nullptr },
    { const_cast<char*>("southeast_corner"), (getter)GeoboundingBox_get_SoutheastCorner, nullptr, nullptr, nullptr },
    { const_cast<char*>("altitude_reference_system"), (getter)GeoboundingBox_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("geoshape_type"), (getter)GeoboundingBox_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("spatial_reference_id"), (getter)GeoboundingBox_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_GeoboundingBox[] = 
{
    { Py_tp_new, _new_GeoboundingBox },
    { Py_tp_dealloc, _dealloc_GeoboundingBox },
    { Py_tp_methods, _methods_GeoboundingBox },
    { Py_tp_getset, _getset_GeoboundingBox },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GeoboundingBox =
{
    "_winrt_Windows_Devices_Geolocation.GeoboundingBox",
    sizeof(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GeoboundingBox
};

// ----- Geocircle class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type;
static const char* _type_name_Geocircle = "Geocircle";

static PyObject* _new_Geocircle(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 3)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 4)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_Geocircle(py::wrapper::Windows::Devices::Geolocation::Geocircle* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocircle_get_Center(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Center();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocircle_get_Radius(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Radius();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocircle_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocircle_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.GeoshapeType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocircle_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Geocircle(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geocircle>());
    }, nullptr);
}

static PyMethodDef _methods_Geocircle[] = {
    { "_from", (PyCFunction)_from_Geocircle, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geocircle[] = {
    { const_cast<char*>("center"), (getter)Geocircle_get_Center, nullptr, nullptr, nullptr },
    { const_cast<char*>("radius"), (getter)Geocircle_get_Radius, nullptr, nullptr, nullptr },
    { const_cast<char*>("altitude_reference_system"), (getter)Geocircle_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("geoshape_type"), (getter)Geocircle_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("spatial_reference_id"), (getter)Geocircle_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geocircle[] = 
{
    { Py_tp_new, _new_Geocircle },
    { Py_tp_dealloc, _dealloc_Geocircle },
    { Py_tp_methods, _methods_Geocircle },
    { Py_tp_getset, _getset_Geocircle },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geocircle =
{
    "_winrt_Windows_Devices_Geolocation.Geocircle",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geocircle),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geocircle
};

// ----- Geocoordinate class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type;
static const char* _type_name_Geocoordinate = "Geocoordinate";

static PyObject* _new_Geocoordinate(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_Geocoordinate };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_Geocoordinate(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocoordinate_get_Accuracy(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Accuracy();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_Altitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Altitude();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_AltitudeAccuracy(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AltitudeAccuracy();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_Heading(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Heading();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_Latitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Latitude();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_Longitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Longitude();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_Speed(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Speed();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Timestamp();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_Point(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Point();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_PositionSource(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.PositionSource();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_SatelliteData(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SatelliteData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geocoordinate_get_PositionSourceTimestamp(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.PositionSourceTimestamp();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Geocoordinate(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geocoordinate>());
    }, nullptr);
}

static PyMethodDef _methods_Geocoordinate[] = {
    { "_from", (PyCFunction)_from_Geocoordinate, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geocoordinate[] = {
    { const_cast<char*>("accuracy"), (getter)Geocoordinate_get_Accuracy, nullptr, nullptr, nullptr },
    { const_cast<char*>("altitude"), (getter)Geocoordinate_get_Altitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("altitude_accuracy"), (getter)Geocoordinate_get_AltitudeAccuracy, nullptr, nullptr, nullptr },
    { const_cast<char*>("heading"), (getter)Geocoordinate_get_Heading, nullptr, nullptr, nullptr },
    { const_cast<char*>("latitude"), (getter)Geocoordinate_get_Latitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("longitude"), (getter)Geocoordinate_get_Longitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("speed"), (getter)Geocoordinate_get_Speed, nullptr, nullptr, nullptr },
    { const_cast<char*>("timestamp"), (getter)Geocoordinate_get_Timestamp, nullptr, nullptr, nullptr },
    { const_cast<char*>("point"), (getter)Geocoordinate_get_Point, nullptr, nullptr, nullptr },
    { const_cast<char*>("position_source"), (getter)Geocoordinate_get_PositionSource, nullptr, nullptr, nullptr },
    { const_cast<char*>("satellite_data"), (getter)Geocoordinate_get_SatelliteData, nullptr, nullptr, nullptr },
    { const_cast<char*>("position_source_timestamp"), (getter)Geocoordinate_get_PositionSourceTimestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geocoordinate[] = 
{
    { Py_tp_new, _new_Geocoordinate },
    { Py_tp_dealloc, _dealloc_Geocoordinate },
    { Py_tp_methods, _methods_Geocoordinate },
    { Py_tp_getset, _getset_Geocoordinate },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geocoordinate =
{
    "_winrt_Windows_Devices_Geolocation.Geocoordinate",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geocoordinate),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geocoordinate
};

// ----- GeocoordinateSatelliteData class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type;
static const char* _type_name_GeocoordinateSatelliteData = "GeocoordinateSatelliteData";

static PyObject* _new_GeocoordinateSatelliteData(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_GeocoordinateSatelliteData };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_GeocoordinateSatelliteData(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.HorizontalDilutionOfPrecision();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeocoordinateSatelliteData_get_PositionDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.PositionDilutionOfPrecision();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.VerticalDilutionOfPrecision();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_GeocoordinateSatelliteData(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>());
    }, nullptr);
}

static PyMethodDef _methods_GeocoordinateSatelliteData[] = {
    { "_from", (PyCFunction)_from_GeocoordinateSatelliteData, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GeocoordinateSatelliteData[] = {
    { const_cast<char*>("horizontal_dilution_of_precision"), (getter)GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision, nullptr, nullptr, nullptr },
    { const_cast<char*>("position_dilution_of_precision"), (getter)GeocoordinateSatelliteData_get_PositionDilutionOfPrecision, nullptr, nullptr, nullptr },
    { const_cast<char*>("vertical_dilution_of_precision"), (getter)GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_GeocoordinateSatelliteData[] = 
{
    { Py_tp_new, _new_GeocoordinateSatelliteData },
    { Py_tp_dealloc, _dealloc_GeocoordinateSatelliteData },
    { Py_tp_methods, _methods_GeocoordinateSatelliteData },
    { Py_tp_getset, _getset_GeocoordinateSatelliteData },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GeocoordinateSatelliteData =
{
    "_winrt_Windows_Devices_Geolocation.GeocoordinateSatelliteData",
    sizeof(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GeocoordinateSatelliteData
};

// ----- Geolocator class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type;
static const char* _type_name_Geolocator = "Geolocator";

static PyObject* _new_Geolocator(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Devices::Geolocation::Geolocator instance{  };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_Geolocator(py::wrapper::Windows::Devices::Geolocation::Geolocator* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geolocator_AllowFallbackToConsentlessPositions(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.AllowFallbackToConsentlessPositions();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Geolocator_GetGeopositionAsync(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetGeopositionAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
            
            auto return_value = self->obj.GetGeopositionAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Geolocator_GetGeopositionHistoryAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            
            auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
            
            auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Geolocator_RequestAccessAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::RequestAccessAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Geolocator_get_ReportInterval(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.ReportInterval();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static int Geolocator_put_ReportInterval(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.ReportInterval(param0);
        return 0;
    });
}

static PyObject* Geolocator_get_MovementThreshold(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.MovementThreshold();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static int Geolocator_put_MovementThreshold(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        auto param0 = py::convert_to<double>(arg);
        
        self->obj.MovementThreshold(param0);
        return 0;
    });
}

static PyObject* Geolocator_get_DesiredAccuracy(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.DesiredAccuracy();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static int Geolocator_put_DesiredAccuracy(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::PositionAccuracy>(arg);
        
        self->obj.DesiredAccuracy(param0);
        return 0;
    });
}

static PyObject* Geolocator_get_LocationStatus(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.LocationStatus();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geolocator_get_DesiredAccuracyInMeters(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.DesiredAccuracyInMeters();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static int Geolocator_put_DesiredAccuracyInMeters(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);
        
        self->obj.DesiredAccuracyInMeters(param0);
        return 0;
    });
}

static PyObject* Geolocator_get_DefaultGeoposition(PyObject* /*unused*/, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geolocator_put_DefaultGeoposition(PyObject* /*unused*/, PyObject* arg, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(arg);
        
        winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition(param0);
        
        Py_RETURN_NONE;
    }, nullptr);
}

static PyObject* Geolocator_get_IsDefaultGeopositionRecommended(PyObject* /*unused*/, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::IsDefaultGeopositionRecommended();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geolocator_add_PositionChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>>(arg);
        
        auto return_value = self->obj.PositionChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geolocator_remove_PositionChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.PositionChanged(param0);
        
        Py_RETURN_NONE;
    }, nullptr);
}

static PyObject* Geolocator_add_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>>(arg);
        
        auto return_value = self->obj.StatusChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geolocator_remove_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.StatusChanged(param0);
        
        Py_RETURN_NONE;
    }, nullptr);
}

static PyObject* _from_Geolocator(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geolocator>());
    }, nullptr);
}

static PyMethodDef _methods_Geolocator[] = {
    { "get_geoposition_async", (PyCFunction)Geolocator_GetGeopositionAsync, METH_VARARGS, nullptr },
    { "allow_fallback_to_consentless_positions", (PyCFunction)Geolocator_AllowFallbackToConsentlessPositions, METH_VARARGS, nullptr },
    { "request_access_async", (PyCFunction)Geolocator_RequestAccessAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "get_geoposition_history_async", (PyCFunction)Geolocator_GetGeopositionHistoryAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "get_default_geoposition", (PyCFunction)Geolocator_get_DefaultGeoposition, METH_NOARGS | METH_STATIC, nullptr },
    { "put_default_geoposition", (PyCFunction)Geolocator_put_DefaultGeoposition, METH_O | METH_STATIC, nullptr },
    { "get_is_default_geoposition_recommended", (PyCFunction)Geolocator_get_IsDefaultGeopositionRecommended, METH_NOARGS | METH_STATIC, nullptr },
    { "add_position_changed", (PyCFunction)Geolocator_add_PositionChanged, METH_O, nullptr },
    { "remove_position_changed", (PyCFunction)Geolocator_remove_PositionChanged, METH_O, nullptr },
    { "add_status_changed", (PyCFunction)Geolocator_add_StatusChanged, METH_O, nullptr },
    { "remove_status_changed", (PyCFunction)Geolocator_remove_StatusChanged, METH_O, nullptr },
    { "_from", (PyCFunction)_from_Geolocator, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geolocator[] = {
    { const_cast<char*>("report_interval"), (getter)Geolocator_get_ReportInterval, (setter)Geolocator_put_ReportInterval, nullptr, nullptr },
    { const_cast<char*>("movement_threshold"), (getter)Geolocator_get_MovementThreshold, (setter)Geolocator_put_MovementThreshold, nullptr, nullptr },
    { const_cast<char*>("desired_accuracy"), (getter)Geolocator_get_DesiredAccuracy, (setter)Geolocator_put_DesiredAccuracy, nullptr, nullptr },
    { const_cast<char*>("location_status"), (getter)Geolocator_get_LocationStatus, nullptr, nullptr, nullptr },
    { const_cast<char*>("desired_accuracy_in_meters"), (getter)Geolocator_get_DesiredAccuracyInMeters, (setter)Geolocator_put_DesiredAccuracyInMeters, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geolocator[] = 
{
    { Py_tp_new, _new_Geolocator },
    { Py_tp_dealloc, _dealloc_Geolocator },
    { Py_tp_methods, _methods_Geolocator },
    { Py_tp_getset, _getset_Geolocator },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geolocator =
{
    "_winrt_Windows_Devices_Geolocation.Geolocator",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geolocator),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geolocator
};

// ----- Geopath class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type;
static const char* _type_name_Geopath = "Geopath";

static PyObject* _new_Geopath(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 3)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_Geopath(py::wrapper::Windows::Devices::Geolocation::Geopath* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopath_get_Positions(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Positions();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geopath_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geopath_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.GeoshapeType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geopath_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Geopath(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geopath>());
    }, nullptr);
}

static PyMethodDef _methods_Geopath[] = {
    { "_from", (PyCFunction)_from_Geopath, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geopath[] = {
    { const_cast<char*>("positions"), (getter)Geopath_get_Positions, nullptr, nullptr, nullptr },
    { const_cast<char*>("altitude_reference_system"), (getter)Geopath_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("geoshape_type"), (getter)Geopath_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("spatial_reference_id"), (getter)Geopath_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geopath[] = 
{
    { Py_tp_new, _new_Geopath },
    { Py_tp_dealloc, _dealloc_Geopath },
    { Py_tp_methods, _methods_Geopath },
    { Py_tp_getset, _getset_Geopath },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geopath =
{
    "_winrt_Windows_Devices_Geolocation.Geopath",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geopath),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geopath
};

// ----- Geopoint class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type;
static const char* _type_name_Geopoint = "Geopoint";

static PyObject* _new_Geopoint(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 3)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_Geopoint(py::wrapper::Windows::Devices::Geolocation::Geopoint* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopoint_get_Position(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geopoint_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geopoint_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.GeoshapeType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geopoint_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Geopoint(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geopoint>());
    }, nullptr);
}

static PyMethodDef _methods_Geopoint[] = {
    { "_from", (PyCFunction)_from_Geopoint, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geopoint[] = {
    { const_cast<char*>("position"), (getter)Geopoint_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("altitude_reference_system"), (getter)Geopoint_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("geoshape_type"), (getter)Geopoint_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("spatial_reference_id"), (getter)Geopoint_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geopoint[] = 
{
    { Py_tp_new, _new_Geopoint },
    { Py_tp_dealloc, _dealloc_Geopoint },
    { Py_tp_methods, _methods_Geopoint },
    { Py_tp_getset, _getset_Geopoint },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geopoint =
{
    "_winrt_Windows_Devices_Geolocation.Geopoint",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geopoint),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geopoint
};

// ----- Geoposition class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type;
static const char* _type_name_Geoposition = "Geoposition";

static PyObject* _new_Geoposition(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_Geoposition };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_Geoposition(py::wrapper::Windows::Devices::Geolocation::Geoposition* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geoposition_get_CivicAddress(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.CivicAddress();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geoposition_get_Coordinate(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Coordinate();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geoposition_get_VenueData(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.VenueData();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Geoposition(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geoposition>());
    }, nullptr);
}

static PyMethodDef _methods_Geoposition[] = {
    { "_from", (PyCFunction)_from_Geoposition, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geoposition[] = {
    { const_cast<char*>("civic_address"), (getter)Geoposition_get_CivicAddress, nullptr, nullptr, nullptr },
    { const_cast<char*>("coordinate"), (getter)Geoposition_get_Coordinate, nullptr, nullptr, nullptr },
    { const_cast<char*>("venue_data"), (getter)Geoposition_get_VenueData, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geoposition[] = 
{
    { Py_tp_new, _new_Geoposition },
    { Py_tp_dealloc, _dealloc_Geoposition },
    { Py_tp_methods, _methods_Geoposition },
    { Py_tp_getset, _getset_Geoposition },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geoposition =
{
    "_winrt_Windows_Devices_Geolocation.Geoposition",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geoposition),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geoposition
};

// ----- Geovisit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type;
static const char* _type_name_Geovisit = "Geovisit";

static PyObject* _new_Geovisit(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_Geovisit };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_Geovisit(py::wrapper::Windows::Devices::Geolocation::Geovisit* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geovisit_get_Position(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geovisit_get_StateChange(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.StateChange();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geovisit_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Timestamp();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Geovisit(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geovisit>());
    }, nullptr);
}

static PyMethodDef _methods_Geovisit[] = {
    { "_from", (PyCFunction)_from_Geovisit, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geovisit[] = {
    { const_cast<char*>("position"), (getter)Geovisit_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("state_change"), (getter)Geovisit_get_StateChange, nullptr, nullptr, nullptr },
    { const_cast<char*>("timestamp"), (getter)Geovisit_get_Timestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geovisit[] = 
{
    { Py_tp_new, _new_Geovisit },
    { Py_tp_dealloc, _dealloc_Geovisit },
    { Py_tp_methods, _methods_Geovisit },
    { Py_tp_getset, _getset_Geovisit },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geovisit =
{
    "_winrt_Windows_Devices_Geolocation.Geovisit",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geovisit),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geovisit
};

// ----- GeovisitMonitor class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type;
static const char* _type_name_GeovisitMonitor = "GeovisitMonitor";

static PyObject* _new_GeovisitMonitor(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Devices::Geolocation::GeovisitMonitor instance{  };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_GeovisitMonitor(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitMonitor_GetLastReportAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = winrt::Windows::Devices::Geolocation::GeovisitMonitor::GetLastReportAsync();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* GeovisitMonitor_Start(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(args, 0);
            
            self->obj.Start(param0);
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* GeovisitMonitor_Stop(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Stop();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* GeovisitMonitor_get_MonitoringScope(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.MonitoringScope();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeovisitMonitor_add_VisitStateChanged(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::GeovisitMonitor, winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>>(arg);
        
        auto return_value = self->obj.VisitStateChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeovisitMonitor_remove_VisitStateChanged(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.VisitStateChanged(param0);
        
        Py_RETURN_NONE;
    }, nullptr);
}

static PyObject* _from_GeovisitMonitor(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitMonitor>());
    }, nullptr);
}

static PyMethodDef _methods_GeovisitMonitor[] = {
    { "start", (PyCFunction)GeovisitMonitor_Start, METH_VARARGS, nullptr },
    { "stop", (PyCFunction)GeovisitMonitor_Stop, METH_VARARGS, nullptr },
    { "get_last_report_async", (PyCFunction)GeovisitMonitor_GetLastReportAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "add_visit_state_changed", (PyCFunction)GeovisitMonitor_add_VisitStateChanged, METH_O, nullptr },
    { "remove_visit_state_changed", (PyCFunction)GeovisitMonitor_remove_VisitStateChanged, METH_O, nullptr },
    { "_from", (PyCFunction)_from_GeovisitMonitor, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GeovisitMonitor[] = {
    { const_cast<char*>("monitoring_scope"), (getter)GeovisitMonitor_get_MonitoringScope, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_GeovisitMonitor[] = 
{
    { Py_tp_new, _new_GeovisitMonitor },
    { Py_tp_dealloc, _dealloc_GeovisitMonitor },
    { Py_tp_methods, _methods_GeovisitMonitor },
    { Py_tp_getset, _getset_GeovisitMonitor },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GeovisitMonitor =
{
    "_winrt_Windows_Devices_Geolocation.GeovisitMonitor",
    sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GeovisitMonitor
};

// ----- GeovisitStateChangedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type;
static const char* _type_name_GeovisitStateChangedEventArgs = "GeovisitStateChangedEventArgs";

static PyObject* _new_GeovisitStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_GeovisitStateChangedEventArgs };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_GeovisitStateChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitStateChangedEventArgs_get_Visit(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Visit();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_GeovisitStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>());
    }, nullptr);
}

static PyMethodDef _methods_GeovisitStateChangedEventArgs[] = {
    { "_from", (PyCFunction)_from_GeovisitStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GeovisitStateChangedEventArgs[] = {
    { const_cast<char*>("visit"), (getter)GeovisitStateChangedEventArgs_get_Visit, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_GeovisitStateChangedEventArgs[] = 
{
    { Py_tp_new, _new_GeovisitStateChangedEventArgs },
    { Py_tp_dealloc, _dealloc_GeovisitStateChangedEventArgs },
    { Py_tp_methods, _methods_GeovisitStateChangedEventArgs },
    { Py_tp_getset, _getset_GeovisitStateChangedEventArgs },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GeovisitStateChangedEventArgs =
{
    "_winrt_Windows_Devices_Geolocation.GeovisitStateChangedEventArgs",
    sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GeovisitStateChangedEventArgs
};

// ----- GeovisitTriggerDetails class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type;
static const char* _type_name_GeovisitTriggerDetails = "GeovisitTriggerDetails";

static PyObject* _new_GeovisitTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_GeovisitTriggerDetails };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_GeovisitTriggerDetails(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitTriggerDetails_ReadReports(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.ReadReports();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* _from_GeovisitTriggerDetails(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>());
    }, nullptr);
}

static PyMethodDef _methods_GeovisitTriggerDetails[] = {
    { "read_reports", (PyCFunction)GeovisitTriggerDetails_ReadReports, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_GeovisitTriggerDetails, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GeovisitTriggerDetails[] = {
    { nullptr }
};

static PyType_Slot _type_slots_GeovisitTriggerDetails[] = 
{
    { Py_tp_new, _new_GeovisitTriggerDetails },
    { Py_tp_dealloc, _dealloc_GeovisitTriggerDetails },
    { Py_tp_methods, _methods_GeovisitTriggerDetails },
    { Py_tp_getset, _getset_GeovisitTriggerDetails },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GeovisitTriggerDetails =
{
    "_winrt_Windows_Devices_Geolocation.GeovisitTriggerDetails",
    sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GeovisitTriggerDetails
};

// ----- PositionChangedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type;
static const char* _type_name_PositionChangedEventArgs = "PositionChangedEventArgs";

static PyObject* _new_PositionChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_PositionChangedEventArgs };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_PositionChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PositionChangedEventArgs_get_Position(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Position();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_PositionChangedEventArgs(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>());
    }, nullptr);
}

static PyMethodDef _methods_PositionChangedEventArgs[] = {
    { "_from", (PyCFunction)_from_PositionChangedEventArgs, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_PositionChangedEventArgs[] = {
    { const_cast<char*>("position"), (getter)PositionChangedEventArgs_get_Position, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_PositionChangedEventArgs[] = 
{
    { Py_tp_new, _new_PositionChangedEventArgs },
    { Py_tp_dealloc, _dealloc_PositionChangedEventArgs },
    { Py_tp_methods, _methods_PositionChangedEventArgs },
    { Py_tp_getset, _getset_PositionChangedEventArgs },
    { 0, nullptr },
};

static PyType_Spec _type_spec_PositionChangedEventArgs =
{
    "_winrt_Windows_Devices_Geolocation.PositionChangedEventArgs",
    sizeof(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_PositionChangedEventArgs
};

// ----- StatusChangedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type;
static const char* _type_name_StatusChangedEventArgs = "StatusChangedEventArgs";

static PyObject* _new_StatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_StatusChangedEventArgs };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_StatusChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StatusChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Status();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_StatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>());
    }, nullptr);
}

static PyMethodDef _methods_StatusChangedEventArgs[] = {
    { "_from", (PyCFunction)_from_StatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_StatusChangedEventArgs[] = {
    { const_cast<char*>("status"), (getter)StatusChangedEventArgs_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_StatusChangedEventArgs[] = 
{
    { Py_tp_new, _new_StatusChangedEventArgs },
    { Py_tp_dealloc, _dealloc_StatusChangedEventArgs },
    { Py_tp_methods, _methods_StatusChangedEventArgs },
    { Py_tp_getset, _getset_StatusChangedEventArgs },
    { 0, nullptr },
};

static PyType_Spec _type_spec_StatusChangedEventArgs =
{
    "_winrt_Windows_Devices_Geolocation.StatusChangedEventArgs",
    sizeof(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_StatusChangedEventArgs
};

// ----- VenueData class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type;
static const char* _type_name_VenueData = "VenueData";

static PyObject* _new_VenueData(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_VenueData };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_VenueData(py::wrapper::Windows::Devices::Geolocation::VenueData* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* VenueData_get_Id(py::wrapper::Windows::Devices::Geolocation::VenueData* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Id();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* VenueData_get_Level(py::wrapper::Windows::Devices::Geolocation::VenueData* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Level();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_VenueData(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::VenueData>());
    }, nullptr);
}

static PyMethodDef _methods_VenueData[] = {
    { "_from", (PyCFunction)_from_VenueData, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_VenueData[] = {
    { const_cast<char*>("id"), (getter)VenueData_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("level"), (getter)VenueData_get_Level, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_VenueData[] = 
{
    { Py_tp_new, _new_VenueData },
    { Py_tp_dealloc, _dealloc_VenueData },
    { Py_tp_methods, _methods_VenueData },
    { Py_tp_getset, _getset_VenueData },
    { 0, nullptr },
};

static PyType_Spec _type_spec_VenueData =
{
    "_winrt_Windows_Devices_Geolocation.VenueData",
    sizeof(py::wrapper::Windows::Devices::Geolocation::VenueData),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_VenueData
};

// ----- IGeoshape interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type;
static const char* _type_name_IGeoshape = "IGeoshape";

static PyObject* _new_IGeoshape(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IGeoshape };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IGeoshape(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGeoshape_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IGeoshape_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.GeoshapeType();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IGeoshape_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_IGeoshape(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::IGeoshape>());
    }, nullptr);
}

static PyMethodDef _methods_IGeoshape[] = {
    { "_from", (PyCFunction)_from_IGeoshape, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IGeoshape[] = {
    { const_cast<char*>("altitude_reference_system"), (getter)IGeoshape_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("geoshape_type"), (getter)IGeoshape_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("spatial_reference_id"), (getter)IGeoshape_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IGeoshape[] = 
{
    { Py_tp_new, _new_IGeoshape },
    { Py_tp_dealloc, _dealloc_IGeoshape },
    { Py_tp_methods, _methods_IGeoshape },
    { Py_tp_getset, _getset_IGeoshape },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IGeoshape =
{
    "_winrt_Windows_Devices_Geolocation.IGeoshape",
    sizeof(py::wrapper::Windows::Devices::Geolocation::IGeoshape),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IGeoshape
};

// ----- BasicGeoposition struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type;
static const char* _type_name_BasicGeoposition = "BasicGeoposition";

PyObject* py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert(winrt::Windows::Devices::Geolocation::BasicGeoposition instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>());
}

winrt::Windows::Devices::Geolocation::BasicGeoposition py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::Windows::Devices::Geolocation::BasicGeoposition return_value{};
    
    py::pyobj_handle py_Latitude{ PyDict_GetItemString(obj, "latitude") };
    if (!py_Latitude) { throw winrt::hresult_invalid_argument(); }
    return_value.Latitude = converter<double>::convert_to(py_Latitude.get());
    
    py::pyobj_handle py_Longitude{ PyDict_GetItemString(obj, "longitude") };
    if (!py_Longitude) { throw winrt::hresult_invalid_argument(); }
    return_value.Longitude = converter<double>::convert_to(py_Longitude.get());
    
    py::pyobj_handle py_Altitude{ PyDict_GetItemString(obj, "altitude") };
    if (!py_Altitude) { throw winrt::hresult_invalid_argument(); }
    return_value.Altitude = converter<double>::convert_to(py_Altitude.get());
    
    return return_value;
}

PyObject* _new_BasicGeoposition(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    double _Latitude{};
    double _Longitude{};
    double _Altitude{};
    
    static const char* kwlist[] = {"latitude", "longitude", "altitude", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", const_cast<char**>(kwlist), &_Latitude, &_Longitude, &_Altitude))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::Windows::Devices::Geolocation::BasicGeoposition return_value{ _Latitude, _Longitude, _Altitude };
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_BasicGeoposition(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self)
{
}

static PyObject* BasicGeoposition_get_Latitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Latitude);
    }, nullptr);
}

static int BasicGeoposition_set_Latitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Latitude = py::converter<double>::convert_to(arg);
        return 0;
    });
}

static PyObject* BasicGeoposition_get_Longitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Longitude);
    }, nullptr);
}

static int BasicGeoposition_set_Longitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Longitude = py::converter<double>::convert_to(arg);
        return 0;
    });
}

static PyObject* BasicGeoposition_get_Altitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Altitude);
    }, nullptr);
}

static int BasicGeoposition_set_Altitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Altitude = py::converter<double>::convert_to(arg);
        return 0;
    });
}

static PyGetSetDef _getset_BasicGeoposition[] = {
    { const_cast<char*>("latitude"), (getter)BasicGeoposition_get_Latitude, (setter)BasicGeoposition_set_Latitude, nullptr, nullptr },
    { const_cast<char*>("longitude"), (getter)BasicGeoposition_get_Longitude, (setter)BasicGeoposition_set_Longitude, nullptr, nullptr },
    { const_cast<char*>("altitude"), (getter)BasicGeoposition_get_Altitude, (setter)BasicGeoposition_set_Altitude, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_BasicGeoposition[] = 
{
    { Py_tp_new, _new_BasicGeoposition },
    { Py_tp_dealloc, _dealloc_BasicGeoposition },
    { Py_tp_getset, _getset_BasicGeoposition },
    { 0, nullptr },
};

static PyType_Spec _type_spec_BasicGeoposition =
{
    "_winrt_Windows_Devices_Geolocation.BasicGeoposition",
    sizeof(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_BasicGeoposition
};

// ----- Windows.Devices.Geolocation Initialization --------------------
static int module_exec(PyObject* module)
{
    py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };
    
    try
    {
        py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_CivicAddress, &_type_spec_CivicAddress, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GeoboundingBox, &_type_spec_GeoboundingBox, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geocircle, &_type_spec_Geocircle, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geocoordinate, &_type_spec_Geocoordinate, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GeocoordinateSatelliteData, &_type_spec_GeocoordinateSatelliteData, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geolocator, &_type_spec_Geolocator, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geopath, &_type_spec_Geopath, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geopoint, &_type_spec_Geopoint, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geoposition, &_type_spec_Geoposition, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geovisit, &_type_spec_Geovisit, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GeovisitMonitor, &_type_spec_GeovisitMonitor, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GeovisitStateChangedEventArgs, &_type_spec_GeovisitStateChangedEventArgs, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GeovisitTriggerDetails, &_type_spec_GeovisitTriggerDetails, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_PositionChangedEventArgs, &_type_spec_PositionChangedEventArgs, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_StatusChangedEventArgs, &_type_spec_StatusChangedEventArgs, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_VenueData, &_type_spec_VenueData, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IGeoshape, &_type_spec_IGeoshape, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_BasicGeoposition, &_type_spec_BasicGeoposition, bases.get()).detach());
    }
    catch(...)
    {
        py::to_PyErr();
        return -1;
    }
    
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Devices.Geolocation");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_winrt_Windows_Devices_Geolocation",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Geolocation (void)
{
    return PyModuleDef_Init(&module_def);
}
