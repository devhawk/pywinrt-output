// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Devices.Geolocation.Geofencing.h"

// ----- Geofence class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>::python_type;
static const char* _type_name_Geofence = "Geofence";

static PyObject* _new_Geofence(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 4)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::Geofencing::MonitoredGeofenceStates>(args, 2);
            auto param3 = py::convert_to<bool>(args, 3);
            
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 5)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::Geofencing::MonitoredGeofenceStates>(args, 2);
            auto param3 = py::convert_to<bool>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 4);
            
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1, param2, param3, param4 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 7)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::Geofencing::MonitoredGeofenceStates>(args, 2);
            auto param3 = py::convert_to<bool>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 4);
            auto param5 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 5);
            auto param6 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 6);
            
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1, param2, param3, param4, param5, param6 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_Geofence(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geofence_get_Duration(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Duration();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geofence_get_DwellTime(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.DwellTime();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geofence_get_Geoshape(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Geoshape();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geofence_get_Id(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Id();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geofence_get_MonitoredStates(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.MonitoredStates();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geofence_get_SingleUse(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SingleUse();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Geofence_get_StartTime(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.StartTime();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Geofence(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>());
    }, nullptr);
}

static PyMethodDef _methods_Geofence[] = {
    { "_from", (PyCFunction)_from_Geofence, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Geofence[] = {
    { const_cast<char*>("duration"), (getter)Geofence_get_Duration, nullptr, nullptr, nullptr },
    { const_cast<char*>("dwell_time"), (getter)Geofence_get_DwellTime, nullptr, nullptr, nullptr },
    { const_cast<char*>("geoshape"), (getter)Geofence_get_Geoshape, nullptr, nullptr, nullptr },
    { const_cast<char*>("id"), (getter)Geofence_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("monitored_states"), (getter)Geofence_get_MonitoredStates, nullptr, nullptr, nullptr },
    { const_cast<char*>("single_use"), (getter)Geofence_get_SingleUse, nullptr, nullptr, nullptr },
    { const_cast<char*>("start_time"), (getter)Geofence_get_StartTime, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Geofence[] = 
{
    { Py_tp_new, _new_Geofence },
    { Py_tp_dealloc, _dealloc_Geofence },
    { Py_tp_methods, _methods_Geofence },
    { Py_tp_getset, _getset_Geofence },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Geofence =
{
    "_winrt_Windows_Devices_Geolocation_Geofencing.Geofence",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geofencing::Geofence),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Geofence
};

// ----- GeofenceMonitor class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>::python_type;
static const char* _type_name_GeofenceMonitor = "GeofenceMonitor";

static PyObject* _new_GeofenceMonitor(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_GeofenceMonitor };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_GeofenceMonitor(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeofenceMonitor_ReadReports(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.ReadReports();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* GeofenceMonitor_get_Geofences(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Geofences();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceMonitor_get_LastKnownGeoposition(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.LastKnownGeoposition();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceMonitor_get_Status(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Status();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceMonitor_get_Current(PyObject* /*unused*/, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor::Current();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceMonitor_add_GeofenceStateChanged(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.GeofenceStateChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceMonitor_remove_GeofenceStateChanged(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.GeofenceStateChanged(param0);
        
        Py_RETURN_NONE;
    }, nullptr);
}

static PyObject* GeofenceMonitor_add_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.StatusChanged(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceMonitor_remove_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.StatusChanged(param0);
        
        Py_RETURN_NONE;
    }, nullptr);
}

static PyObject* _from_GeofenceMonitor(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>());
    }, nullptr);
}

static PyMethodDef _methods_GeofenceMonitor[] = {
    { "read_reports", (PyCFunction)GeofenceMonitor_ReadReports, METH_VARARGS, nullptr },
    { "get_current", (PyCFunction)GeofenceMonitor_get_Current, METH_NOARGS | METH_STATIC, nullptr },
    { "add_geofence_state_changed", (PyCFunction)GeofenceMonitor_add_GeofenceStateChanged, METH_O, nullptr },
    { "remove_geofence_state_changed", (PyCFunction)GeofenceMonitor_remove_GeofenceStateChanged, METH_O, nullptr },
    { "add_status_changed", (PyCFunction)GeofenceMonitor_add_StatusChanged, METH_O, nullptr },
    { "remove_status_changed", (PyCFunction)GeofenceMonitor_remove_StatusChanged, METH_O, nullptr },
    { "_from", (PyCFunction)_from_GeofenceMonitor, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GeofenceMonitor[] = {
    { const_cast<char*>("geofences"), (getter)GeofenceMonitor_get_Geofences, nullptr, nullptr, nullptr },
    { const_cast<char*>("last_known_geoposition"), (getter)GeofenceMonitor_get_LastKnownGeoposition, nullptr, nullptr, nullptr },
    { const_cast<char*>("status"), (getter)GeofenceMonitor_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_GeofenceMonitor[] = 
{
    { Py_tp_new, _new_GeofenceMonitor },
    { Py_tp_dealloc, _dealloc_GeofenceMonitor },
    { Py_tp_methods, _methods_GeofenceMonitor },
    { Py_tp_getset, _getset_GeofenceMonitor },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GeofenceMonitor =
{
    "_winrt_Windows_Devices_Geolocation_Geofencing.GeofenceMonitor",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GeofenceMonitor
};

// ----- GeofenceStateChangeReport class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>::python_type;
static const char* _type_name_GeofenceStateChangeReport = "GeofenceStateChangeReport";

static PyObject* _new_GeofenceStateChangeReport(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_GeofenceStateChangeReport };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_GeofenceStateChangeReport(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeofenceStateChangeReport_get_Geofence(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Geofence();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceStateChangeReport_get_Geoposition(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Geoposition();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceStateChangeReport_get_NewState(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.NewState();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* GeofenceStateChangeReport_get_RemovalReason(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.RemovalReason();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_GeofenceStateChangeReport(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>());
    }, nullptr);
}

static PyMethodDef _methods_GeofenceStateChangeReport[] = {
    { "_from", (PyCFunction)_from_GeofenceStateChangeReport, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GeofenceStateChangeReport[] = {
    { const_cast<char*>("geofence"), (getter)GeofenceStateChangeReport_get_Geofence, nullptr, nullptr, nullptr },
    { const_cast<char*>("geoposition"), (getter)GeofenceStateChangeReport_get_Geoposition, nullptr, nullptr, nullptr },
    { const_cast<char*>("new_state"), (getter)GeofenceStateChangeReport_get_NewState, nullptr, nullptr, nullptr },
    { const_cast<char*>("removal_reason"), (getter)GeofenceStateChangeReport_get_RemovalReason, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_GeofenceStateChangeReport[] = 
{
    { Py_tp_new, _new_GeofenceStateChangeReport },
    { Py_tp_dealloc, _dealloc_GeofenceStateChangeReport },
    { Py_tp_methods, _methods_GeofenceStateChangeReport },
    { Py_tp_getset, _getset_GeofenceStateChangeReport },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GeofenceStateChangeReport =
{
    "_winrt_Windows_Devices_Geolocation_Geofencing.GeofenceStateChangeReport",
    sizeof(py::wrapper::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GeofenceStateChangeReport
};

// ----- Windows.Devices.Geolocation.Geofencing Initialization --------------------
static int module_exec(PyObject* module)
{
    py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };
    
    try
    {
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Geofence, &_type_spec_Geofence, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GeofenceMonitor, &_type_spec_GeofenceMonitor, bases.get()).detach());
        py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GeofenceStateChangeReport, &_type_spec_GeofenceStateChangeReport, bases.get()).detach());
    }
    catch(...)
    {
        py::to_PyErr();
        return -1;
    }
    
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Devices.Geolocation.Geofencing");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_winrt_Windows_Devices_Geolocation_Geofencing",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Geolocation_Geofencing (void)
{
    return PyModuleDef_Init(&module_def);
}
