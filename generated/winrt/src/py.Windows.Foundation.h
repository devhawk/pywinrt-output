// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"

#if __has_include("py.Windows.Foundation.Collections.h")
#include "py.Windows.Foundation.Collections.h"
#endif

#include <winrt/Windows.Foundation.h>

namespace py::proj::Windows::Foundation
{
    struct IAsyncActionWithProgress
    {
        virtual ~IAsyncActionWithProgress() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetResults(PyObject*) = 0;
        virtual PyObject* Cancel(PyObject*) = 0;
        virtual PyObject* Close(PyObject*) = 0;
        virtual PyObject* get_Progress() = 0;
        virtual int put_Progress(PyObject*) = 0;
        virtual PyObject* get_Completed() = 0;
        virtual int put_Completed(PyObject*) = 0;
        virtual PyObject* get_ErrorCode() = 0;
        virtual PyObject* get_Id() = 0;
        virtual PyObject* get_Status() = 0;
        virtual PyObject* dunder_await() = 0;
    };
    
    struct IAsyncOperationWithProgress
    {
        virtual ~IAsyncOperationWithProgress() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetResults(PyObject*) = 0;
        virtual PyObject* Cancel(PyObject*) = 0;
        virtual PyObject* Close(PyObject*) = 0;
        virtual PyObject* get_Progress() = 0;
        virtual int put_Progress(PyObject*) = 0;
        virtual PyObject* get_Completed() = 0;
        virtual int put_Completed(PyObject*) = 0;
        virtual PyObject* get_ErrorCode() = 0;
        virtual PyObject* get_Id() = 0;
        virtual PyObject* get_Status() = 0;
        virtual PyObject* dunder_await() = 0;
    };
    
    struct IAsyncOperation
    {
        virtual ~IAsyncOperation() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetResults(PyObject*) = 0;
        virtual PyObject* Cancel(PyObject*) = 0;
        virtual PyObject* Close(PyObject*) = 0;
        virtual PyObject* get_Completed() = 0;
        virtual int put_Completed(PyObject*) = 0;
        virtual PyObject* get_ErrorCode() = 0;
        virtual PyObject* get_Id() = 0;
        virtual PyObject* get_Status() = 0;
        virtual PyObject* dunder_await() = 0;
    };
    
    struct IReferenceArray
    {
        virtual ~IReferenceArray() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetUInt8(PyObject*) = 0;
        virtual PyObject* GetInt16(PyObject*) = 0;
        virtual PyObject* GetUInt16(PyObject*) = 0;
        virtual PyObject* GetInt32(PyObject*) = 0;
        virtual PyObject* GetUInt32(PyObject*) = 0;
        virtual PyObject* GetInt64(PyObject*) = 0;
        virtual PyObject* GetUInt64(PyObject*) = 0;
        virtual PyObject* GetSingle(PyObject*) = 0;
        virtual PyObject* GetDouble(PyObject*) = 0;
        virtual PyObject* GetChar16(PyObject*) = 0;
        virtual PyObject* GetBoolean(PyObject*) = 0;
        virtual PyObject* GetString(PyObject*) = 0;
        virtual PyObject* GetGuid(PyObject*) = 0;
        virtual PyObject* GetDateTime(PyObject*) = 0;
        virtual PyObject* GetTimeSpan(PyObject*) = 0;
        virtual PyObject* GetPoint(PyObject*) = 0;
        virtual PyObject* GetSize(PyObject*) = 0;
        virtual PyObject* GetRect(PyObject*) = 0;
        virtual PyObject* GetUInt8Array(PyObject*) = 0;
        virtual PyObject* GetInt16Array(PyObject*) = 0;
        virtual PyObject* GetUInt16Array(PyObject*) = 0;
        virtual PyObject* GetInt32Array(PyObject*) = 0;
        virtual PyObject* GetUInt32Array(PyObject*) = 0;
        virtual PyObject* GetInt64Array(PyObject*) = 0;
        virtual PyObject* GetUInt64Array(PyObject*) = 0;
        virtual PyObject* GetSingleArray(PyObject*) = 0;
        virtual PyObject* GetDoubleArray(PyObject*) = 0;
        virtual PyObject* GetChar16Array(PyObject*) = 0;
        virtual PyObject* GetBooleanArray(PyObject*) = 0;
        virtual PyObject* GetStringArray(PyObject*) = 0;
        virtual PyObject* GetInspectableArray(PyObject*) = 0;
        virtual PyObject* GetGuidArray(PyObject*) = 0;
        virtual PyObject* GetDateTimeArray(PyObject*) = 0;
        virtual PyObject* GetTimeSpanArray(PyObject*) = 0;
        virtual PyObject* GetPointArray(PyObject*) = 0;
        virtual PyObject* GetSizeArray(PyObject*) = 0;
        virtual PyObject* GetRectArray(PyObject*) = 0;
        virtual PyObject* get_Value() = 0;
        virtual PyObject* get_IsNumericScalar() = 0;
        virtual PyObject* get_Type() = 0;
    };
    
    struct IReference
    {
        virtual ~IReference() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetUInt8(PyObject*) = 0;
        virtual PyObject* GetInt16(PyObject*) = 0;
        virtual PyObject* GetUInt16(PyObject*) = 0;
        virtual PyObject* GetInt32(PyObject*) = 0;
        virtual PyObject* GetUInt32(PyObject*) = 0;
        virtual PyObject* GetInt64(PyObject*) = 0;
        virtual PyObject* GetUInt64(PyObject*) = 0;
        virtual PyObject* GetSingle(PyObject*) = 0;
        virtual PyObject* GetDouble(PyObject*) = 0;
        virtual PyObject* GetChar16(PyObject*) = 0;
        virtual PyObject* GetBoolean(PyObject*) = 0;
        virtual PyObject* GetString(PyObject*) = 0;
        virtual PyObject* GetGuid(PyObject*) = 0;
        virtual PyObject* GetDateTime(PyObject*) = 0;
        virtual PyObject* GetTimeSpan(PyObject*) = 0;
        virtual PyObject* GetPoint(PyObject*) = 0;
        virtual PyObject* GetSize(PyObject*) = 0;
        virtual PyObject* GetRect(PyObject*) = 0;
        virtual PyObject* GetUInt8Array(PyObject*) = 0;
        virtual PyObject* GetInt16Array(PyObject*) = 0;
        virtual PyObject* GetUInt16Array(PyObject*) = 0;
        virtual PyObject* GetInt32Array(PyObject*) = 0;
        virtual PyObject* GetUInt32Array(PyObject*) = 0;
        virtual PyObject* GetInt64Array(PyObject*) = 0;
        virtual PyObject* GetUInt64Array(PyObject*) = 0;
        virtual PyObject* GetSingleArray(PyObject*) = 0;
        virtual PyObject* GetDoubleArray(PyObject*) = 0;
        virtual PyObject* GetChar16Array(PyObject*) = 0;
        virtual PyObject* GetBooleanArray(PyObject*) = 0;
        virtual PyObject* GetStringArray(PyObject*) = 0;
        virtual PyObject* GetInspectableArray(PyObject*) = 0;
        virtual PyObject* GetGuidArray(PyObject*) = 0;
        virtual PyObject* GetDateTimeArray(PyObject*) = 0;
        virtual PyObject* GetTimeSpanArray(PyObject*) = 0;
        virtual PyObject* GetPointArray(PyObject*) = 0;
        virtual PyObject* GetSizeArray(PyObject*) = 0;
        virtual PyObject* GetRectArray(PyObject*) = 0;
        virtual PyObject* get_Value() = 0;
        virtual PyObject* get_IsNumericScalar() = 0;
        virtual PyObject* get_Type() = 0;
    };
}

namespace py::impl::Windows::Foundation
{
    struct AsyncActionCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncActionCompletedHandler get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename TProgress>
    struct AsyncActionProgressHandler
    {
        static winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename TProgress>
    struct AsyncActionWithProgressCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename TResult>
    struct AsyncOperationCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename TResult, typename TProgress>
    struct AsyncOperationProgressHandler
    {
        static winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename TResult, typename TProgress>
    struct AsyncOperationWithProgressCompletedHandler
    {
        static winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    struct DeferralCompletedHandler
    {
        static winrt::Windows::Foundation::DeferralCompletedHandler get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)]()
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle args{ nullptr };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename T>
    struct EventHandler
    {
        static winrt::Windows::Foundation::EventHandler<T> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename TSender, typename TResult>
    struct TypedEventHandler
    {
        static winrt::Windows::Foundation::TypedEventHandler<TSender, TResult> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template<typename TProgress>
    struct IAsyncActionWithProgress : public py::proj::Windows::Foundation::IAsyncActionWithProgress
    {
        IAsyncActionWithProgress(winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* Cancel(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Cancel();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Close(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Close();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetResults(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.GetResults();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Progress() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Progress();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        int put_Progress(PyObject* arg) override
        {
            return py::setter_trycatch_invoker(arg, [=]() -> int
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>(arg);
                
                _obj.Progress(param0);
                return 0;
            });
        }
        PyObject* get_Completed() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Completed();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        int put_Completed(PyObject* arg) override
        {
            return py::setter_trycatch_invoker(arg, [=]() -> int
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>(arg);
                
                _obj.Completed(param0);
                return 0;
            });
        }
        PyObject* get_ErrorCode() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.ErrorCode();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Id() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Id();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Status() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Status();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_await() override { return py::dunder_await(_obj); }
        
        winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> _obj{ nullptr };
    };
    
    template<typename TResult, typename TProgress>
    struct IAsyncOperationWithProgress : public py::proj::Windows::Foundation::IAsyncOperationWithProgress
    {
        IAsyncOperationWithProgress(winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* Cancel(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Cancel();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Close(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Close();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetResults(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetResults();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Progress() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Progress();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        int put_Progress(PyObject* arg) override
        {
            return py::setter_trycatch_invoker(arg, [=]() -> int
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>(arg);
                
                _obj.Progress(param0);
                return 0;
            });
        }
        PyObject* get_Completed() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Completed();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        int put_Completed(PyObject* arg) override
        {
            return py::setter_trycatch_invoker(arg, [=]() -> int
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>(arg);
                
                _obj.Completed(param0);
                return 0;
            });
        }
        PyObject* get_ErrorCode() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.ErrorCode();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Id() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Id();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Status() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Status();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_await() override { return py::dunder_await(_obj); }
        
        winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> _obj{ nullptr };
    };
    
    template<typename TResult>
    struct IAsyncOperation : public py::proj::Windows::Foundation::IAsyncOperation
    {
        IAsyncOperation(winrt::Windows::Foundation::IAsyncOperation<TResult> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* Cancel(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Cancel();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Close(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Close();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetResults(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetResults();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Completed() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Completed();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        int put_Completed(PyObject* arg) override
        {
            return py::setter_trycatch_invoker(arg, [=]() -> int
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>(arg);
                
                _obj.Completed(param0);
                return 0;
            });
        }
        PyObject* get_ErrorCode() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.ErrorCode();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Id() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Id();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Status() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Status();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_await() override { return py::dunder_await(_obj); }
        
        winrt::Windows::Foundation::IAsyncOperation<TResult> _obj{ nullptr };
    };
    
    template<typename T>
    struct IReferenceArray : public py::proj::Windows::Foundation::IReferenceArray
    {
        IReferenceArray(winrt::Windows::Foundation::IReferenceArray<T> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* GetBoolean(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetBoolean();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetBooleanArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<bool> param0 { };
                    
                    _obj.GetBooleanArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetChar16(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetChar16();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetChar16Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<char16_t> param0 { };
                    
                    _obj.GetChar16Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDateTime(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetDateTime();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDateTimeArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };
                    
                    _obj.GetDateTimeArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDouble(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetDouble();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDoubleArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<double> param0 { };
                    
                    _obj.GetDoubleArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetGuid(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetGuid();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetGuidArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::guid> param0 { };
                    
                    _obj.GetGuidArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInspectableArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };
                    
                    _obj.GetInspectableArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt16(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetInt16();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt16Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<int16_t> param0 { };
                    
                    _obj.GetInt16Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt32(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetInt32();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt32Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<int32_t> param0 { };
                    
                    _obj.GetInt32Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt64(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetInt64();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt64Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<int64_t> param0 { };
                    
                    _obj.GetInt64Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetPoint(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetPoint();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetPointArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::Point> param0 { };
                    
                    _obj.GetPointArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetRect(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetRect();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetRectArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };
                    
                    _obj.GetRectArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSingle(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetSingle();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSingleArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<float> param0 { };
                    
                    _obj.GetSingleArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSize(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetSize();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSizeArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::Size> param0 { };
                    
                    _obj.GetSizeArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetString(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetString();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetStringArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::hstring> param0 { };
                    
                    _obj.GetStringArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetTimeSpan(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetTimeSpan();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetTimeSpanArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };
                    
                    _obj.GetTimeSpanArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt16(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt16();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt16Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint16_t> param0 { };
                    
                    _obj.GetUInt16Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt32(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt32();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt32Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint32_t> param0 { };
                    
                    _obj.GetUInt32Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt64(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt64();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt64Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint64_t> param0 { };
                    
                    _obj.GetUInt64Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt8(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt8();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt8Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint8_t> param0 { };
                    
                    _obj.GetUInt8Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Value() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Value();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_IsNumericScalar() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.IsNumericScalar();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Type() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Type();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        
        winrt::Windows::Foundation::IReferenceArray<T> _obj{ nullptr };
    };
    
    template<typename T>
    struct IReference : public py::proj::Windows::Foundation::IReference
    {
        IReference(winrt::Windows::Foundation::IReference<T> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* GetBoolean(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetBoolean();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetBooleanArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<bool> param0 { };
                    
                    _obj.GetBooleanArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetChar16(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetChar16();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetChar16Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<char16_t> param0 { };
                    
                    _obj.GetChar16Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDateTime(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetDateTime();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDateTimeArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };
                    
                    _obj.GetDateTimeArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDouble(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetDouble();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetDoubleArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<double> param0 { };
                    
                    _obj.GetDoubleArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetGuid(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetGuid();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetGuidArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::guid> param0 { };
                    
                    _obj.GetGuidArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInspectableArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };
                    
                    _obj.GetInspectableArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt16(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetInt16();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt16Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<int16_t> param0 { };
                    
                    _obj.GetInt16Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt32(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetInt32();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt32Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<int32_t> param0 { };
                    
                    _obj.GetInt32Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt64(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetInt64();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetInt64Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<int64_t> param0 { };
                    
                    _obj.GetInt64Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetPoint(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetPoint();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetPointArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::Point> param0 { };
                    
                    _obj.GetPointArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetRect(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetRect();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetRectArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };
                    
                    _obj.GetRectArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSingle(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetSingle();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSingleArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<float> param0 { };
                    
                    _obj.GetSingleArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSize(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetSize();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetSizeArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::Size> param0 { };
                    
                    _obj.GetSizeArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetString(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetString();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetStringArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::hstring> param0 { };
                    
                    _obj.GetStringArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetTimeSpan(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetTimeSpan();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetTimeSpanArray(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };
                    
                    _obj.GetTimeSpanArray(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt16(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt16();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt16Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint16_t> param0 { };
                    
                    _obj.GetUInt16Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt32(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt32();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt32Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint32_t> param0 { };
                    
                    _obj.GetUInt32Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt64(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt64();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt64Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint64_t> param0 { };
                    
                    _obj.GetUInt64Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt8(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetUInt8();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetUInt8Array(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::com_array<uint8_t> param0 { };
                    
                    _obj.GetUInt8Array(param0);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return out0.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Value() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Value();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_IsNumericScalar() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.IsNumericScalar();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Type() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Type();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        
        winrt::Windows::Foundation::IReference<T> _obj{ nullptr };
    };
}

namespace py::wrapper::Windows::Foundation
{
    using Deferral = py::winrt_wrapper<winrt::Windows::Foundation::Deferral>;
    using GuidHelper = py::winrt_wrapper<winrt::Windows::Foundation::GuidHelper>;
    using MemoryBuffer = py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>;
    using PropertyValue = py::winrt_wrapper<winrt::Windows::Foundation::PropertyValue>;
    using Uri = py::winrt_wrapper<winrt::Windows::Foundation::Uri>;
    using WwwFormUrlDecoder = py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>;
    using WwwFormUrlDecoderEntry = py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>;
    using IAsyncAction = py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>;
    using IAsyncActionWithProgress = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IAsyncActionWithProgress>;
    using IAsyncInfo = py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>;
    using IAsyncOperationWithProgress = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IAsyncOperationWithProgress>;
    using IAsyncOperation = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IAsyncOperation>;
    using IClosable = py::winrt_wrapper<winrt::Windows::Foundation::IClosable>;
    using IGetActivationFactory = py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>;
    using IMemoryBuffer = py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>;
    using IMemoryBufferReference = py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>;
    using IPropertyValue = py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>;
    using IReferenceArray = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IReferenceArray>;
    using IReference = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::IReference>;
    using IStringable = py::winrt_wrapper<winrt::Windows::Foundation::IStringable>;
    using IWwwFormUrlDecoderEntry = py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>;
    using DateTime = py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>;
    using EventRegistrationToken = py::winrt_struct_wrapper<winrt::event_token>;
    using HResult = py::winrt_struct_wrapper<winrt::hresult>;
    using Point = py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>;
    using Rect = py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>;
    using Size = py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>;
    using TimeSpan = py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>;
}

namespace py
{
    template<>
    struct winrt_type<winrt::Windows::Foundation::Deferral>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::GuidHelper>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::MemoryBuffer>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::PropertyValue>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Uri>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IAsyncAction>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IAsyncInfo>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::IAsyncOperation>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IClosable>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IGetActivationFactory>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IMemoryBuffer>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IPropertyValue>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::IReferenceArray>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::IReference>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IStringable>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::DateTime>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::event_token>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::hresult>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Point>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Rect>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Size>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::TimeSpan>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template <typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress>>
    {
        using abstract = py::proj::Windows::Foundation::IAsyncActionWithProgress;
        using concrete = py::impl::Windows::Foundation::IAsyncActionWithProgress<TProgress>;
    };
    
    template <typename TResult, typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress>>
    {
        using abstract = py::proj::Windows::Foundation::IAsyncOperationWithProgress;
        using concrete = py::impl::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress>;
    };
    
    template <typename TResult>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperation<TResult>>
    {
        using abstract = py::proj::Windows::Foundation::IAsyncOperation;
        using concrete = py::impl::Windows::Foundation::IAsyncOperation<TResult>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::IReferenceArray<T>>
    {
        using abstract = py::proj::Windows::Foundation::IReferenceArray;
        using concrete = py::impl::Windows::Foundation::IReferenceArray<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::IReference<T>>
    {
        using abstract = py::proj::Windows::Foundation::IReference;
        using concrete = py::impl::Windows::Foundation::IReference<T>;
    };
    
    template <>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionCompletedHandler>
    {
        using type = py::impl::Windows::Foundation::AsyncActionCompletedHandler;
    };
    
    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncActionProgressHandler<TProgress>;
    };
    
    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>;
    };
    
    template <typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>
    {
        using type = py::impl::Windows::Foundation::AsyncOperationCompletedHandler<TResult>;
    };
    
    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>;
    };
    
    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>
    {
        using type = py::impl::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>;
    };
    
    template <>
    struct delegate_python_type<winrt::Windows::Foundation::DeferralCompletedHandler>
    {
        using type = py::impl::Windows::Foundation::DeferralCompletedHandler;
    };
    
    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::EventHandler<T>>
    {
        using type = py::impl::Windows::Foundation::EventHandler<T>;
    };
    
    template <typename TSender, typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::TypedEventHandler<TSender, TResult>>
    {
        using type = py::impl::Windows::Foundation::TypedEventHandler<TSender, TResult>;
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::DateTime>
    {
        static PyObject* convert(winrt::Windows::Foundation::DateTime instance) noexcept;
        static winrt::Windows::Foundation::DateTime convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::event_token>
    {
        static PyObject* convert(winrt::event_token instance) noexcept;
        static winrt::event_token convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::hresult>
    {
        static PyObject* convert(winrt::hresult instance) noexcept;
        static winrt::hresult convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Point>
    {
        static PyObject* convert(winrt::Windows::Foundation::Point instance) noexcept;
        static winrt::Windows::Foundation::Point convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Rect>
    {
        static PyObject* convert(winrt::Windows::Foundation::Rect instance) noexcept;
        static winrt::Windows::Foundation::Rect convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Size>
    {
        static PyObject* convert(winrt::Windows::Foundation::Size instance) noexcept;
        static winrt::Windows::Foundation::Size convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::TimeSpan>
    {
        static PyObject* convert(winrt::Windows::Foundation::TimeSpan instance) noexcept;
        static winrt::Windows::Foundation::TimeSpan convert_to(PyObject* obj);
    };
    
}
