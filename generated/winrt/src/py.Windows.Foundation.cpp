// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Foundation.h"

inline int64_t custom_get(winrt::Windows::Foundation::DateTime const& instance) 
{
    return instance.time_since_epoch().count();
}

inline void custom_set(winrt::Windows::Foundation::DateTime& instance, int64_t value) 
{
    instance = winrt::Windows::Foundation::DateTime{ winrt::Windows::Foundation::TimeSpan{ value } };
}

inline int64_t custom_get(winrt::Windows::Foundation::TimeSpan const& instance) 
{
    return instance.count();
}

inline void custom_set(winrt::Windows::Foundation::TimeSpan& instance, int64_t value) 
{
    instance = winrt::Windows::Foundation::TimeSpan{ value };
}

inline int64_t custom_get(winrt::event_token const& instance) 
{
    return instance.value;
}

inline void custom_set(winrt::event_token& instance, int64_t value) 
{
    instance.value = value;
}

inline int32_t custom_get(winrt::hresult const& instance) 
{
    return instance;
}

inline void custom_set(winrt::hresult& instance, int32_t value) 
{
    instance = value;
}

// ----- Deferral class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Deferral>::python_type;
static const char* _type_name_Deferral = "Deferral";

static PyObject* _new_Deferral(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DeferralCompletedHandler>(args, 0);
            
            winrt::Windows::Foundation::Deferral instance{ param0 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_Deferral(py::wrapper::Windows::Foundation::Deferral* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Deferral_Close(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Deferral_Complete(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Complete();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* _from_Deferral(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::Deferral>());
    }, nullptr);
}

static PyObject* _enter_Deferral(py::wrapper::Windows::Foundation::Deferral* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* _exit_Deferral(py::wrapper::Windows::Foundation::Deferral* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }, nullptr);
}

static PyMethodDef _methods_Deferral[] = {
    { "complete", (PyCFunction)Deferral_Complete, METH_VARARGS, nullptr },
    { "close", (PyCFunction)Deferral_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_Deferral, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)_enter_Deferral, METH_O, nullptr },
    { "__exit__",  (PyCFunction)_exit_Deferral,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Deferral[] = {
    { nullptr }
};

static PyType_Slot _type_slots_Deferral[] = 
{
    { Py_tp_new, _new_Deferral },
    { Py_tp_dealloc, _dealloc_Deferral },
    { Py_tp_methods, _methods_Deferral },
    { Py_tp_getset, _getset_Deferral },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Deferral =
{
    "_winrt_Windows_Foundation.Deferral",
    sizeof(py::wrapper::Windows::Foundation::Deferral),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Deferral
};

// ----- GuidHelper class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type;
static const char* _type_name_GuidHelper = "GuidHelper";

static PyObject* _new_GuidHelper(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_GuidHelper };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = winrt::Windows::Foundation::GuidHelper::CreateNewGuid();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);
            
            auto return_value = winrt::Windows::Foundation::GuidHelper::Equals(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* GuidHelper_get_Empty(PyObject* /*unused*/, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = winrt::Windows::Foundation::GuidHelper::Empty();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyMethodDef _methods_GuidHelper[] = {
    { "create_new_guid", (PyCFunction)GuidHelper_CreateNewGuid, METH_VARARGS | METH_STATIC, nullptr },
    { "equals", (PyCFunction)GuidHelper_Equals, METH_VARARGS | METH_STATIC, nullptr },
    { "get_empty", (PyCFunction)GuidHelper_get_Empty, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_GuidHelper[] = {
    { nullptr }
};

static PyType_Slot _type_slots_GuidHelper[] = 
{
    { Py_tp_new, _new_GuidHelper },
    { Py_tp_methods, _methods_GuidHelper },
    { Py_tp_getset, _getset_GuidHelper },
    { 0, nullptr },
};

static PyType_Spec _type_spec_GuidHelper =
{
    "_winrt_Windows_Foundation.GuidHelper",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_GuidHelper
};

// ----- MemoryBuffer class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type;
static const char* _type_name_MemoryBuffer = "MemoryBuffer";

static PyObject* _new_MemoryBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            winrt::Windows::Foundation::MemoryBuffer instance{ param0 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MemoryBuffer_Close(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* MemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.CreateReference();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* _from_MemoryBuffer(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::MemoryBuffer>());
    }, nullptr);
}

static PyObject* _enter_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* _exit_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }, nullptr);
}

static PyMethodDef _methods_MemoryBuffer[] = {
    { "create_reference", (PyCFunction)MemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { "close", (PyCFunction)MemoryBuffer_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_MemoryBuffer, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)_enter_MemoryBuffer, METH_O, nullptr },
    { "__exit__",  (PyCFunction)_exit_MemoryBuffer,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_MemoryBuffer[] = {
    { nullptr }
};

static PyType_Slot _type_slots_MemoryBuffer[] = 
{
    { Py_tp_new, _new_MemoryBuffer },
    { Py_tp_dealloc, _dealloc_MemoryBuffer },
    { Py_tp_methods, _methods_MemoryBuffer },
    { Py_tp_getset, _getset_MemoryBuffer },
    { 0, nullptr },
};

static PyType_Spec _type_spec_MemoryBuffer =
{
    "_winrt_Windows_Foundation.MemoryBuffer",
    sizeof(py::wrapper::Windows::Foundation::MemoryBuffer),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_MemoryBuffer
};

// ----- PropertyValue class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::PropertyValue>::python_type;
static const char* _type_name_PropertyValue = "PropertyValue";

static PyObject* _new_PropertyValue(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_PropertyValue };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static PyObject* PropertyValue_CreateBoolean(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<bool>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateBoolean(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateBooleanArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<bool>>(args, 0);
            auto param0 = winrt::array_view<const bool>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateBooleanArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateChar16(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<char16_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateChar16(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateChar16Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<char16_t>>(args, 0);
            auto param0 = winrt::array_view<const char16_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateChar16Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateDateTime(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateDateTime(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateDateTimeArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Foundation::DateTime>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Foundation::DateTime>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateDateTimeArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateDouble(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<double>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateDouble(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateDoubleArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<double>>(args, 0);
            auto param0 = winrt::array_view<const double>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateDoubleArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateEmpty(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateEmpty();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateGuid(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateGuid(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateGuidArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::guid>>(args, 0);
            auto param0 = winrt::array_view<const winrt::guid>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateGuidArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInspectable(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInspectable(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInspectableArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Foundation::IInspectable>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Foundation::IInspectable>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInspectableArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInt16(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<int16_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInt16(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInt16Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<int16_t>>(args, 0);
            auto param0 = winrt::array_view<const int16_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInt16Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInt32(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<int32_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInt32(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInt32Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<int32_t>>(args, 0);
            auto param0 = winrt::array_view<const int32_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInt32Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInt64(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<int64_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInt64(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateInt64Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<int64_t>>(args, 0);
            auto param0 = winrt::array_view<const int64_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateInt64Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreatePoint(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreatePoint(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreatePointArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Foundation::Point>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreatePointArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateRect(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateRect(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateRectArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Rect>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Foundation::Rect>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateRectArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateSingle(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<float>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateSingle(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateSingleArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<float>>(args, 0);
            auto param0 = winrt::array_view<const float>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateSingleArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateSize(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateSize(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateSizeArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Size>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Foundation::Size>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateSizeArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateString(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateString(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateStringArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::hstring>>(args, 0);
            auto param0 = winrt::array_view<const winrt::hstring>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateStringArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateTimeSpan(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateTimeSpan(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateTimeSpanArray(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Foundation::TimeSpan>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Foundation::TimeSpan>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateTimeSpanArray(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt16(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<uint16_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt16(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt16Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<uint16_t>>(args, 0);
            auto param0 = winrt::array_view<const uint16_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt16Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt32(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt32(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt32Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<uint32_t>>(args, 0);
            auto param0 = winrt::array_view<const uint32_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt32Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt64(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt64(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt64Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<uint64_t>>(args, 0);
            auto param0 = winrt::array_view<const uint64_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt64Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt8(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<uint8_t>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt8(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt8Array(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto _param0 = py::convert_to<winrt::com_array<uint8_t>>(args, 0);
            auto param0 = winrt::array_view<const uint8_t>(_param0.data(), _param0.data() + _param0.size());
            
            auto return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt8Array(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyMethodDef _methods_PropertyValue[] = {
    { "create_empty", (PyCFunction)PropertyValue_CreateEmpty, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint8", (PyCFunction)PropertyValue_CreateUInt8, METH_VARARGS | METH_STATIC, nullptr },
    { "create_int16", (PyCFunction)PropertyValue_CreateInt16, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint16", (PyCFunction)PropertyValue_CreateUInt16, METH_VARARGS | METH_STATIC, nullptr },
    { "create_int32", (PyCFunction)PropertyValue_CreateInt32, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint32", (PyCFunction)PropertyValue_CreateUInt32, METH_VARARGS | METH_STATIC, nullptr },
    { "create_int64", (PyCFunction)PropertyValue_CreateInt64, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint64", (PyCFunction)PropertyValue_CreateUInt64, METH_VARARGS | METH_STATIC, nullptr },
    { "create_single", (PyCFunction)PropertyValue_CreateSingle, METH_VARARGS | METH_STATIC, nullptr },
    { "create_double", (PyCFunction)PropertyValue_CreateDouble, METH_VARARGS | METH_STATIC, nullptr },
    { "create_char16", (PyCFunction)PropertyValue_CreateChar16, METH_VARARGS | METH_STATIC, nullptr },
    { "create_boolean", (PyCFunction)PropertyValue_CreateBoolean, METH_VARARGS | METH_STATIC, nullptr },
    { "create_string", (PyCFunction)PropertyValue_CreateString, METH_VARARGS | METH_STATIC, nullptr },
    { "create_inspectable", (PyCFunction)PropertyValue_CreateInspectable, METH_VARARGS | METH_STATIC, nullptr },
    { "create_guid", (PyCFunction)PropertyValue_CreateGuid, METH_VARARGS | METH_STATIC, nullptr },
    { "create_date_time", (PyCFunction)PropertyValue_CreateDateTime, METH_VARARGS | METH_STATIC, nullptr },
    { "create_time_span", (PyCFunction)PropertyValue_CreateTimeSpan, METH_VARARGS | METH_STATIC, nullptr },
    { "create_point", (PyCFunction)PropertyValue_CreatePoint, METH_VARARGS | METH_STATIC, nullptr },
    { "create_size", (PyCFunction)PropertyValue_CreateSize, METH_VARARGS | METH_STATIC, nullptr },
    { "create_rect", (PyCFunction)PropertyValue_CreateRect, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint8_array", (PyCFunction)PropertyValue_CreateUInt8Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_int16_array", (PyCFunction)PropertyValue_CreateInt16Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint16_array", (PyCFunction)PropertyValue_CreateUInt16Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_int32_array", (PyCFunction)PropertyValue_CreateInt32Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint32_array", (PyCFunction)PropertyValue_CreateUInt32Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_int64_array", (PyCFunction)PropertyValue_CreateInt64Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_uint64_array", (PyCFunction)PropertyValue_CreateUInt64Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_single_array", (PyCFunction)PropertyValue_CreateSingleArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_double_array", (PyCFunction)PropertyValue_CreateDoubleArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_char16_array", (PyCFunction)PropertyValue_CreateChar16Array, METH_VARARGS | METH_STATIC, nullptr },
    { "create_boolean_array", (PyCFunction)PropertyValue_CreateBooleanArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_string_array", (PyCFunction)PropertyValue_CreateStringArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_inspectable_array", (PyCFunction)PropertyValue_CreateInspectableArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_guid_array", (PyCFunction)PropertyValue_CreateGuidArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_date_time_array", (PyCFunction)PropertyValue_CreateDateTimeArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_time_span_array", (PyCFunction)PropertyValue_CreateTimeSpanArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_point_array", (PyCFunction)PropertyValue_CreatePointArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_size_array", (PyCFunction)PropertyValue_CreateSizeArray, METH_VARARGS | METH_STATIC, nullptr },
    { "create_rect_array", (PyCFunction)PropertyValue_CreateRectArray, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_PropertyValue[] = {
    { nullptr }
};

static PyType_Slot _type_slots_PropertyValue[] = 
{
    { Py_tp_new, _new_PropertyValue },
    { Py_tp_methods, _methods_PropertyValue },
    { Py_tp_getset, _getset_PropertyValue },
    { 0, nullptr },
};

static PyType_Spec _type_spec_PropertyValue =
{
    "_winrt_Windows_Foundation.PropertyValue",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_PropertyValue
};

// ----- Uri class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Uri>::python_type;
static const char* _type_name_Uri = "Uri";

static PyObject* _new_Uri(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            winrt::Windows::Foundation::Uri instance{ param0 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            winrt::Windows::Foundation::Uri instance{ param0, param1 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_Uri(py::wrapper::Windows::Foundation::Uri* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Uri_CombineUri(py::wrapper::Windows::Foundation::Uri* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.CombineUri(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Uri_Equals(py::wrapper::Windows::Foundation::Uri* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
            
            auto return_value = self->obj.Equals(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::Uri::EscapeComponent(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Uri_ToString(py::wrapper::Windows::Foundation::Uri* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.ToString();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Foundation::Uri::UnescapeComponent(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* Uri_get_AbsoluteUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AbsoluteUri();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_DisplayUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.DisplayUri();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Domain(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Domain();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Extension(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Extension();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Fragment(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Fragment();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Host(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Host();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Password(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Password();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Path(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Path();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Port(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Port();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Query(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Query();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_QueryParsed(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.QueryParsed();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_RawUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.RawUri();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_SchemeName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.SchemeName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_Suspicious(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Suspicious();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_UserName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.UserName();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_AbsoluteCanonicalUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.AbsoluteCanonicalUri();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* Uri_get_DisplayIri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.DisplayIri();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_Uri(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::Uri>());
    }, nullptr);
}

static PyObject* _str_Uri(py::wrapper::Windows::Foundation::Uri* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.ToString());
    }, nullptr);
}

static PyMethodDef _methods_Uri[] = {
    { "equals", (PyCFunction)Uri_Equals, METH_VARARGS, nullptr },
    { "combine_uri", (PyCFunction)Uri_CombineUri, METH_VARARGS, nullptr },
    { "to_string", (PyCFunction)Uri_ToString, METH_VARARGS, nullptr },
    { "unescape_component", (PyCFunction)Uri_UnescapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { "escape_component", (PyCFunction)Uri_EscapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)_from_Uri, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_Uri[] = {
    { const_cast<char*>("absolute_uri"), (getter)Uri_get_AbsoluteUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("display_uri"), (getter)Uri_get_DisplayUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("domain"), (getter)Uri_get_Domain, nullptr, nullptr, nullptr },
    { const_cast<char*>("extension"), (getter)Uri_get_Extension, nullptr, nullptr, nullptr },
    { const_cast<char*>("fragment"), (getter)Uri_get_Fragment, nullptr, nullptr, nullptr },
    { const_cast<char*>("host"), (getter)Uri_get_Host, nullptr, nullptr, nullptr },
    { const_cast<char*>("password"), (getter)Uri_get_Password, nullptr, nullptr, nullptr },
    { const_cast<char*>("path"), (getter)Uri_get_Path, nullptr, nullptr, nullptr },
    { const_cast<char*>("port"), (getter)Uri_get_Port, nullptr, nullptr, nullptr },
    { const_cast<char*>("query"), (getter)Uri_get_Query, nullptr, nullptr, nullptr },
    { const_cast<char*>("query_parsed"), (getter)Uri_get_QueryParsed, nullptr, nullptr, nullptr },
    { const_cast<char*>("raw_uri"), (getter)Uri_get_RawUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("scheme_name"), (getter)Uri_get_SchemeName, nullptr, nullptr, nullptr },
    { const_cast<char*>("suspicious"), (getter)Uri_get_Suspicious, nullptr, nullptr, nullptr },
    { const_cast<char*>("user_name"), (getter)Uri_get_UserName, nullptr, nullptr, nullptr },
    { const_cast<char*>("absolute_canonical_uri"), (getter)Uri_get_AbsoluteCanonicalUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("display_iri"), (getter)Uri_get_DisplayIri, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Uri[] = 
{
    { Py_tp_new, _new_Uri },
    { Py_tp_dealloc, _dealloc_Uri },
    { Py_tp_methods, _methods_Uri },
    { Py_tp_getset, _getset_Uri },
    { Py_tp_str, _str_Uri },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Uri =
{
    "_winrt_Windows_Foundation.Uri",
    sizeof(py::wrapper::Windows::Foundation::Uri),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Uri
};

// ----- WwwFormUrlDecoder class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type;
static const char* _type_name_WwwFormUrlDecoder = "WwwFormUrlDecoder";

static PyObject* _new_WwwFormUrlDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            winrt::Windows::Foundation::WwwFormUrlDecoder instance{ param0 };
            return py::wrap(instance, type);
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static void _dealloc_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoder_First(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.First();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetAt(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetAt(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetFirstValueByName(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetMany(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::size_type>(args, 1);
            winrt::com_array<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::get() );
            
            auto return_value = self->obj.GetMany(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            py::pyobj_handle out1{ py::convert(param1) };
            if (!out1) 
            {
                return nullptr;
            }
            return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_IndexOf(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
            uint32_t param1 {  };
            
            auto return_value = self->obj.IndexOf(param0, param1);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            py::pyobj_handle out1{ py::convert(param1) };
            if (!out1) 
            {
                return nullptr;
            }
            return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_get_Size(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Size();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoder>());
    }, nullptr);
}

static PyObject* _iterator_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.First());
    }, nullptr);
}

static Py_ssize_t _seq_length_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self)
{
    return py::trycatch_invoker([=]() -> Py_ssize_t
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }, -1);
}

static PyObject* _seq_item_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, Py_ssize_t i)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
    }, nullptr);
}

static PyMethodDef _methods_WwwFormUrlDecoder[] = {
    { "get_first_value_by_name", (PyCFunction)WwwFormUrlDecoder_GetFirstValueByName, METH_VARARGS, nullptr },
    { "first", (PyCFunction)WwwFormUrlDecoder_First, METH_VARARGS, nullptr },
    { "get_at", (PyCFunction)WwwFormUrlDecoder_GetAt, METH_VARARGS, nullptr },
    { "index_of", (PyCFunction)WwwFormUrlDecoder_IndexOf, METH_VARARGS, nullptr },
    { "get_many", (PyCFunction)WwwFormUrlDecoder_GetMany, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_WwwFormUrlDecoder, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_WwwFormUrlDecoder[] = {
    { const_cast<char*>("size"), (getter)WwwFormUrlDecoder_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_WwwFormUrlDecoder[] = 
{
    { Py_tp_new, _new_WwwFormUrlDecoder },
    { Py_tp_dealloc, _dealloc_WwwFormUrlDecoder },
    { Py_tp_methods, _methods_WwwFormUrlDecoder },
    { Py_tp_getset, _getset_WwwFormUrlDecoder },
    { Py_tp_iter, _iterator_WwwFormUrlDecoder },
    { Py_sq_length, _seq_length_WwwFormUrlDecoder },
    { Py_sq_item, _seq_item_WwwFormUrlDecoder },
    { 0, nullptr },
};

static PyType_Spec _type_spec_WwwFormUrlDecoder =
{
    "_winrt_Windows_Foundation.WwwFormUrlDecoder",
    sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoder),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_WwwFormUrlDecoder
};

// ----- WwwFormUrlDecoderEntry class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type;
static const char* _type_name_WwwFormUrlDecoderEntry = "WwwFormUrlDecoderEntry";

static PyObject* _new_WwwFormUrlDecoderEntry(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    std::string msg{ _type_name_WwwFormUrlDecoderEntry };
    msg.append(" is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_WwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* WwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Value();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>());
    }, nullptr);
}

static PyMethodDef _methods_WwwFormUrlDecoderEntry[] = {
    { "_from", (PyCFunction)_from_WwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_WwwFormUrlDecoderEntry[] = {
    { const_cast<char*>("name"), (getter)WwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("value"), (getter)WwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_WwwFormUrlDecoderEntry[] = 
{
    { Py_tp_new, _new_WwwFormUrlDecoderEntry },
    { Py_tp_dealloc, _dealloc_WwwFormUrlDecoderEntry },
    { Py_tp_methods, _methods_WwwFormUrlDecoderEntry },
    { Py_tp_getset, _getset_WwwFormUrlDecoderEntry },
    { 0, nullptr },
};

static PyType_Spec _type_spec_WwwFormUrlDecoderEntry =
{
    "_winrt_Windows_Foundation.WwwFormUrlDecoderEntry",
    sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_WwwFormUrlDecoderEntry
};

// ----- IAsyncAction interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type;
static const char* _type_name_IAsyncAction = "IAsyncAction";

static PyObject* _new_IAsyncAction(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IAsyncAction };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncAction_Cancel(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Cancel();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IAsyncAction_Close(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IAsyncAction_GetResults(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.GetResults();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IAsyncAction_get_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Completed();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static int IAsyncAction_put_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);
        
        self->obj.Completed(param0);
        return 0;
    });
}

static PyObject* IAsyncAction_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.ErrorCode();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IAsyncAction_get_Id(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Id();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IAsyncAction_get_Status(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Status();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_IAsyncAction(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncAction>());
    }, nullptr);
}

static PyObject* _await_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self)
{
    return py::dunder_await(self->obj);
}

static PyMethodDef _methods_IAsyncAction[] = {
    { "get_results", (PyCFunction)IAsyncAction_GetResults, METH_VARARGS, nullptr },
    { "cancel", (PyCFunction)IAsyncAction_Cancel, METH_VARARGS, nullptr },
    { "close", (PyCFunction)IAsyncAction_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_IAsyncAction, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IAsyncAction[] = {
    { const_cast<char*>("completed"), (getter)IAsyncAction_get_Completed, (setter)IAsyncAction_put_Completed, nullptr, nullptr },
    { const_cast<char*>("error_code"), (getter)IAsyncAction_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("id"), (getter)IAsyncAction_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("status"), (getter)IAsyncAction_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IAsyncAction[] = 
{
    { Py_tp_new, _new_IAsyncAction },
    { Py_tp_dealloc, _dealloc_IAsyncAction },
    { Py_tp_methods, _methods_IAsyncAction },
    { Py_tp_getset, _getset_IAsyncAction },
    { Py_am_await, (unaryfunc)_await_IAsyncAction },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IAsyncAction =
{
    "_winrt_Windows_Foundation.IAsyncAction",
    sizeof(py::wrapper::Windows::Foundation::IAsyncAction),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IAsyncAction
};

// ----- IAsyncActionWithProgress interface --------------------

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::python_type;
static const char* _type_name_IAsyncActionWithProgress = "IAsyncActionWithProgress";

static PyObject* _new_IAsyncActionWithProgress(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IAsyncActionWithProgress };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IAsyncActionWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args)
{
    return self->obj->Cancel(args);
}

static PyObject* IAsyncActionWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args)
{
    return self->obj->Close(args);
}

static PyObject* IAsyncActionWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncActionWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Progress();
}

static int IAsyncActionWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/)
{
    return self->obj->put_Progress(arg);
}

static PyObject* IAsyncActionWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncActionWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/)
{
    return self->obj->put_Completed(arg);
}

static PyObject* IAsyncActionWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/)
{
    return self->obj->get_ErrorCode();
}

static PyObject* IAsyncActionWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Id();
}

static PyObject* IAsyncActionWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Status();
}

static PyObject* _await_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self)
{
    return self->obj->dunder_await();
}

static PyMethodDef _methods_IAsyncActionWithProgress[] = {
    { "get_results", (PyCFunction)IAsyncActionWithProgress_GetResults, METH_VARARGS, nullptr },
    { "cancel", (PyCFunction)IAsyncActionWithProgress_Cancel, METH_VARARGS, nullptr },
    { "close", (PyCFunction)IAsyncActionWithProgress_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IAsyncActionWithProgress[] = {
    { const_cast<char*>("progress"), (getter)IAsyncActionWithProgress_get_Progress, (setter)IAsyncActionWithProgress_put_Progress, nullptr, nullptr },
    { const_cast<char*>("completed"), (getter)IAsyncActionWithProgress_get_Completed, (setter)IAsyncActionWithProgress_put_Completed, nullptr, nullptr },
    { const_cast<char*>("error_code"), (getter)IAsyncActionWithProgress_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("id"), (getter)IAsyncActionWithProgress_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("status"), (getter)IAsyncActionWithProgress_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IAsyncActionWithProgress[] = 
{
    { Py_tp_new, _new_IAsyncActionWithProgress },
    { Py_tp_dealloc, _dealloc_IAsyncActionWithProgress },
    { Py_tp_methods, _methods_IAsyncActionWithProgress },
    { Py_tp_getset, _getset_IAsyncActionWithProgress },
    { Py_am_await, (unaryfunc)_await_IAsyncActionWithProgress },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IAsyncActionWithProgress =
{
    "_winrt_Windows_Foundation.IAsyncActionWithProgress",
    sizeof(py::wrapper::Windows::Foundation::IAsyncActionWithProgress),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IAsyncActionWithProgress
};

// ----- IAsyncInfo interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type;
static const char* _type_name_IAsyncInfo = "IAsyncInfo";

static PyObject* _new_IAsyncInfo(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IAsyncInfo };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IAsyncInfo(py::wrapper::Windows::Foundation::IAsyncInfo* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncInfo_Cancel(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Cancel();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IAsyncInfo_Close(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IAsyncInfo_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.ErrorCode();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IAsyncInfo_get_Id(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Id();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IAsyncInfo_get_Status(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Status();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_IAsyncInfo(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncInfo>());
    }, nullptr);
}

static PyMethodDef _methods_IAsyncInfo[] = {
    { "cancel", (PyCFunction)IAsyncInfo_Cancel, METH_VARARGS, nullptr },
    { "close", (PyCFunction)IAsyncInfo_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_IAsyncInfo, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IAsyncInfo[] = {
    { const_cast<char*>("error_code"), (getter)IAsyncInfo_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("id"), (getter)IAsyncInfo_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("status"), (getter)IAsyncInfo_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IAsyncInfo[] = 
{
    { Py_tp_new, _new_IAsyncInfo },
    { Py_tp_dealloc, _dealloc_IAsyncInfo },
    { Py_tp_methods, _methods_IAsyncInfo },
    { Py_tp_getset, _getset_IAsyncInfo },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IAsyncInfo =
{
    "_winrt_Windows_Foundation.IAsyncInfo",
    sizeof(py::wrapper::Windows::Foundation::IAsyncInfo),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IAsyncInfo
};

// ----- IAsyncOperationWithProgress interface --------------------

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::python_type;
static const char* _type_name_IAsyncOperationWithProgress = "IAsyncOperationWithProgress";

static PyObject* _new_IAsyncOperationWithProgress(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IAsyncOperationWithProgress };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperationWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args)
{
    return self->obj->Cancel(args);
}

static PyObject* IAsyncOperationWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args)
{
    return self->obj->Close(args);
}

static PyObject* IAsyncOperationWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperationWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Progress();
}

static int IAsyncOperationWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/)
{
    return self->obj->put_Progress(arg);
}

static PyObject* IAsyncOperationWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncOperationWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/)
{
    return self->obj->put_Completed(arg);
}

static PyObject* IAsyncOperationWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/)
{
    return self->obj->get_ErrorCode();
}

static PyObject* IAsyncOperationWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Id();
}

static PyObject* IAsyncOperationWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/)
{
    return self->obj->get_Status();
}

static PyObject* _await_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self)
{
    return self->obj->dunder_await();
}

static PyMethodDef _methods_IAsyncOperationWithProgress[] = {
    { "get_results", (PyCFunction)IAsyncOperationWithProgress_GetResults, METH_VARARGS, nullptr },
    { "cancel", (PyCFunction)IAsyncOperationWithProgress_Cancel, METH_VARARGS, nullptr },
    { "close", (PyCFunction)IAsyncOperationWithProgress_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IAsyncOperationWithProgress[] = {
    { const_cast<char*>("progress"), (getter)IAsyncOperationWithProgress_get_Progress, (setter)IAsyncOperationWithProgress_put_Progress, nullptr, nullptr },
    { const_cast<char*>("completed"), (getter)IAsyncOperationWithProgress_get_Completed, (setter)IAsyncOperationWithProgress_put_Completed, nullptr, nullptr },
    { const_cast<char*>("error_code"), (getter)IAsyncOperationWithProgress_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("id"), (getter)IAsyncOperationWithProgress_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("status"), (getter)IAsyncOperationWithProgress_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IAsyncOperationWithProgress[] = 
{
    { Py_tp_new, _new_IAsyncOperationWithProgress },
    { Py_tp_dealloc, _dealloc_IAsyncOperationWithProgress },
    { Py_tp_methods, _methods_IAsyncOperationWithProgress },
    { Py_tp_getset, _getset_IAsyncOperationWithProgress },
    { Py_am_await, (unaryfunc)_await_IAsyncOperationWithProgress },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IAsyncOperationWithProgress =
{
    "_winrt_Windows_Foundation.IAsyncOperationWithProgress",
    sizeof(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IAsyncOperationWithProgress
};

// ----- IAsyncOperation interface --------------------

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncOperation>::python_type;
static const char* _type_name_IAsyncOperation = "IAsyncOperation";

static PyObject* _new_IAsyncOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IAsyncOperation };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperation_Cancel(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args)
{
    return self->obj->Cancel(args);
}

static PyObject* IAsyncOperation_Close(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args)
{
    return self->obj->Close(args);
}

static PyObject* IAsyncOperation_GetResults(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperation_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncOperation_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* arg, void* /*unused*/)
{
    return self->obj->put_Completed(arg);
}

static PyObject* IAsyncOperation_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/)
{
    return self->obj->get_ErrorCode();
}

static PyObject* IAsyncOperation_get_Id(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/)
{
    return self->obj->get_Id();
}

static PyObject* IAsyncOperation_get_Status(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/)
{
    return self->obj->get_Status();
}

static PyObject* _await_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self)
{
    return self->obj->dunder_await();
}

static PyMethodDef _methods_IAsyncOperation[] = {
    { "get_results", (PyCFunction)IAsyncOperation_GetResults, METH_VARARGS, nullptr },
    { "cancel", (PyCFunction)IAsyncOperation_Cancel, METH_VARARGS, nullptr },
    { "close", (PyCFunction)IAsyncOperation_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IAsyncOperation[] = {
    { const_cast<char*>("completed"), (getter)IAsyncOperation_get_Completed, (setter)IAsyncOperation_put_Completed, nullptr, nullptr },
    { const_cast<char*>("error_code"), (getter)IAsyncOperation_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("id"), (getter)IAsyncOperation_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("status"), (getter)IAsyncOperation_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IAsyncOperation[] = 
{
    { Py_tp_new, _new_IAsyncOperation },
    { Py_tp_dealloc, _dealloc_IAsyncOperation },
    { Py_tp_methods, _methods_IAsyncOperation },
    { Py_tp_getset, _getset_IAsyncOperation },
    { Py_am_await, (unaryfunc)_await_IAsyncOperation },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IAsyncOperation =
{
    "_winrt_Windows_Foundation.IAsyncOperation",
    sizeof(py::wrapper::Windows::Foundation::IAsyncOperation),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IAsyncOperation
};

// ----- IClosable interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type;
static const char* _type_name_IClosable = "IClosable";

static PyObject* _new_IClosable(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IClosable };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IClosable(py::wrapper::Windows::Foundation::IClosable* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IClosable_Close(py::wrapper::Windows::Foundation::IClosable* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* _from_IClosable(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IClosable>());
    }, nullptr);
}

static PyObject* _enter_IClosable(py::wrapper::Windows::Foundation::IClosable* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* _exit_IClosable(py::wrapper::Windows::Foundation::IClosable* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }, nullptr);
}

static PyMethodDef _methods_IClosable[] = {
    { "close", (PyCFunction)IClosable_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_IClosable, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)_enter_IClosable, METH_O, nullptr },
    { "__exit__",  (PyCFunction)_exit_IClosable,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IClosable[] = {
    { nullptr }
};

static PyType_Slot _type_slots_IClosable[] = 
{
    { Py_tp_new, _new_IClosable },
    { Py_tp_dealloc, _dealloc_IClosable },
    { Py_tp_methods, _methods_IClosable },
    { Py_tp_getset, _getset_IClosable },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IClosable =
{
    "_winrt_Windows_Foundation.IClosable",
    sizeof(py::wrapper::Windows::Foundation::IClosable),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IClosable
};

// ----- IGetActivationFactory interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type;
static const char* _type_name_IGetActivationFactory = "IGetActivationFactory";

static PyObject* _new_IGetActivationFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IGetActivationFactory };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IGetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGetActivationFactory_GetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetActivationFactory(param0);
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* _from_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IGetActivationFactory>());
    }, nullptr);
}

static PyMethodDef _methods_IGetActivationFactory[] = {
    { "get_activation_factory", (PyCFunction)IGetActivationFactory_GetActivationFactory, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_IGetActivationFactory, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IGetActivationFactory[] = {
    { nullptr }
};

static PyType_Slot _type_slots_IGetActivationFactory[] = 
{
    { Py_tp_new, _new_IGetActivationFactory },
    { Py_tp_dealloc, _dealloc_IGetActivationFactory },
    { Py_tp_methods, _methods_IGetActivationFactory },
    { Py_tp_getset, _getset_IGetActivationFactory },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IGetActivationFactory =
{
    "_winrt_Windows_Foundation.IGetActivationFactory",
    sizeof(py::wrapper::Windows::Foundation::IGetActivationFactory),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IGetActivationFactory
};

// ----- IMemoryBuffer interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type;
static const char* _type_name_IMemoryBuffer = "IMemoryBuffer";

static PyObject* _new_IMemoryBuffer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IMemoryBuffer };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBuffer_Close(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IMemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.CreateReference();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* _from_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBuffer>());
    }, nullptr);
}

static PyObject* _enter_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* _exit_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }, nullptr);
}

static PyMethodDef _methods_IMemoryBuffer[] = {
    { "create_reference", (PyCFunction)IMemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { "close", (PyCFunction)IMemoryBuffer_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_IMemoryBuffer, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)_enter_IMemoryBuffer, METH_O, nullptr },
    { "__exit__",  (PyCFunction)_exit_IMemoryBuffer,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IMemoryBuffer[] = {
    { nullptr }
};

static PyType_Slot _type_slots_IMemoryBuffer[] = 
{
    { Py_tp_new, _new_IMemoryBuffer },
    { Py_tp_dealloc, _dealloc_IMemoryBuffer },
    { Py_tp_methods, _methods_IMemoryBuffer },
    { Py_tp_getset, _getset_IMemoryBuffer },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IMemoryBuffer =
{
    "_winrt_Windows_Foundation.IMemoryBuffer",
    sizeof(py::wrapper::Windows::Foundation::IMemoryBuffer),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IMemoryBuffer
};

// ----- IMemoryBufferReference interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type;
static const char* _type_name_IMemoryBufferReference = "IMemoryBufferReference";

static PyObject* _new_IMemoryBufferReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IMemoryBufferReference };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBufferReference_Close(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            self->obj.Close();
            
            Py_RETURN_NONE;
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IMemoryBufferReference_get_Capacity(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Capacity();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IMemoryBufferReference_add_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IMemoryBufferReference, winrt::Windows::Foundation::IInspectable>>(arg);
        
        auto return_value = self->obj.Closed(param0);
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IMemoryBufferReference_remove_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.Closed(param0);
        
        Py_RETURN_NONE;
    }, nullptr);
}

static PyObject* _from_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBufferReference>());
    }, nullptr);
}

static PyObject* _enter_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self)
{
    Py_INCREF(self);
    return (PyObject*)self;
}

static PyObject* _exit_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        self->obj.Close();
        Py_RETURN_FALSE;
    }, nullptr);
}

static PyMethodDef _methods_IMemoryBufferReference[] = {
    { "close", (PyCFunction)IMemoryBufferReference_Close, METH_VARARGS, nullptr },
    { "add_closed", (PyCFunction)IMemoryBufferReference_add_Closed, METH_O, nullptr },
    { "remove_closed", (PyCFunction)IMemoryBufferReference_remove_Closed, METH_O, nullptr },
    { "_from", (PyCFunction)_from_IMemoryBufferReference, METH_O | METH_STATIC, nullptr },
    { "__enter__", (PyCFunction)_enter_IMemoryBufferReference, METH_O, nullptr },
    { "__exit__",  (PyCFunction)_exit_IMemoryBufferReference,  METH_O, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IMemoryBufferReference[] = {
    { const_cast<char*>("capacity"), (getter)IMemoryBufferReference_get_Capacity, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IMemoryBufferReference[] = 
{
    { Py_tp_new, _new_IMemoryBufferReference },
    { Py_tp_dealloc, _dealloc_IMemoryBufferReference },
    { Py_tp_methods, _methods_IMemoryBufferReference },
    { Py_tp_getset, _getset_IMemoryBufferReference },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IMemoryBufferReference =
{
    "_winrt_Windows_Foundation.IMemoryBufferReference",
    sizeof(py::wrapper::Windows::Foundation::IMemoryBufferReference),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IMemoryBufferReference
};

// ----- IPropertyValue interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IPropertyValue>::python_type;
static const char* _type_name_IPropertyValue = "IPropertyValue";

static PyObject* _new_IPropertyValue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IPropertyValue };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IPropertyValue(py::wrapper::Windows::Foundation::IPropertyValue* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IPropertyValue_GetBoolean(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetBoolean();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetBooleanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<bool> param0 { };
            
            self->obj.GetBooleanArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetChar16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetChar16();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetChar16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<char16_t> param0 { };
            
            self->obj.GetChar16Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetDateTime(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetDateTime();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetDateTimeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };
            
            self->obj.GetDateTimeArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetDouble(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetDouble();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetDoubleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<double> param0 { };
            
            self->obj.GetDoubleArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetGuid(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetGuid();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetGuidArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::guid> param0 { };
            
            self->obj.GetGuidArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetInspectableArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };
            
            self->obj.GetInspectableArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetInt16();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<int16_t> param0 { };
            
            self->obj.GetInt16Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetInt32();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<int32_t> param0 { };
            
            self->obj.GetInt32Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetInt64();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<int64_t> param0 { };
            
            self->obj.GetInt64Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetPoint(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetPoint();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetPointArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::Windows::Foundation::Point> param0 { };
            
            self->obj.GetPointArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetRect(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetRect();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetRectArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };
            
            self->obj.GetRectArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetSingle(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetSingle();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetSingleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<float> param0 { };
            
            self->obj.GetSingleArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetSize(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetSize();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetSizeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::Windows::Foundation::Size> param0 { };
            
            self->obj.GetSizeArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetString(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetString();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetStringArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::hstring> param0 { };
            
            self->obj.GetStringArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetTimeSpan(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetTimeSpan();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetTimeSpanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };
            
            self->obj.GetTimeSpanArray(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetUInt16();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<uint16_t> param0 { };
            
            self->obj.GetUInt16Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetUInt32();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<uint32_t> param0 { };
            
            self->obj.GetUInt32Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetUInt64();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<uint64_t> param0 { };
            
            self->obj.GetUInt64Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt8(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.GetUInt8();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt8Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::com_array<uint8_t> param0 { };
            
            self->obj.GetUInt8Array(param0);
            
            py::pyobj_handle out0{ py::convert(param0) };
            if (!out0) 
            {
                return nullptr;
            }
            return out0.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* IPropertyValue_get_IsNumericScalar(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.IsNumericScalar();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IPropertyValue_get_Type(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Type();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_IPropertyValue(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IPropertyValue>());
    }, nullptr);
}

static PyMethodDef _methods_IPropertyValue[] = {
    { "get_uint8", (PyCFunction)IPropertyValue_GetUInt8, METH_VARARGS, nullptr },
    { "get_int16", (PyCFunction)IPropertyValue_GetInt16, METH_VARARGS, nullptr },
    { "get_uint16", (PyCFunction)IPropertyValue_GetUInt16, METH_VARARGS, nullptr },
    { "get_int32", (PyCFunction)IPropertyValue_GetInt32, METH_VARARGS, nullptr },
    { "get_uint32", (PyCFunction)IPropertyValue_GetUInt32, METH_VARARGS, nullptr },
    { "get_int64", (PyCFunction)IPropertyValue_GetInt64, METH_VARARGS, nullptr },
    { "get_uint64", (PyCFunction)IPropertyValue_GetUInt64, METH_VARARGS, nullptr },
    { "get_single", (PyCFunction)IPropertyValue_GetSingle, METH_VARARGS, nullptr },
    { "get_double", (PyCFunction)IPropertyValue_GetDouble, METH_VARARGS, nullptr },
    { "get_char16", (PyCFunction)IPropertyValue_GetChar16, METH_VARARGS, nullptr },
    { "get_boolean", (PyCFunction)IPropertyValue_GetBoolean, METH_VARARGS, nullptr },
    { "get_string", (PyCFunction)IPropertyValue_GetString, METH_VARARGS, nullptr },
    { "get_guid", (PyCFunction)IPropertyValue_GetGuid, METH_VARARGS, nullptr },
    { "get_date_time", (PyCFunction)IPropertyValue_GetDateTime, METH_VARARGS, nullptr },
    { "get_time_span", (PyCFunction)IPropertyValue_GetTimeSpan, METH_VARARGS, nullptr },
    { "get_point", (PyCFunction)IPropertyValue_GetPoint, METH_VARARGS, nullptr },
    { "get_size", (PyCFunction)IPropertyValue_GetSize, METH_VARARGS, nullptr },
    { "get_rect", (PyCFunction)IPropertyValue_GetRect, METH_VARARGS, nullptr },
    { "get_uint8_array", (PyCFunction)IPropertyValue_GetUInt8Array, METH_VARARGS, nullptr },
    { "get_int16_array", (PyCFunction)IPropertyValue_GetInt16Array, METH_VARARGS, nullptr },
    { "get_uint16_array", (PyCFunction)IPropertyValue_GetUInt16Array, METH_VARARGS, nullptr },
    { "get_int32_array", (PyCFunction)IPropertyValue_GetInt32Array, METH_VARARGS, nullptr },
    { "get_uint32_array", (PyCFunction)IPropertyValue_GetUInt32Array, METH_VARARGS, nullptr },
    { "get_int64_array", (PyCFunction)IPropertyValue_GetInt64Array, METH_VARARGS, nullptr },
    { "get_uint64_array", (PyCFunction)IPropertyValue_GetUInt64Array, METH_VARARGS, nullptr },
    { "get_single_array", (PyCFunction)IPropertyValue_GetSingleArray, METH_VARARGS, nullptr },
    { "get_double_array", (PyCFunction)IPropertyValue_GetDoubleArray, METH_VARARGS, nullptr },
    { "get_char16_array", (PyCFunction)IPropertyValue_GetChar16Array, METH_VARARGS, nullptr },
    { "get_boolean_array", (PyCFunction)IPropertyValue_GetBooleanArray, METH_VARARGS, nullptr },
    { "get_string_array", (PyCFunction)IPropertyValue_GetStringArray, METH_VARARGS, nullptr },
    { "get_inspectable_array", (PyCFunction)IPropertyValue_GetInspectableArray, METH_VARARGS, nullptr },
    { "get_guid_array", (PyCFunction)IPropertyValue_GetGuidArray, METH_VARARGS, nullptr },
    { "get_date_time_array", (PyCFunction)IPropertyValue_GetDateTimeArray, METH_VARARGS, nullptr },
    { "get_time_span_array", (PyCFunction)IPropertyValue_GetTimeSpanArray, METH_VARARGS, nullptr },
    { "get_point_array", (PyCFunction)IPropertyValue_GetPointArray, METH_VARARGS, nullptr },
    { "get_size_array", (PyCFunction)IPropertyValue_GetSizeArray, METH_VARARGS, nullptr },
    { "get_rect_array", (PyCFunction)IPropertyValue_GetRectArray, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_IPropertyValue, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IPropertyValue[] = {
    { const_cast<char*>("is_numeric_scalar"), (getter)IPropertyValue_get_IsNumericScalar, nullptr, nullptr, nullptr },
    { const_cast<char*>("type"), (getter)IPropertyValue_get_Type, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IPropertyValue[] = 
{
    { Py_tp_new, _new_IPropertyValue },
    { Py_tp_dealloc, _dealloc_IPropertyValue },
    { Py_tp_methods, _methods_IPropertyValue },
    { Py_tp_getset, _getset_IPropertyValue },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IPropertyValue =
{
    "_winrt_Windows_Foundation.IPropertyValue",
    sizeof(py::wrapper::Windows::Foundation::IPropertyValue),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IPropertyValue
};

// ----- IReferenceArray interface --------------------

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IReferenceArray>::python_type;
static const char* _type_name_IReferenceArray = "IReferenceArray";

static PyObject* _new_IReferenceArray(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IReferenceArray };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IReferenceArray(py::wrapper::Windows::Foundation::IReferenceArray* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IReferenceArray_GetBoolean(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetBoolean(args);
}

static PyObject* IReferenceArray_GetBooleanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetBooleanArray(args);
}

static PyObject* IReferenceArray_GetChar16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetChar16(args);
}

static PyObject* IReferenceArray_GetChar16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetChar16Array(args);
}

static PyObject* IReferenceArray_GetDateTime(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetDateTime(args);
}

static PyObject* IReferenceArray_GetDateTimeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetDateTimeArray(args);
}

static PyObject* IReferenceArray_GetDouble(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetDouble(args);
}

static PyObject* IReferenceArray_GetDoubleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetDoubleArray(args);
}

static PyObject* IReferenceArray_GetGuid(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetGuid(args);
}

static PyObject* IReferenceArray_GetGuidArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetGuidArray(args);
}

static PyObject* IReferenceArray_GetInspectableArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetInspectableArray(args);
}

static PyObject* IReferenceArray_GetInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetInt16(args);
}

static PyObject* IReferenceArray_GetInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetInt16Array(args);
}

static PyObject* IReferenceArray_GetInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetInt32(args);
}

static PyObject* IReferenceArray_GetInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetInt32Array(args);
}

static PyObject* IReferenceArray_GetInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetInt64(args);
}

static PyObject* IReferenceArray_GetInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetInt64Array(args);
}

static PyObject* IReferenceArray_GetPoint(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetPoint(args);
}

static PyObject* IReferenceArray_GetPointArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetPointArray(args);
}

static PyObject* IReferenceArray_GetRect(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetRect(args);
}

static PyObject* IReferenceArray_GetRectArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetRectArray(args);
}

static PyObject* IReferenceArray_GetSingle(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetSingle(args);
}

static PyObject* IReferenceArray_GetSingleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetSingleArray(args);
}

static PyObject* IReferenceArray_GetSize(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetSize(args);
}

static PyObject* IReferenceArray_GetSizeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetSizeArray(args);
}

static PyObject* IReferenceArray_GetString(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetString(args);
}

static PyObject* IReferenceArray_GetStringArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetStringArray(args);
}

static PyObject* IReferenceArray_GetTimeSpan(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetTimeSpan(args);
}

static PyObject* IReferenceArray_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetTimeSpanArray(args);
}

static PyObject* IReferenceArray_GetUInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt16(args);
}

static PyObject* IReferenceArray_GetUInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt16Array(args);
}

static PyObject* IReferenceArray_GetUInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt32(args);
}

static PyObject* IReferenceArray_GetUInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt32Array(args);
}

static PyObject* IReferenceArray_GetUInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt64(args);
}

static PyObject* IReferenceArray_GetUInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt64Array(args);
}

static PyObject* IReferenceArray_GetUInt8(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt8(args);
}

static PyObject* IReferenceArray_GetUInt8Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args)
{
    return self->obj->GetUInt8Array(args);
}

static PyObject* IReferenceArray_get_Value(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/)
{
    return self->obj->get_Value();
}

static PyObject* IReferenceArray_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/)
{
    return self->obj->get_IsNumericScalar();
}

static PyObject* IReferenceArray_get_Type(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/)
{
    return self->obj->get_Type();
}

static PyMethodDef _methods_IReferenceArray[] = {
    { "get_uint8", (PyCFunction)IReferenceArray_GetUInt8, METH_VARARGS, nullptr },
    { "get_int16", (PyCFunction)IReferenceArray_GetInt16, METH_VARARGS, nullptr },
    { "get_uint16", (PyCFunction)IReferenceArray_GetUInt16, METH_VARARGS, nullptr },
    { "get_int32", (PyCFunction)IReferenceArray_GetInt32, METH_VARARGS, nullptr },
    { "get_uint32", (PyCFunction)IReferenceArray_GetUInt32, METH_VARARGS, nullptr },
    { "get_int64", (PyCFunction)IReferenceArray_GetInt64, METH_VARARGS, nullptr },
    { "get_uint64", (PyCFunction)IReferenceArray_GetUInt64, METH_VARARGS, nullptr },
    { "get_single", (PyCFunction)IReferenceArray_GetSingle, METH_VARARGS, nullptr },
    { "get_double", (PyCFunction)IReferenceArray_GetDouble, METH_VARARGS, nullptr },
    { "get_char16", (PyCFunction)IReferenceArray_GetChar16, METH_VARARGS, nullptr },
    { "get_boolean", (PyCFunction)IReferenceArray_GetBoolean, METH_VARARGS, nullptr },
    { "get_string", (PyCFunction)IReferenceArray_GetString, METH_VARARGS, nullptr },
    { "get_guid", (PyCFunction)IReferenceArray_GetGuid, METH_VARARGS, nullptr },
    { "get_date_time", (PyCFunction)IReferenceArray_GetDateTime, METH_VARARGS, nullptr },
    { "get_time_span", (PyCFunction)IReferenceArray_GetTimeSpan, METH_VARARGS, nullptr },
    { "get_point", (PyCFunction)IReferenceArray_GetPoint, METH_VARARGS, nullptr },
    { "get_size", (PyCFunction)IReferenceArray_GetSize, METH_VARARGS, nullptr },
    { "get_rect", (PyCFunction)IReferenceArray_GetRect, METH_VARARGS, nullptr },
    { "get_uint8_array", (PyCFunction)IReferenceArray_GetUInt8Array, METH_VARARGS, nullptr },
    { "get_int16_array", (PyCFunction)IReferenceArray_GetInt16Array, METH_VARARGS, nullptr },
    { "get_uint16_array", (PyCFunction)IReferenceArray_GetUInt16Array, METH_VARARGS, nullptr },
    { "get_int32_array", (PyCFunction)IReferenceArray_GetInt32Array, METH_VARARGS, nullptr },
    { "get_uint32_array", (PyCFunction)IReferenceArray_GetUInt32Array, METH_VARARGS, nullptr },
    { "get_int64_array", (PyCFunction)IReferenceArray_GetInt64Array, METH_VARARGS, nullptr },
    { "get_uint64_array", (PyCFunction)IReferenceArray_GetUInt64Array, METH_VARARGS, nullptr },
    { "get_single_array", (PyCFunction)IReferenceArray_GetSingleArray, METH_VARARGS, nullptr },
    { "get_double_array", (PyCFunction)IReferenceArray_GetDoubleArray, METH_VARARGS, nullptr },
    { "get_char16_array", (PyCFunction)IReferenceArray_GetChar16Array, METH_VARARGS, nullptr },
    { "get_boolean_array", (PyCFunction)IReferenceArray_GetBooleanArray, METH_VARARGS, nullptr },
    { "get_string_array", (PyCFunction)IReferenceArray_GetStringArray, METH_VARARGS, nullptr },
    { "get_inspectable_array", (PyCFunction)IReferenceArray_GetInspectableArray, METH_VARARGS, nullptr },
    { "get_guid_array", (PyCFunction)IReferenceArray_GetGuidArray, METH_VARARGS, nullptr },
    { "get_date_time_array", (PyCFunction)IReferenceArray_GetDateTimeArray, METH_VARARGS, nullptr },
    { "get_time_span_array", (PyCFunction)IReferenceArray_GetTimeSpanArray, METH_VARARGS, nullptr },
    { "get_point_array", (PyCFunction)IReferenceArray_GetPointArray, METH_VARARGS, nullptr },
    { "get_size_array", (PyCFunction)IReferenceArray_GetSizeArray, METH_VARARGS, nullptr },
    { "get_rect_array", (PyCFunction)IReferenceArray_GetRectArray, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IReferenceArray[] = {
    { const_cast<char*>("value"), (getter)IReferenceArray_get_Value, nullptr, nullptr, nullptr },
    { const_cast<char*>("is_numeric_scalar"), (getter)IReferenceArray_get_IsNumericScalar, nullptr, nullptr, nullptr },
    { const_cast<char*>("type"), (getter)IReferenceArray_get_Type, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IReferenceArray[] = 
{
    { Py_tp_new, _new_IReferenceArray },
    { Py_tp_dealloc, _dealloc_IReferenceArray },
    { Py_tp_methods, _methods_IReferenceArray },
    { Py_tp_getset, _getset_IReferenceArray },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IReferenceArray =
{
    "_winrt_Windows_Foundation.IReferenceArray",
    sizeof(py::wrapper::Windows::Foundation::IReferenceArray),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IReferenceArray
};

// ----- IReference interface --------------------

PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IReference>::python_type;
static const char* _type_name_IReference = "IReference";

static PyObject* _new_IReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IReference };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IReference(py::wrapper::Windows::Foundation::IReference* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IReference_GetBoolean(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetBoolean(args);
}

static PyObject* IReference_GetBooleanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetBooleanArray(args);
}

static PyObject* IReference_GetChar16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetChar16(args);
}

static PyObject* IReference_GetChar16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetChar16Array(args);
}

static PyObject* IReference_GetDateTime(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetDateTime(args);
}

static PyObject* IReference_GetDateTimeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetDateTimeArray(args);
}

static PyObject* IReference_GetDouble(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetDouble(args);
}

static PyObject* IReference_GetDoubleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetDoubleArray(args);
}

static PyObject* IReference_GetGuid(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetGuid(args);
}

static PyObject* IReference_GetGuidArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetGuidArray(args);
}

static PyObject* IReference_GetInspectableArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetInspectableArray(args);
}

static PyObject* IReference_GetInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetInt16(args);
}

static PyObject* IReference_GetInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetInt16Array(args);
}

static PyObject* IReference_GetInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetInt32(args);
}

static PyObject* IReference_GetInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetInt32Array(args);
}

static PyObject* IReference_GetInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetInt64(args);
}

static PyObject* IReference_GetInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetInt64Array(args);
}

static PyObject* IReference_GetPoint(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetPoint(args);
}

static PyObject* IReference_GetPointArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetPointArray(args);
}

static PyObject* IReference_GetRect(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetRect(args);
}

static PyObject* IReference_GetRectArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetRectArray(args);
}

static PyObject* IReference_GetSingle(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetSingle(args);
}

static PyObject* IReference_GetSingleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetSingleArray(args);
}

static PyObject* IReference_GetSize(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetSize(args);
}

static PyObject* IReference_GetSizeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetSizeArray(args);
}

static PyObject* IReference_GetString(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetString(args);
}

static PyObject* IReference_GetStringArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetStringArray(args);
}

static PyObject* IReference_GetTimeSpan(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetTimeSpan(args);
}

static PyObject* IReference_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetTimeSpanArray(args);
}

static PyObject* IReference_GetUInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt16(args);
}

static PyObject* IReference_GetUInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt16Array(args);
}

static PyObject* IReference_GetUInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt32(args);
}

static PyObject* IReference_GetUInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt32Array(args);
}

static PyObject* IReference_GetUInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt64(args);
}

static PyObject* IReference_GetUInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt64Array(args);
}

static PyObject* IReference_GetUInt8(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt8(args);
}

static PyObject* IReference_GetUInt8Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args)
{
    return self->obj->GetUInt8Array(args);
}

static PyObject* IReference_get_Value(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/)
{
    return self->obj->get_Value();
}

static PyObject* IReference_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/)
{
    return self->obj->get_IsNumericScalar();
}

static PyObject* IReference_get_Type(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/)
{
    return self->obj->get_Type();
}

static PyMethodDef _methods_IReference[] = {
    { "get_uint8", (PyCFunction)IReference_GetUInt8, METH_VARARGS, nullptr },
    { "get_int16", (PyCFunction)IReference_GetInt16, METH_VARARGS, nullptr },
    { "get_uint16", (PyCFunction)IReference_GetUInt16, METH_VARARGS, nullptr },
    { "get_int32", (PyCFunction)IReference_GetInt32, METH_VARARGS, nullptr },
    { "get_uint32", (PyCFunction)IReference_GetUInt32, METH_VARARGS, nullptr },
    { "get_int64", (PyCFunction)IReference_GetInt64, METH_VARARGS, nullptr },
    { "get_uint64", (PyCFunction)IReference_GetUInt64, METH_VARARGS, nullptr },
    { "get_single", (PyCFunction)IReference_GetSingle, METH_VARARGS, nullptr },
    { "get_double", (PyCFunction)IReference_GetDouble, METH_VARARGS, nullptr },
    { "get_char16", (PyCFunction)IReference_GetChar16, METH_VARARGS, nullptr },
    { "get_boolean", (PyCFunction)IReference_GetBoolean, METH_VARARGS, nullptr },
    { "get_string", (PyCFunction)IReference_GetString, METH_VARARGS, nullptr },
    { "get_guid", (PyCFunction)IReference_GetGuid, METH_VARARGS, nullptr },
    { "get_date_time", (PyCFunction)IReference_GetDateTime, METH_VARARGS, nullptr },
    { "get_time_span", (PyCFunction)IReference_GetTimeSpan, METH_VARARGS, nullptr },
    { "get_point", (PyCFunction)IReference_GetPoint, METH_VARARGS, nullptr },
    { "get_size", (PyCFunction)IReference_GetSize, METH_VARARGS, nullptr },
    { "get_rect", (PyCFunction)IReference_GetRect, METH_VARARGS, nullptr },
    { "get_uint8_array", (PyCFunction)IReference_GetUInt8Array, METH_VARARGS, nullptr },
    { "get_int16_array", (PyCFunction)IReference_GetInt16Array, METH_VARARGS, nullptr },
    { "get_uint16_array", (PyCFunction)IReference_GetUInt16Array, METH_VARARGS, nullptr },
    { "get_int32_array", (PyCFunction)IReference_GetInt32Array, METH_VARARGS, nullptr },
    { "get_uint32_array", (PyCFunction)IReference_GetUInt32Array, METH_VARARGS, nullptr },
    { "get_int64_array", (PyCFunction)IReference_GetInt64Array, METH_VARARGS, nullptr },
    { "get_uint64_array", (PyCFunction)IReference_GetUInt64Array, METH_VARARGS, nullptr },
    { "get_single_array", (PyCFunction)IReference_GetSingleArray, METH_VARARGS, nullptr },
    { "get_double_array", (PyCFunction)IReference_GetDoubleArray, METH_VARARGS, nullptr },
    { "get_char16_array", (PyCFunction)IReference_GetChar16Array, METH_VARARGS, nullptr },
    { "get_boolean_array", (PyCFunction)IReference_GetBooleanArray, METH_VARARGS, nullptr },
    { "get_string_array", (PyCFunction)IReference_GetStringArray, METH_VARARGS, nullptr },
    { "get_inspectable_array", (PyCFunction)IReference_GetInspectableArray, METH_VARARGS, nullptr },
    { "get_guid_array", (PyCFunction)IReference_GetGuidArray, METH_VARARGS, nullptr },
    { "get_date_time_array", (PyCFunction)IReference_GetDateTimeArray, METH_VARARGS, nullptr },
    { "get_time_span_array", (PyCFunction)IReference_GetTimeSpanArray, METH_VARARGS, nullptr },
    { "get_point_array", (PyCFunction)IReference_GetPointArray, METH_VARARGS, nullptr },
    { "get_size_array", (PyCFunction)IReference_GetSizeArray, METH_VARARGS, nullptr },
    { "get_rect_array", (PyCFunction)IReference_GetRectArray, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IReference[] = {
    { const_cast<char*>("value"), (getter)IReference_get_Value, nullptr, nullptr, nullptr },
    { const_cast<char*>("is_numeric_scalar"), (getter)IReference_get_IsNumericScalar, nullptr, nullptr, nullptr },
    { const_cast<char*>("type"), (getter)IReference_get_Type, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IReference[] = 
{
    { Py_tp_new, _new_IReference },
    { Py_tp_dealloc, _dealloc_IReference },
    { Py_tp_methods, _methods_IReference },
    { Py_tp_getset, _getset_IReference },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IReference =
{
    "_winrt_Windows_Foundation.IReference",
    sizeof(py::wrapper::Windows::Foundation::IReference),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IReference
};

// ----- IStringable interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type;
static const char* _type_name_IStringable = "IStringable";

static PyObject* _new_IStringable(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IStringable };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IStringable(py::wrapper::Windows::Foundation::IStringable* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStringable_ToString(py::wrapper::Windows::Foundation::IStringable* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            auto return_value = self->obj.ToString();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            return out_return_value.detach();
        }, nullptr);
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    return nullptr;
}

static PyObject* _from_IStringable(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IStringable>());
    }, nullptr);
}

static PyObject* _str_IStringable(py::wrapper::Windows::Foundation::IStringable* self)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.ToString());
    }, nullptr);
}

static PyMethodDef _methods_IStringable[] = {
    { "to_string", (PyCFunction)IStringable_ToString, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)_from_IStringable, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IStringable[] = {
    { nullptr }
};

static PyType_Slot _type_slots_IStringable[] = 
{
    { Py_tp_new, _new_IStringable },
    { Py_tp_dealloc, _dealloc_IStringable },
    { Py_tp_methods, _methods_IStringable },
    { Py_tp_getset, _getset_IStringable },
    { Py_tp_str, _str_IStringable },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IStringable =
{
    "_winrt_Windows_Foundation.IStringable",
    sizeof(py::wrapper::Windows::Foundation::IStringable),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IStringable
};

// ----- IWwwFormUrlDecoderEntry interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type;
static const char* _type_name_IWwwFormUrlDecoderEntry = "IWwwFormUrlDecoderEntry";

static PyObject* _new_IWwwFormUrlDecoderEntry(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    std::string msg{ _type_name_IWwwFormUrlDecoderEntry };
    msg.append(" interface is not activatable");
    PyErr_SetString(PyExc_TypeError, msg.c_str());
    return nullptr;
}

static void _dealloc_IWwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Name();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = self->obj.Value();
        
        py::pyobj_handle out_return_value{ py::convert(return_value) };
        if (!out_return_value) 
        { 
            return nullptr;
        }
        return out_return_value.detach();
    }, nullptr);
}

static PyObject* _from_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
        return py::convert(return_value.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>());
    }, nullptr);
}

static PyMethodDef _methods_IWwwFormUrlDecoderEntry[] = {
    { "_from", (PyCFunction)_from_IWwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef _getset_IWwwFormUrlDecoderEntry[] = {
    { const_cast<char*>("name"), (getter)IWwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("value"), (getter)IWwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_IWwwFormUrlDecoderEntry[] = 
{
    { Py_tp_new, _new_IWwwFormUrlDecoderEntry },
    { Py_tp_dealloc, _dealloc_IWwwFormUrlDecoderEntry },
    { Py_tp_methods, _methods_IWwwFormUrlDecoderEntry },
    { Py_tp_getset, _getset_IWwwFormUrlDecoderEntry },
    { 0, nullptr },
};

static PyType_Spec _type_spec_IWwwFormUrlDecoderEntry =
{
    "_winrt_Windows_Foundation.IWwwFormUrlDecoderEntry",
    sizeof(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_IWwwFormUrlDecoderEntry
};

// ----- DateTime struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type;
static const char* _type_name_DateTime = "DateTime";

PyObject* py::converter<winrt::Windows::Foundation::DateTime>::convert(winrt::Windows::Foundation::DateTime instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::DateTime>());
}

winrt::Windows::Foundation::DateTime py::converter<winrt::Windows::Foundation::DateTime>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::DateTime>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::Windows::Foundation::DateTime return_value{};
    
    py::pyobj_handle py_UniversalTime{ PyDict_GetItemString(obj, "universal_time") };
    if (!py_UniversalTime) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int64_t>::convert_to(py_UniversalTime.get()));
    
    return return_value;
}

PyObject* _new_DateTime(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Foundation::DateTime return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    int64_t _UniversalTime{};
    
    static const char* kwlist[] = {"universal_time", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_UniversalTime))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::Windows::Foundation::DateTime return_value{ };
        custom_set(return_value, _UniversalTime);
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_DateTime(py::wrapper::Windows::Foundation::DateTime* self)
{
}

static PyObject* DateTime_get_UniversalTime(py::wrapper::Windows::Foundation::DateTime* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(custom_get(self->obj));
    }, nullptr);
}

static int DateTime_set_UniversalTime(py::wrapper::Windows::Foundation::DateTime* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
        return 0;
    });
}

static PyGetSetDef _getset_DateTime[] = {
    { const_cast<char*>("universal_time"), (getter)DateTime_get_UniversalTime, (setter)DateTime_set_UniversalTime, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_DateTime[] = 
{
    { Py_tp_new, _new_DateTime },
    { Py_tp_dealloc, _dealloc_DateTime },
    { Py_tp_getset, _getset_DateTime },
    { 0, nullptr },
};

static PyType_Spec _type_spec_DateTime =
{
    "_winrt_Windows_Foundation.DateTime",
    sizeof(py::wrapper::Windows::Foundation::DateTime),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_DateTime
};

// ----- EventRegistrationToken struct --------------------

PyTypeObject* py::winrt_type<winrt::event_token>::python_type;
static const char* _type_name_EventRegistrationToken = "EventRegistrationToken";

PyObject* py::converter<winrt::event_token>::convert(winrt::event_token instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::event_token>());
}

winrt::event_token py::converter<winrt::event_token>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::event_token>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::event_token>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::event_token return_value{};
    
    py::pyobj_handle py_Value{ PyDict_GetItemString(obj, "value") };
    if (!py_Value) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int64_t>::convert_to(py_Value.get()));
    
    return return_value;
}

PyObject* _new_EventRegistrationToken(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::event_token return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::event_token>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    int64_t _Value{};
    
    static const char* kwlist[] = {"value", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_Value))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::event_token return_value{ };
        custom_set(return_value, _Value);
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_EventRegistrationToken(py::wrapper::Windows::Foundation::EventRegistrationToken* self)
{
}

static PyObject* EventRegistrationToken_get_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(custom_get(self->obj));
    }, nullptr);
}

static int EventRegistrationToken_set_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
        return 0;
    });
}

static PyGetSetDef _getset_EventRegistrationToken[] = {
    { const_cast<char*>("value"), (getter)EventRegistrationToken_get_Value, (setter)EventRegistrationToken_set_Value, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_EventRegistrationToken[] = 
{
    { Py_tp_new, _new_EventRegistrationToken },
    { Py_tp_dealloc, _dealloc_EventRegistrationToken },
    { Py_tp_getset, _getset_EventRegistrationToken },
    { 0, nullptr },
};

static PyType_Spec _type_spec_EventRegistrationToken =
{
    "_winrt_Windows_Foundation.EventRegistrationToken",
    sizeof(py::wrapper::Windows::Foundation::EventRegistrationToken),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_EventRegistrationToken
};

// ----- HResult struct --------------------

PyTypeObject* py::winrt_type<winrt::hresult>::python_type;
static const char* _type_name_HResult = "HResult";

PyObject* py::converter<winrt::hresult>::convert(winrt::hresult instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::hresult>());
}

winrt::hresult py::converter<winrt::hresult>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::hresult>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::hresult>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::hresult return_value{};
    
    py::pyobj_handle py_Value{ PyDict_GetItemString(obj, "value") };
    if (!py_Value) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int32_t>::convert_to(py_Value.get()));
    
    return return_value;
}

PyObject* _new_HResult(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::hresult return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::hresult>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    int32_t _Value{};
    
    static const char* kwlist[] = {"value", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_Value))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::hresult return_value{ };
        custom_set(return_value, _Value);
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_HResult(py::wrapper::Windows::Foundation::HResult* self)
{
}

static PyObject* HResult_get_Value(py::wrapper::Windows::Foundation::HResult* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(custom_get(self->obj));
    }, nullptr);
}

static int HResult_set_Value(py::wrapper::Windows::Foundation::HResult* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        custom_set(self->obj, py::converter<int32_t>::convert_to(arg));
        return 0;
    });
}

static PyGetSetDef _getset_HResult[] = {
    { const_cast<char*>("value"), (getter)HResult_get_Value, (setter)HResult_set_Value, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_HResult[] = 
{
    { Py_tp_new, _new_HResult },
    { Py_tp_dealloc, _dealloc_HResult },
    { Py_tp_getset, _getset_HResult },
    { 0, nullptr },
};

static PyType_Spec _type_spec_HResult =
{
    "_winrt_Windows_Foundation.HResult",
    sizeof(py::wrapper::Windows::Foundation::HResult),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_HResult
};

// ----- Point struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Point>::python_type;
static const char* _type_name_Point = "Point";

PyObject* py::converter<winrt::Windows::Foundation::Point>::convert(winrt::Windows::Foundation::Point instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Point>());
}

winrt::Windows::Foundation::Point py::converter<winrt::Windows::Foundation::Point>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Point>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::Windows::Foundation::Point return_value{};
    
    py::pyobj_handle py_X{ PyDict_GetItemString(obj, "x") };
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<float>::convert_to(py_X.get());
    
    py::pyobj_handle py_Y{ PyDict_GetItemString(obj, "y") };
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<float>::convert_to(py_Y.get());
    
    return return_value;
}

PyObject* _new_Point(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Foundation::Point return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::Windows::Foundation::Point>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    float _X{};
    float _Y{};
    
    static const char* kwlist[] = {"x", "y", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_X, &_Y))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::Windows::Foundation::Point return_value{ _X, _Y };
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_Point(py::wrapper::Windows::Foundation::Point* self)
{
}

static PyObject* Point_get_X(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.X);
    }, nullptr);
}

static int Point_set_X(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.X = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyObject* Point_get_Y(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Y);
    }, nullptr);
}

static int Point_set_Y(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Y = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyGetSetDef _getset_Point[] = {
    { const_cast<char*>("x"), (getter)Point_get_X, (setter)Point_set_X, nullptr, nullptr },
    { const_cast<char*>("y"), (getter)Point_get_Y, (setter)Point_set_Y, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Point[] = 
{
    { Py_tp_new, _new_Point },
    { Py_tp_dealloc, _dealloc_Point },
    { Py_tp_getset, _getset_Point },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Point =
{
    "_winrt_Windows_Foundation.Point",
    sizeof(py::wrapper::Windows::Foundation::Point),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Point
};

// ----- Rect struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Rect>::python_type;
static const char* _type_name_Rect = "Rect";

PyObject* py::converter<winrt::Windows::Foundation::Rect>::convert(winrt::Windows::Foundation::Rect instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Rect>());
}

winrt::Windows::Foundation::Rect py::converter<winrt::Windows::Foundation::Rect>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Rect>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::Windows::Foundation::Rect return_value{};
    
    py::pyobj_handle py_X{ PyDict_GetItemString(obj, "x") };
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<float>::convert_to(py_X.get());
    
    py::pyobj_handle py_Y{ PyDict_GetItemString(obj, "y") };
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<float>::convert_to(py_Y.get());
    
    py::pyobj_handle py_Width{ PyDict_GetItemString(obj, "width") };
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<float>::convert_to(py_Width.get());
    
    py::pyobj_handle py_Height{ PyDict_GetItemString(obj, "height") };
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<float>::convert_to(py_Height.get());
    
    return return_value;
}

PyObject* _new_Rect(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Foundation::Rect return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::Windows::Foundation::Rect>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    float _X{};
    float _Y{};
    float _Width{};
    float _Height{};
    
    static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::Windows::Foundation::Rect return_value{ _X, _Y, _Width, _Height };
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_Rect(py::wrapper::Windows::Foundation::Rect* self)
{
}

static PyObject* Rect_get_X(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.X);
    }, nullptr);
}

static int Rect_set_X(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.X = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyObject* Rect_get_Y(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Y);
    }, nullptr);
}

static int Rect_set_Y(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Y = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyObject* Rect_get_Width(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Width);
    }, nullptr);
}

static int Rect_set_Width(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Width = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyObject* Rect_get_Height(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Height);
    }, nullptr);
}

static int Rect_set_Height(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Height = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyGetSetDef _getset_Rect[] = {
    { const_cast<char*>("x"), (getter)Rect_get_X, (setter)Rect_set_X, nullptr, nullptr },
    { const_cast<char*>("y"), (getter)Rect_get_Y, (setter)Rect_set_Y, nullptr, nullptr },
    { const_cast<char*>("width"), (getter)Rect_get_Width, (setter)Rect_set_Width, nullptr, nullptr },
    { const_cast<char*>("height"), (getter)Rect_get_Height, (setter)Rect_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Rect[] = 
{
    { Py_tp_new, _new_Rect },
    { Py_tp_dealloc, _dealloc_Rect },
    { Py_tp_getset, _getset_Rect },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Rect =
{
    "_winrt_Windows_Foundation.Rect",
    sizeof(py::wrapper::Windows::Foundation::Rect),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Rect
};

// ----- Size struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Size>::python_type;
static const char* _type_name_Size = "Size";

PyObject* py::converter<winrt::Windows::Foundation::Size>::convert(winrt::Windows::Foundation::Size instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Size>());
}

winrt::Windows::Foundation::Size py::converter<winrt::Windows::Foundation::Size>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Size>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::Windows::Foundation::Size return_value{};
    
    py::pyobj_handle py_Width{ PyDict_GetItemString(obj, "width") };
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<float>::convert_to(py_Width.get());
    
    py::pyobj_handle py_Height{ PyDict_GetItemString(obj, "height") };
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<float>::convert_to(py_Height.get());
    
    return return_value;
}

PyObject* _new_Size(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Foundation::Size return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::Windows::Foundation::Size>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    float _Width{};
    float _Height{};
    
    static const char* kwlist[] = {"width", "height", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_Width, &_Height))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::Windows::Foundation::Size return_value{ _Width, _Height };
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_Size(py::wrapper::Windows::Foundation::Size* self)
{
}

static PyObject* Size_get_Width(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Width);
    }, nullptr);
}

static int Size_set_Width(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Width = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyObject* Size_get_Height(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(self->obj.Height);
    }, nullptr);
}

static int Size_set_Height(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        self->obj.Height = py::converter<float>::convert_to(arg);
        return 0;
    });
}

static PyGetSetDef _getset_Size[] = {
    { const_cast<char*>("width"), (getter)Size_get_Width, (setter)Size_set_Width, nullptr, nullptr },
    { const_cast<char*>("height"), (getter)Size_get_Height, (setter)Size_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_Size[] = 
{
    { Py_tp_new, _new_Size },
    { Py_tp_dealloc, _dealloc_Size },
    { Py_tp_getset, _getset_Size },
    { 0, nullptr },
};

static PyType_Spec _type_spec_Size =
{
    "_winrt_Windows_Foundation.Size",
    sizeof(py::wrapper::Windows::Foundation::Size),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_Size
};

// ----- TimeSpan struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type;
static const char* _type_name_TimeSpan = "TimeSpan";

PyObject* py::converter<winrt::Windows::Foundation::TimeSpan>::convert(winrt::Windows::Foundation::TimeSpan instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::TimeSpan>());
}

winrt::Windows::Foundation::TimeSpan py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
        
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::TimeSpan>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>*>(obj)->obj;
    }
        
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
        
    winrt::Windows::Foundation::TimeSpan return_value{};
    
    py::pyobj_handle py_Duration{ PyDict_GetItemString(obj, "duration") };
    if (!py_Duration) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int64_t>::convert_to(py_Duration.get()));
    
    return return_value;
}

PyObject* _new_TimeSpan(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        return py::trycatch_invoker([=]() -> PyObject*
        {
            winrt::Windows::Foundation::TimeSpan return_value{};
            return py::convert(return_value);
        }, nullptr);
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
                return py::convert(return_value);
            }, nullptr);
        }
    }
    
    int64_t _Duration{};
    
    static const char* kwlist[] = {"duration", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_Duration))
    {
        return nullptr;
    }
    
    return py::trycatch_invoker([=]() -> PyObject*
    {
        winrt::Windows::Foundation::TimeSpan return_value{ };
        custom_set(return_value, _Duration);
        return py::convert(return_value);
    }, nullptr);
}

static void _dealloc_TimeSpan(py::wrapper::Windows::Foundation::TimeSpan* self)
{
}

static PyObject* TimeSpan_get_Duration(py::wrapper::Windows::Foundation::TimeSpan* self, void* /*unused*/)
{
    return py::trycatch_invoker([=]() -> PyObject*
    {
        return py::convert(custom_get(self->obj));
    }, nullptr);
}

static int TimeSpan_set_Duration(py::wrapper::Windows::Foundation::TimeSpan* self, PyObject* arg, void* /*unused*/)
{
    return py::setter_trycatch_invoker(arg, [=]() -> int
    {
        custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
        return 0;
    });
}

static PyGetSetDef _getset_TimeSpan[] = {
    { const_cast<char*>("duration"), (getter)TimeSpan_get_Duration, (setter)TimeSpan_set_Duration, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot _type_slots_TimeSpan[] = 
{
    { Py_tp_new, _new_TimeSpan },
    { Py_tp_dealloc, _dealloc_TimeSpan },
    { Py_tp_getset, _getset_TimeSpan },
    { 0, nullptr },
};

static PyType_Spec _type_spec_TimeSpan =
{
    "_winrt_Windows_Foundation.TimeSpan",
    sizeof(py::wrapper::Windows::Foundation::TimeSpan),
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_TimeSpan
};

// ----- Windows.Foundation Initialization --------------------
static int module_exec(PyObject* module)
{
    py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };
    
    try
    {
        py::winrt_type<winrt::Windows::Foundation::Deferral>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Deferral, &_type_spec_Deferral, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_GuidHelper, &_type_spec_GuidHelper, nullptr).detach());
        py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_MemoryBuffer, &_type_spec_MemoryBuffer, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::PropertyValue>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_PropertyValue, &_type_spec_PropertyValue, nullptr).detach());
        py::winrt_type<winrt::Windows::Foundation::Uri>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Uri, &_type_spec_Uri, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_WwwFormUrlDecoder, &_type_spec_WwwFormUrlDecoder, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_WwwFormUrlDecoderEntry, &_type_spec_WwwFormUrlDecoderEntry, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IAsyncAction, &_type_spec_IAsyncAction, bases.get()).detach());
        py::winrt_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IAsyncActionWithProgress, &_type_spec_IAsyncActionWithProgress, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IAsyncInfo, &_type_spec_IAsyncInfo, bases.get()).detach());
        py::winrt_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IAsyncOperationWithProgress, &_type_spec_IAsyncOperationWithProgress, bases.get()).detach());
        py::winrt_type<py::proj::Windows::Foundation::IAsyncOperation>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IAsyncOperation, &_type_spec_IAsyncOperation, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IClosable, &_type_spec_IClosable, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IGetActivationFactory, &_type_spec_IGetActivationFactory, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IMemoryBuffer, &_type_spec_IMemoryBuffer, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IMemoryBufferReference, &_type_spec_IMemoryBufferReference, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IPropertyValue>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IPropertyValue, &_type_spec_IPropertyValue, bases.get()).detach());
        py::winrt_type<py::proj::Windows::Foundation::IReferenceArray>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IReferenceArray, &_type_spec_IReferenceArray, bases.get()).detach());
        py::winrt_type<py::proj::Windows::Foundation::IReference>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IReference, &_type_spec_IReference, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IStringable, &_type_spec_IStringable, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_IWwwFormUrlDecoderEntry, &_type_spec_IWwwFormUrlDecoderEntry, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_DateTime, &_type_spec_DateTime, bases.get()).detach());
        py::winrt_type<winrt::event_token>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_EventRegistrationToken, &_type_spec_EventRegistrationToken, bases.get()).detach());
        py::winrt_type<winrt::hresult>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_HResult, &_type_spec_HResult, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::Point>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Point, &_type_spec_Point, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::Rect>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Rect, &_type_spec_Rect, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::Size>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_Size, &_type_spec_Size, bases.get()).detach());
        py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type = reinterpret_cast<PyTypeObject*>(py::register_python_type(module, _type_name_TimeSpan, &_type_spec_TimeSpan, bases.get()).detach());
    }
    catch(...)
    {
        py::to_PyErr();
        return -1;
    }
    
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Foundation");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_winrt_Windows_Foundation",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__winrt_Windows_Foundation (void)
{
    return PyModuleDef_Init(&module_def);
}
