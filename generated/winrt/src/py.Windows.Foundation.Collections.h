// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"

#if __has_include("py.Windows.Foundation.h")
#include "py.Windows.Foundation.h"
#endif

#include <winrt/Windows.Foundation.Collections.h>

namespace py::proj::Windows::Foundation::Collections
{
    struct IIterable
    {
        virtual ~IIterable() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* First(PyObject*) = 0;
        virtual PyObject* dunder_iter() = 0;
    };
    
    struct IIterator
    {
        virtual ~IIterator() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* MoveNext(PyObject*) = 0;
        virtual PyObject* GetMany(PyObject*) = 0;
        virtual PyObject* get_Current() = 0;
        virtual PyObject* get_HasCurrent() = 0;
        virtual PyObject* dunder_iter() = 0;
        virtual PyObject* dunder_iternext() = 0;
    };
    
    struct IKeyValuePair
    {
        virtual ~IKeyValuePair() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* get_Key() = 0;
        virtual PyObject* get_Value() = 0;
    };
    
    struct IMapChangedEventArgs
    {
        virtual ~IMapChangedEventArgs() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* get_CollectionChange() = 0;
        virtual PyObject* get_Key() = 0;
    };
    
    struct IMapView
    {
        virtual ~IMapView() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* Lookup(PyObject*) = 0;
        virtual PyObject* HasKey(PyObject*) = 0;
        virtual PyObject* Split(PyObject*) = 0;
        virtual PyObject* First(PyObject*) = 0;
        virtual PyObject* get_Size() = 0;
        virtual PyObject* dunder_iter() = 0;
        virtual Py_ssize_t map_length() = 0;
        virtual PyObject* map_subscript(PyObject* key) = 0;
    };
    
    struct IMap
    {
        virtual ~IMap() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* Lookup(PyObject*) = 0;
        virtual PyObject* HasKey(PyObject*) = 0;
        virtual PyObject* GetView(PyObject*) = 0;
        virtual PyObject* Insert(PyObject*) = 0;
        virtual PyObject* Remove(PyObject*) = 0;
        virtual PyObject* Clear(PyObject*) = 0;
        virtual PyObject* First(PyObject*) = 0;
        virtual PyObject* get_Size() = 0;
        virtual PyObject* dunder_iter() = 0;
        virtual Py_ssize_t map_length() = 0;
        virtual PyObject* map_subscript(PyObject* key) = 0;
        virtual int map_assign(PyObject* key, PyObject* value) = 0;
    };
    
    struct IObservableMap
    {
        virtual ~IObservableMap() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* Lookup(PyObject*) = 0;
        virtual PyObject* HasKey(PyObject*) = 0;
        virtual PyObject* GetView(PyObject*) = 0;
        virtual PyObject* Insert(PyObject*) = 0;
        virtual PyObject* Remove(PyObject*) = 0;
        virtual PyObject* Clear(PyObject*) = 0;
        virtual PyObject* First(PyObject*) = 0;
        virtual PyObject* get_Size() = 0;
        virtual PyObject* add_MapChanged(PyObject*) = 0;
        virtual PyObject* remove_MapChanged(PyObject*) = 0;
        virtual PyObject* dunder_iter() = 0;
        virtual Py_ssize_t map_length() = 0;
        virtual PyObject* map_subscript(PyObject* key) = 0;
        virtual int map_assign(PyObject* key, PyObject* value) = 0;
    };
    
    struct IObservableVector
    {
        virtual ~IObservableVector() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetAt(PyObject*) = 0;
        virtual PyObject* GetView(PyObject*) = 0;
        virtual PyObject* IndexOf(PyObject*) = 0;
        virtual PyObject* SetAt(PyObject*) = 0;
        virtual PyObject* InsertAt(PyObject*) = 0;
        virtual PyObject* RemoveAt(PyObject*) = 0;
        virtual PyObject* Append(PyObject*) = 0;
        virtual PyObject* RemoveAtEnd(PyObject*) = 0;
        virtual PyObject* Clear(PyObject*) = 0;
        virtual PyObject* GetMany(PyObject*) = 0;
        virtual PyObject* ReplaceAll(PyObject*) = 0;
        virtual PyObject* First(PyObject*) = 0;
        virtual PyObject* get_Size() = 0;
        virtual PyObject* add_VectorChanged(PyObject*) = 0;
        virtual PyObject* remove_VectorChanged(PyObject*) = 0;
        virtual PyObject* dunder_iter() = 0;
        virtual Py_ssize_t seq_length() = 0;
        virtual PyObject* seq_item(Py_ssize_t i) = 0;
        virtual int seq_assign(Py_ssize_t i, PyObject* value) = 0;
    };
    
    struct IVectorView
    {
        virtual ~IVectorView() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetAt(PyObject*) = 0;
        virtual PyObject* IndexOf(PyObject*) = 0;
        virtual PyObject* GetMany(PyObject*) = 0;
        virtual PyObject* First(PyObject*) = 0;
        virtual PyObject* get_Size() = 0;
        virtual PyObject* dunder_iter() = 0;
        virtual Py_ssize_t seq_length() = 0;
        virtual PyObject* seq_item(Py_ssize_t i) = 0;
    };
    
    struct IVector
    {
        virtual ~IVector() {};
        virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
        virtual std::size_t hash() = 0;
        virtual PyObject* GetAt(PyObject*) = 0;
        virtual PyObject* GetView(PyObject*) = 0;
        virtual PyObject* IndexOf(PyObject*) = 0;
        virtual PyObject* SetAt(PyObject*) = 0;
        virtual PyObject* InsertAt(PyObject*) = 0;
        virtual PyObject* RemoveAt(PyObject*) = 0;
        virtual PyObject* Append(PyObject*) = 0;
        virtual PyObject* RemoveAtEnd(PyObject*) = 0;
        virtual PyObject* Clear(PyObject*) = 0;
        virtual PyObject* GetMany(PyObject*) = 0;
        virtual PyObject* ReplaceAll(PyObject*) = 0;
        virtual PyObject* First(PyObject*) = 0;
        virtual PyObject* get_Size() = 0;
        virtual PyObject* dunder_iter() = 0;
        virtual Py_ssize_t seq_length() = 0;
        virtual PyObject* seq_item(Py_ssize_t i) = 0;
        virtual int seq_assign(Py_ssize_t i, PyObject* value) = 0;
    };
}

namespace py::impl::Windows::Foundation::Collections
{
    template <typename K, typename V>
    struct MapChangedEventHandler
    {
        static winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template <typename T>
    struct VectorChangedEventHandler
    {
        static winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T> get(PyObject* callable)
        {
            py::delegate_callable _delegate{ callable };
                
            return [delegate = std::move(_delegate)](auto param0, auto param1)
            {
                winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
                
                py::pyobj_handle py_param0{ py::convert(param0) };
                py::pyobj_handle py_param1{ py::convert(param1) };
                
                py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
                py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };
                
                if (!return_value) 
                {
                    // TODO: propagate Python error
                    throw winrt::hresult_invalid_argument();
                }
            };
        };
    };
    
    template<typename T>
    struct IIterable : public py::proj::Windows::Foundation::Collections::IIterable
    {
        IIterable(winrt::Windows::Foundation::Collections::IIterable<T> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* First(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.First();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* dunder_iter() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.First());
            }, nullptr);
        }
        
        winrt::Windows::Foundation::Collections::IIterable<T> _obj{ nullptr };
    };
    
    template<typename T>
    struct IIterator : public py::proj::Windows::Foundation::Collections::IIterator
    {
        IIterator(winrt::Windows::Foundation::Collections::IIterator<T> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* GetMany(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0_count = py::convert_to<winrt::com_array<T>::size_type>(args, 0);
                    winrt::com_array<T> param0 ( param0_count, py::empty_instance<T>::get() );
                    
                    auto return_value = _obj.GetMany(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out_return_value.detach(), out0.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* MoveNext(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.MoveNext();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Current() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Current();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_HasCurrent() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.HasCurrent();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_iter() override
        {
            return reinterpret_cast<PyObject*>(this);
        }
        PyObject* dunder_iternext() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                if (_obj.HasCurrent())
                {
                    auto cur = _obj.Current();
                    _obj.MoveNext();
                    return py::convert(cur);
                }
                else
                {
                    return nullptr;
                }}, nullptr);
        }
        
        winrt::Windows::Foundation::Collections::IIterator<T> _obj{ nullptr };
    };
    
    template<typename K, typename V>
    struct IKeyValuePair : public py::proj::Windows::Foundation::Collections::IKeyValuePair
    {
        IKeyValuePair(winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* get_Key() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Key();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Value() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Value();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        
        winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> _obj{ nullptr };
    };
    
    template<typename K>
    struct IMapChangedEventArgs : public py::proj::Windows::Foundation::Collections::IMapChangedEventArgs
    {
        IMapChangedEventArgs(winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* get_CollectionChange() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.CollectionChange();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* get_Key() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Key();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        
        winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> _obj{ nullptr };
    };
    
    template<typename K, typename V>
    struct IMapView : public py::proj::Windows::Foundation::Collections::IMapView
    {
        IMapView(winrt::Windows::Foundation::Collections::IMapView<K, V> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* First(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.First();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* HasKey(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    auto return_value = _obj.HasKey(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Lookup(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    auto return_value = _obj.Lookup(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Split(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    winrt::Windows::Foundation::Collections::IMapView<K, V> param0 { nullptr };
                    winrt::Windows::Foundation::Collections::IMapView<K, V> param1 { nullptr };
                    
                    _obj.Split(param0, param1);
                    
                    py::pyobj_handle out0{ py::convert(param0) };
                    if (!out0) 
                    {
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out0.detach(), out1.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Size() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Size();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_iter() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.First());
            }, nullptr);
        }
        Py_ssize_t map_length() override
        {
            return py::trycatch_invoker([=]() -> Py_ssize_t
            {
                return static_cast<Py_ssize_t>(_obj.Size());
            }, -1);
        }
        PyObject* map_subscript(PyObject* key) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.Lookup(py::convert_to<K>(key)));
            }, nullptr);
        }
        
        winrt::Windows::Foundation::Collections::IMapView<K, V> _obj{ nullptr };
    };
    
    template<typename K, typename V>
    struct IMap : public py::proj::Windows::Foundation::Collections::IMap
    {
        IMap(winrt::Windows::Foundation::Collections::IMap<K, V> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* Clear(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Clear();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* First(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.First();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetView(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetView();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* HasKey(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    auto return_value = _obj.HasKey(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Insert(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    auto param1 = py::convert_to<V>(args, 1);
                    
                    auto return_value = _obj.Insert(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Lookup(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    auto return_value = _obj.Lookup(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Remove(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    _obj.Remove(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Size() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Size();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_iter() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.First());
            }, nullptr);
        }
        Py_ssize_t map_length() override
        {
            return py::trycatch_invoker([=]() -> Py_ssize_t
            {
                return static_cast<Py_ssize_t>(_obj.Size());
            }, -1);
        }
        PyObject* map_subscript(PyObject* key) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.Lookup(py::convert_to<K>(key)));
            }, nullptr);
        }
        int map_assign(PyObject* key, PyObject* value) override
        {
            return py::trycatch_invoker([=]() -> int
            {
                auto _key = py::convert_to<K>(key);
                if (value == nullptr) { _obj.Remove(_key); }
                else { _obj.Insert(_key, py::convert_to<V>(value)); }
                return 0;
            }, -1);
        }
        
        winrt::Windows::Foundation::Collections::IMap<K, V> _obj{ nullptr };
    };
    
    template<typename K, typename V>
    struct IObservableMap : public py::proj::Windows::Foundation::Collections::IObservableMap
    {
        IObservableMap(winrt::Windows::Foundation::Collections::IObservableMap<K, V> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* Clear(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Clear();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* First(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.First();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetView(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetView();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* HasKey(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    auto return_value = _obj.HasKey(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Insert(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    auto param1 = py::convert_to<V>(args, 1);
                    
                    auto return_value = _obj.Insert(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Lookup(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    auto return_value = _obj.Lookup(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Remove(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<K>(args, 0);
                    
                    _obj.Remove(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Size() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Size();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* add_MapChanged(PyObject* arg) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>(arg);
                
                auto return_value = _obj.MapChanged(param0);
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* remove_MapChanged(PyObject* arg) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto param0 = py::convert_to<winrt::event_token>(arg);
                
                _obj.MapChanged(param0);
                
                Py_RETURN_NONE;
            }, nullptr);
        }
        PyObject* dunder_iter() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.First());
            }, nullptr);
        }
        Py_ssize_t map_length() override
        {
            return py::trycatch_invoker([=]() -> Py_ssize_t
            {
                return static_cast<Py_ssize_t>(_obj.Size());
            }, -1);
        }
        PyObject* map_subscript(PyObject* key) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.Lookup(py::convert_to<K>(key)));
            }, nullptr);
        }
        int map_assign(PyObject* key, PyObject* value) override
        {
            return py::trycatch_invoker([=]() -> int
            {
                auto _key = py::convert_to<K>(key);
                if (value == nullptr) { _obj.Remove(_key); }
                else { _obj.Insert(_key, py::convert_to<V>(value)); }
                return 0;
            }, -1);
        }
        
        winrt::Windows::Foundation::Collections::IObservableMap<K, V> _obj{ nullptr };
    };
    
    template<typename T>
    struct IObservableVector : public py::proj::Windows::Foundation::Collections::IObservableVector
    {
        IObservableVector(winrt::Windows::Foundation::Collections::IObservableVector<T> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* Append(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<T>(args, 0);
                    
                    _obj.Append(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Clear(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Clear();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* First(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.First();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    
                    auto return_value = _obj.GetAt(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetMany(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1_count = py::convert_to<winrt::com_array<T>::size_type>(args, 1);
                    winrt::com_array<T> param1 ( param1_count, py::empty_instance<T>::get() );
                    
                    auto return_value = _obj.GetMany(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetView(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetView();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* IndexOf(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<T>(args, 0);
                    uint32_t param1 {  };
                    
                    auto return_value = _obj.IndexOf(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* InsertAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);
                    
                    _obj.InsertAt(param0, param1);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* RemoveAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    
                    _obj.RemoveAt(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* RemoveAtEnd(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.RemoveAtEnd();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* ReplaceAll(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto _param0 = py::convert_to<winrt::com_array<T>>(args, 0);
                    auto param0 = winrt::array_view<const T>(_param0.data(), _param0.data() + _param0.size());
                    
                    _obj.ReplaceAll(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* SetAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);
                    
                    _obj.SetAt(param0, param1);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Size() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Size();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* add_VectorChanged(PyObject* arg) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>(arg);
                
                auto return_value = _obj.VectorChanged(param0);
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* remove_VectorChanged(PyObject* arg) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto param0 = py::convert_to<winrt::event_token>(arg);
                
                _obj.VectorChanged(param0);
                
                Py_RETURN_NONE;
            }, nullptr);
        }
        PyObject* dunder_iter() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.First());
            }, nullptr);
        }
        Py_ssize_t seq_length() override
        {
            return py::trycatch_invoker([=]() -> Py_ssize_t
            {
                return static_cast<Py_ssize_t>(_obj.Size());
            }, -1);
        }
        PyObject* seq_item(Py_ssize_t i) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.GetAt(static_cast<uint32_t>(i)));
            }, nullptr);
        }
        int seq_assign(Py_ssize_t i, PyObject* value) override
        {
            return py::trycatch_invoker([=]() -> int
            {
                if (value == nullptr) { _obj.RemoveAt(static_cast<uint32_t>(i)); }
                else { _obj.SetAt(static_cast<uint32_t>(i), py::convert_to<T>(value)); }
                return 0;
            }, -1);
        }
        
        winrt::Windows::Foundation::Collections::IObservableVector<T> _obj{ nullptr };
    };
    
    template<typename T>
    struct IVectorView : public py::proj::Windows::Foundation::Collections::IVectorView
    {
        IVectorView(winrt::Windows::Foundation::Collections::IVectorView<T> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* First(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.First();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    
                    auto return_value = _obj.GetAt(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetMany(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1_count = py::convert_to<winrt::com_array<T>::size_type>(args, 1);
                    winrt::com_array<T> param1 ( param1_count, py::empty_instance<T>::get() );
                    
                    auto return_value = _obj.GetMany(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* IndexOf(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<T>(args, 0);
                    uint32_t param1 {  };
                    
                    auto return_value = _obj.IndexOf(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Size() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Size();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_iter() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.First());
            }, nullptr);
        }
        Py_ssize_t seq_length() override
        {
            return py::trycatch_invoker([=]() -> Py_ssize_t
            {
                return static_cast<Py_ssize_t>(_obj.Size());
            }, -1);
        }
        PyObject* seq_item(Py_ssize_t i) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.GetAt(static_cast<uint32_t>(i)));
            }, nullptr);
        }
        
        winrt::Windows::Foundation::Collections::IVectorView<T> _obj{ nullptr };
    };
    
    template<typename T>
    struct IVector : public py::proj::Windows::Foundation::Collections::IVector
    {
        IVector(winrt::Windows::Foundation::Collections::IVector<T> o) : _obj(o) {}
        winrt::Windows::Foundation::IUnknown const& get_unknown() override { return _obj; }
        std::size_t hash() override { return py::get_instance_hash(_obj); }
        PyObject* Append(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<T>(args, 0);
                    
                    _obj.Append(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* Clear(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.Clear();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* First(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.First();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    
                    auto return_value = _obj.GetAt(param0);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetMany(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1_count = py::convert_to<winrt::com_array<T>::size_type>(args, 1);
                    winrt::com_array<T> param1 ( param1_count, py::empty_instance<T>::get() );
                    
                    auto return_value = _obj.GetMany(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* GetView(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto return_value = _obj.GetView();
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    return out_return_value.detach();
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* IndexOf(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<T>(args, 0);
                    uint32_t param1 {  };
                    
                    auto return_value = _obj.IndexOf(param0, param1);
                    
                    py::pyobj_handle out_return_value{ py::convert(return_value) };
                    if (!out_return_value) 
                    { 
                        return nullptr;
                    }
                    py::pyobj_handle out1{ py::convert(param1) };
                    if (!out1) 
                    {
                        return nullptr;
                    }
                    return PyTuple_Pack(2, out_return_value.detach(), out1.detach());
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* InsertAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);
                    
                    _obj.InsertAt(param0, param1);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* RemoveAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    
                    _obj.RemoveAt(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* RemoveAtEnd(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 0)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    _obj.RemoveAtEnd();
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* ReplaceAll(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 1)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto _param0 = py::convert_to<winrt::com_array<T>>(args, 0);
                    auto param0 = winrt::array_view<const T>(_param0.data(), _param0.data() + _param0.size());
                    
                    _obj.ReplaceAll(param0);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* SetAt(PyObject* args) override
        {
            Py_ssize_t arg_count = PyTuple_Size(args);
            
            if (arg_count == 2)
            {
                return py::trycatch_invoker([=]() -> PyObject*
                {
                    auto param0 = py::convert_to<uint32_t>(args, 0);
                    auto param1 = py::convert_to<T>(args, 1);
                    
                    _obj.SetAt(param0, param1);
                    
                    Py_RETURN_NONE;
                }, nullptr);
            }
            else if (arg_count != -1)
            {
                PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
            }
            return nullptr;
        }
        PyObject* get_Size() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                auto return_value = _obj.Size();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                return out_return_value.detach();
            }, nullptr);
        }
        PyObject* dunder_iter() override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.First());
            }, nullptr);
        }
        Py_ssize_t seq_length() override
        {
            return py::trycatch_invoker([=]() -> Py_ssize_t
            {
                return static_cast<Py_ssize_t>(_obj.Size());
            }, -1);
        }
        PyObject* seq_item(Py_ssize_t i) override
        {
            return py::trycatch_invoker([=]() -> PyObject*
            {
                return py::convert(_obj.GetAt(static_cast<uint32_t>(i)));
            }, nullptr);
        }
        int seq_assign(Py_ssize_t i, PyObject* value) override
        {
            return py::trycatch_invoker([=]() -> int
            {
                if (value == nullptr) { _obj.RemoveAt(static_cast<uint32_t>(i)); }
                else { _obj.SetAt(static_cast<uint32_t>(i), py::convert_to<T>(value)); }
                return 0;
            }, -1);
        }
        
        winrt::Windows::Foundation::Collections::IVector<T> _obj{ nullptr };
    };
}

namespace py::wrapper::Windows::Foundation::Collections
{
    using PropertySet = py::winrt_wrapper<winrt::Windows::Foundation::Collections::PropertySet>;
    using StringMap = py::winrt_wrapper<winrt::Windows::Foundation::Collections::StringMap>;
    using ValueSet = py::winrt_wrapper<winrt::Windows::Foundation::Collections::ValueSet>;
    using IIterable = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IIterable>;
    using IIterator = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IIterator>;
    using IKeyValuePair = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IKeyValuePair>;
    using IMapChangedEventArgs = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IMapChangedEventArgs>;
    using IMapView = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IMapView>;
    using IMap = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IMap>;
    using IObservableMap = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IObservableMap>;
    using IObservableVector = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IObservableVector>;
    using IPropertySet = py::winrt_wrapper<winrt::Windows::Foundation::Collections::IPropertySet>;
    using IVectorChangedEventArgs = py::winrt_wrapper<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>;
    using IVectorView = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IVectorView>;
    using IVector = py::winrt_pinterface_wrapper<py::proj::Windows::Foundation::Collections::IVector>;
}

namespace py
{
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::PropertySet>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::StringMap>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::ValueSet>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IIterable>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IIterator>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IKeyValuePair>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IMapChangedEventArgs>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IMapView>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IMap>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IObservableMap>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IObservableVector>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::IPropertySet>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IVectorView>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template<>
    struct winrt_type<py::proj::Windows::Foundation::Collections::IVector>
    {
        static PyTypeObject* python_type;
        static PyTypeObject* get_python_type() { return python_type; }
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IIterable;
        using concrete = py::impl::Windows::Foundation::Collections::IIterable<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterator<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IIterator;
        using concrete = py::impl::Windows::Foundation::Collections::IIterator<T>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IKeyValuePair;
        using concrete = py::impl::Windows::Foundation::Collections::IKeyValuePair<K, V>;
    };
    
    template <typename K>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IMapChangedEventArgs;
        using concrete = py::impl::Windows::Foundation::Collections::IMapChangedEventArgs<K>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapView<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IMapView;
        using concrete = py::impl::Windows::Foundation::Collections::IMapView<K, V>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMap<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IMap;
        using concrete = py::impl::Windows::Foundation::Collections::IMap<K, V>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableMap<K, V>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IObservableMap;
        using concrete = py::impl::Windows::Foundation::Collections::IObservableMap<K, V>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableVector<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IObservableVector;
        using concrete = py::impl::Windows::Foundation::Collections::IObservableVector<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVectorView<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IVectorView;
        using concrete = py::impl::Windows::Foundation::Collections::IVectorView<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVector<T>>
    {
        using abstract = py::proj::Windows::Foundation::Collections::IVector;
        using concrete = py::impl::Windows::Foundation::Collections::IVector<T>;
    };
    
    template <typename K, typename V>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>
    {
        using type = py::impl::Windows::Foundation::Collections::MapChangedEventHandler<K, V>;
    };
    
    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>
    {
        using type = py::impl::Windows::Foundation::Collections::VectorChangedEventHandler<T>;
    };
    
}
