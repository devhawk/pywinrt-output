// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Data.Json.h"

// ----- JsonArray class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Data::Json::JsonArray>::python_type;

static PyObject* JsonArray_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Data::Json::JsonArray instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void JsonArray_dealloc(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* JsonArray_Append(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Data::Json::IJsonValue>(args, 0);
            
            self->obj.Append(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_Clear(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_First(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.First();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetArray(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetArray();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetArrayAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetArrayAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetBoolean(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBoolean();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetBooleanAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetBooleanAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetMany(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Data::Json::IJsonValue>::size_type>(args, 1);
            winrt::com_array<winrt::Windows::Data::Json::IJsonValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Data::Json::IJsonValue>::get() );
            
            auto return_value = self->obj.GetMany(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetNumber(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetNumber();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetNumberAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetNumberAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetObject(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetObject();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetObjectAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetObjectAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetString(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetStringAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            auto return_value = self->obj.GetStringAt(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_GetView(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_IndexOf(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Data::Json::IJsonValue>(args, 0);
            uint32_t param1 {  };
            
            auto return_value = self->obj.IndexOf(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_InsertAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Data::Json::IJsonValue>(args, 1);
            
            self->obj.InsertAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_Parse(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Data::Json::JsonArray::Parse(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_RemoveAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            self->obj.RemoveAt(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_RemoveAtEnd(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.RemoveAtEnd();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_ReplaceAll(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto _param0 = py::convert_to<winrt::com_array<winrt::Windows::Data::Json::IJsonValue>>(args, 0);
            auto param0 = winrt::array_view<const winrt::Windows::Data::Json::IJsonValue>(_param0.begin(), _param0.end());
            
            self->obj.ReplaceAll(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_SetAt(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Data::Json::IJsonValue>(args, 1);
            
            self->obj.SetAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_Stringify(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.Stringify();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_ToString(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ToString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_TryParse(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Data::Json::JsonArray param1 { nullptr };
            
            auto return_value = winrt::Windows::Data::Json::JsonArray::TryParse(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonArray_get_ValueType(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ValueType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* JsonArray_get_Size(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonArray_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Data::Json::JsonArray>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonArray_str(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self)
{
    try
    {
        return py::convert(self->obj.ToString());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonArray_iter(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self)
{
    try
    {
        return py::convert(self->obj.First());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static Py_ssize_t __JsonArray_sq_length(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self)
{
    try
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyObject* __JsonArray_sq_item(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, Py_ssize_t i)
{
    try
    {
        return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int __JsonArray_sq_ass_item(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>* self, Py_ssize_t i, PyObject* value)
{
    try
    {
        if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
         else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Data::Json::IJsonValue>(value)); }
         return 0;
         }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyMethodDef JsonArray_methods[] = {
    { "Append", (PyCFunction)JsonArray_Append, METH_VARARGS, nullptr },
    { "Clear", (PyCFunction)JsonArray_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)JsonArray_First, METH_VARARGS, nullptr },
    { "GetArray", (PyCFunction)JsonArray_GetArray, METH_VARARGS, nullptr },
    { "GetArrayAt", (PyCFunction)JsonArray_GetArrayAt, METH_VARARGS, nullptr },
    { "GetAt", (PyCFunction)JsonArray_GetAt, METH_VARARGS, nullptr },
    { "GetBoolean", (PyCFunction)JsonArray_GetBoolean, METH_VARARGS, nullptr },
    { "GetBooleanAt", (PyCFunction)JsonArray_GetBooleanAt, METH_VARARGS, nullptr },
    { "GetMany", (PyCFunction)JsonArray_GetMany, METH_VARARGS, nullptr },
    { "GetNumber", (PyCFunction)JsonArray_GetNumber, METH_VARARGS, nullptr },
    { "GetNumberAt", (PyCFunction)JsonArray_GetNumberAt, METH_VARARGS, nullptr },
    { "GetObject", (PyCFunction)JsonArray_GetObject, METH_VARARGS, nullptr },
    { "GetObjectAt", (PyCFunction)JsonArray_GetObjectAt, METH_VARARGS, nullptr },
    { "GetString", (PyCFunction)JsonArray_GetString, METH_VARARGS, nullptr },
    { "GetStringAt", (PyCFunction)JsonArray_GetStringAt, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)JsonArray_GetView, METH_VARARGS, nullptr },
    { "IndexOf", (PyCFunction)JsonArray_IndexOf, METH_VARARGS, nullptr },
    { "InsertAt", (PyCFunction)JsonArray_InsertAt, METH_VARARGS, nullptr },
    { "Parse", (PyCFunction)JsonArray_Parse, METH_VARARGS | METH_STATIC, nullptr },
    { "RemoveAt", (PyCFunction)JsonArray_RemoveAt, METH_VARARGS, nullptr },
    { "RemoveAtEnd", (PyCFunction)JsonArray_RemoveAtEnd, METH_VARARGS, nullptr },
    { "ReplaceAll", (PyCFunction)JsonArray_ReplaceAll, METH_VARARGS, nullptr },
    { "SetAt", (PyCFunction)JsonArray_SetAt, METH_VARARGS, nullptr },
    { "Stringify", (PyCFunction)JsonArray_Stringify, METH_VARARGS, nullptr },
    { "ToString", (PyCFunction)JsonArray_ToString, METH_VARARGS, nullptr },
    { "TryParse", (PyCFunction)JsonArray_TryParse, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__JsonArray_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef JsonArray_getset[] = {
    { const_cast<char*>("ValueType"), (getter)JsonArray_get_ValueType, nullptr, nullptr, nullptr },
    { const_cast<char*>("Size"), (getter)JsonArray_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot JsonArray_Type_slots[] = 
{
    { Py_tp_dealloc, JsonArray_dealloc },
    { Py_tp_new, JsonArray_new },
    { Py_tp_methods, JsonArray_methods },
    { Py_tp_getset, JsonArray_getset },
    { Py_tp_str, __JsonArray_str },
    { Py_tp_iter, __JsonArray_iter },
    { Py_sq_length, __JsonArray_sq_length },
    { Py_sq_item, __JsonArray_sq_item },
    { Py_sq_ass_item, __JsonArray_sq_ass_item },
    { 0, nullptr },
};

static PyType_Spec JsonArray_Type_spec =
{
    "JsonArray",
    sizeof(py::winrt_wrapper<winrt::Windows::Data::Json::JsonArray>),
    0,
    Py_TPFLAGS_DEFAULT,
    JsonArray_Type_slots
};

// ----- JsonError class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Data::Json::JsonError>::python_type;

static PyObject* JsonError_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "JsonError is not activatable");
    return nullptr;
}

static PyObject* JsonError_GetJsonStatus(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);
            
            auto return_value = winrt::Windows::Data::Json::JsonError::GetJsonStatus(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyMethodDef JsonError_methods[] = {
    { "GetJsonStatus", (PyCFunction)JsonError_GetJsonStatus, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef JsonError_getset[] = {
    { nullptr }
};

static PyType_Slot JsonError_Type_slots[] = 
{
    { Py_tp_new, JsonError_new },
    { Py_tp_methods, JsonError_methods },
    { Py_tp_getset, JsonError_getset },
    { 0, nullptr },
};

static PyType_Spec JsonError_Type_spec =
{
    "JsonError",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    JsonError_Type_slots
};

// ----- JsonObject class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Data::Json::JsonObject>::python_type;

static PyObject* JsonObject_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Data::Json::JsonObject instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void JsonObject_dealloc(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* JsonObject_Clear(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_First(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.First();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetArray(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetArray();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetBoolean(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBoolean();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetNamedArray(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetNamedArray(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Data::Json::JsonArray>(args, 1);
            
            auto return_value = self->obj.GetNamedArray(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetNamedBoolean(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetNamedBoolean(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<bool>(args, 1);
            
            auto return_value = self->obj.GetNamedBoolean(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetNamedNumber(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetNamedNumber(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            
            auto return_value = self->obj.GetNamedNumber(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetNamedObject(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetNamedObject(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Data::Json::JsonObject>(args, 1);
            
            auto return_value = self->obj.GetNamedObject(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetNamedString(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetNamedString(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            
            auto return_value = self->obj.GetNamedString(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetNamedValue(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.GetNamedValue(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Data::Json::JsonValue>(args, 1);
            
            auto return_value = self->obj.GetNamedValue(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetNumber(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetNumber();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetObject(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetObject();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetString(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_GetView(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetView();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_HasKey(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.HasKey(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_Insert(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Data::Json::IJsonValue>(args, 1);
            
            auto return_value = self->obj.Insert(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_Lookup(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = self->obj.Lookup(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_Parse(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Data::Json::JsonObject::Parse(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_Remove(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            self->obj.Remove(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_SetNamedValue(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Data::Json::IJsonValue>(args, 1);
            
            self->obj.SetNamedValue(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_Stringify(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.Stringify();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_ToString(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ToString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_TryParse(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Data::Json::JsonObject param1 { nullptr };
            
            auto return_value = winrt::Windows::Data::Json::JsonObject::TryParse(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonObject_get_ValueType(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ValueType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* JsonObject_get_Size(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonObject_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Data::Json::JsonObject>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonObject_str(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self)
{
    try
    {
        return py::convert(self->obj.ToString());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonObject_iter(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self)
{
    try
    {
        return py::convert(self->obj.First());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static Py_ssize_t __JsonObject_mp_length(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self)
{
    try
    {
        return static_cast<Py_ssize_t>(self->obj.Size());
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyObject* __JsonObject_mp_subscript(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* key)
{
    try
    {
        return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int __JsonObject_mp_ass_item(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>* self, PyObject* key, PyObject* value)
{
    try
    {
        if (value == nullptr) { self->obj.Remove(py::convert_to<winrt::hstring>(key)); }
        else { self->obj.Insert(py::convert_to<winrt::hstring>(key), py::convert_to<winrt::Windows::Data::Json::IJsonValue>(value)); }
        return 0;
    }
    catch (...)
    {
        py::to_PyErr();
        return -1;
    }
}

static PyMethodDef JsonObject_methods[] = {
    { "Clear", (PyCFunction)JsonObject_Clear, METH_VARARGS, nullptr },
    { "First", (PyCFunction)JsonObject_First, METH_VARARGS, nullptr },
    { "GetArray", (PyCFunction)JsonObject_GetArray, METH_VARARGS, nullptr },
    { "GetBoolean", (PyCFunction)JsonObject_GetBoolean, METH_VARARGS, nullptr },
    { "GetNamedArray", (PyCFunction)JsonObject_GetNamedArray, METH_VARARGS, nullptr },
    { "GetNamedBoolean", (PyCFunction)JsonObject_GetNamedBoolean, METH_VARARGS, nullptr },
    { "GetNamedNumber", (PyCFunction)JsonObject_GetNamedNumber, METH_VARARGS, nullptr },
    { "GetNamedObject", (PyCFunction)JsonObject_GetNamedObject, METH_VARARGS, nullptr },
    { "GetNamedString", (PyCFunction)JsonObject_GetNamedString, METH_VARARGS, nullptr },
    { "GetNamedValue", (PyCFunction)JsonObject_GetNamedValue, METH_VARARGS, nullptr },
    { "GetNumber", (PyCFunction)JsonObject_GetNumber, METH_VARARGS, nullptr },
    { "GetObject", (PyCFunction)JsonObject_GetObject, METH_VARARGS, nullptr },
    { "GetString", (PyCFunction)JsonObject_GetString, METH_VARARGS, nullptr },
    { "GetView", (PyCFunction)JsonObject_GetView, METH_VARARGS, nullptr },
    { "HasKey", (PyCFunction)JsonObject_HasKey, METH_VARARGS, nullptr },
    { "Insert", (PyCFunction)JsonObject_Insert, METH_VARARGS, nullptr },
    { "Lookup", (PyCFunction)JsonObject_Lookup, METH_VARARGS, nullptr },
    { "Parse", (PyCFunction)JsonObject_Parse, METH_VARARGS | METH_STATIC, nullptr },
    { "Remove", (PyCFunction)JsonObject_Remove, METH_VARARGS, nullptr },
    { "SetNamedValue", (PyCFunction)JsonObject_SetNamedValue, METH_VARARGS, nullptr },
    { "Stringify", (PyCFunction)JsonObject_Stringify, METH_VARARGS, nullptr },
    { "ToString", (PyCFunction)JsonObject_ToString, METH_VARARGS, nullptr },
    { "TryParse", (PyCFunction)JsonObject_TryParse, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__JsonObject_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef JsonObject_getset[] = {
    { const_cast<char*>("ValueType"), (getter)JsonObject_get_ValueType, nullptr, nullptr, nullptr },
    { const_cast<char*>("Size"), (getter)JsonObject_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot JsonObject_Type_slots[] = 
{
    { Py_tp_dealloc, JsonObject_dealloc },
    { Py_tp_new, JsonObject_new },
    { Py_tp_methods, JsonObject_methods },
    { Py_tp_getset, JsonObject_getset },
    { Py_tp_str, __JsonObject_str },
    { Py_tp_iter, __JsonObject_iter },
    { Py_mp_length, __JsonObject_mp_length },
    { Py_mp_subscript, __JsonObject_mp_subscript },
    { Py_mp_ass_subscript, __JsonObject_mp_ass_item },
    { 0, nullptr },
};

static PyType_Spec JsonObject_Type_spec =
{
    "JsonObject",
    sizeof(py::winrt_wrapper<winrt::Windows::Data::Json::JsonObject>),
    0,
    Py_TPFLAGS_DEFAULT,
    JsonObject_Type_slots
};

// ----- JsonValue class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Data::Json::JsonValue>::python_type;

static PyObject* JsonValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "JsonValue is not activatable");
    return nullptr;
}

static void JsonValue_dealloc(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* JsonValue_CreateBooleanValue(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<bool>(args, 0);
            
            auto return_value = winrt::Windows::Data::Json::JsonValue::CreateBooleanValue(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_CreateNullValue(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Data::Json::JsonValue::CreateNullValue();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_CreateNumberValue(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<double>(args, 0);
            
            auto return_value = winrt::Windows::Data::Json::JsonValue::CreateNumberValue(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_CreateStringValue(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Data::Json::JsonValue::CreateStringValue(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_GetArray(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetArray();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_GetBoolean(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBoolean();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_GetNumber(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetNumber();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_GetObject(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetObject();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_GetString(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_Parse(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            
            auto return_value = winrt::Windows::Data::Json::JsonValue::Parse(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_Stringify(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.Stringify();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_ToString(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ToString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_TryParse(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Data::Json::JsonValue param1 { nullptr };
            
            auto return_value = winrt::Windows::Data::Json::JsonValue::TryParse(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }
            
            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* JsonValue_get_ValueType(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ValueType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonValue_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Data::Json::JsonValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __JsonValue_str(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>* self)
{
    try
    {
        return py::convert(self->obj.ToString());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef JsonValue_methods[] = {
    { "CreateBooleanValue", (PyCFunction)JsonValue_CreateBooleanValue, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateNullValue", (PyCFunction)JsonValue_CreateNullValue, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateNumberValue", (PyCFunction)JsonValue_CreateNumberValue, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateStringValue", (PyCFunction)JsonValue_CreateStringValue, METH_VARARGS | METH_STATIC, nullptr },
    { "GetArray", (PyCFunction)JsonValue_GetArray, METH_VARARGS, nullptr },
    { "GetBoolean", (PyCFunction)JsonValue_GetBoolean, METH_VARARGS, nullptr },
    { "GetNumber", (PyCFunction)JsonValue_GetNumber, METH_VARARGS, nullptr },
    { "GetObject", (PyCFunction)JsonValue_GetObject, METH_VARARGS, nullptr },
    { "GetString", (PyCFunction)JsonValue_GetString, METH_VARARGS, nullptr },
    { "Parse", (PyCFunction)JsonValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
    { "Stringify", (PyCFunction)JsonValue_Stringify, METH_VARARGS, nullptr },
    { "ToString", (PyCFunction)JsonValue_ToString, METH_VARARGS, nullptr },
    { "TryParse", (PyCFunction)JsonValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__JsonValue_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef JsonValue_getset[] = {
    { const_cast<char*>("ValueType"), (getter)JsonValue_get_ValueType, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot JsonValue_Type_slots[] = 
{
    { Py_tp_dealloc, JsonValue_dealloc },
    { Py_tp_new, JsonValue_new },
    { Py_tp_methods, JsonValue_methods },
    { Py_tp_getset, JsonValue_getset },
    { Py_tp_str, __JsonValue_str },
    { 0, nullptr },
};

static PyType_Spec JsonValue_Type_spec =
{
    "JsonValue",
    sizeof(py::winrt_wrapper<winrt::Windows::Data::Json::JsonValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    JsonValue_Type_slots
};

// ----- IJsonValue interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Data::Json::IJsonValue>::python_type;

PyObject* IJsonValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IJsonValue interface is not activatable");
    return nullptr;
}

static void IJsonValue_dealloc(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IJsonValue_GetArray(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetArray();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IJsonValue_GetBoolean(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetBoolean();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IJsonValue_GetNumber(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetNumber();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IJsonValue_GetObject(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetObject();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IJsonValue_GetString(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetString();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IJsonValue_Stringify(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.Stringify();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* IJsonValue_get_ValueType(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ValueType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IJsonValue_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Data::Json::IJsonValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IJsonValue_methods[] = {
    { "GetArray", (PyCFunction)IJsonValue_GetArray, METH_VARARGS, nullptr },
    { "GetBoolean", (PyCFunction)IJsonValue_GetBoolean, METH_VARARGS, nullptr },
    { "GetNumber", (PyCFunction)IJsonValue_GetNumber, METH_VARARGS, nullptr },
    { "GetObject", (PyCFunction)IJsonValue_GetObject, METH_VARARGS, nullptr },
    { "GetString", (PyCFunction)IJsonValue_GetString, METH_VARARGS, nullptr },
    { "Stringify", (PyCFunction)IJsonValue_Stringify, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__IJsonValue_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IJsonValue_getset[] = {
    { const_cast<char*>("ValueType"), (getter)IJsonValue_get_ValueType, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IJsonValue_Type_slots[] = 
{
    { Py_tp_dealloc, IJsonValue_dealloc },
    { Py_tp_new, IJsonValue_new },
    { Py_tp_methods, IJsonValue_methods },
    { Py_tp_getset, IJsonValue_getset },
    { 0, nullptr },
};

static PyType_Spec IJsonValue_Type_spec =
{
    "IJsonValue",
    sizeof(py::winrt_wrapper<winrt::Windows::Data::Json::IJsonValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    IJsonValue_Type_slots
};

// ----- Windows.Data.Json Initialization --------------------

static int module_exec(PyObject* module)
{
    PyObject* type_object{ nullptr };
    PyObject* bases = PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type);
    
    type_object = PyType_FromSpecWithBases(&JsonArray_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "JsonArray", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Data::Json::JsonArray>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&JsonError_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "JsonError", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Data::Json::JsonError>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&JsonObject_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "JsonObject", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Data::Json::JsonObject>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&JsonValue_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "JsonValue", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Data::Json::JsonValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IJsonValue_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IJsonValue", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Data::Json::IJsonValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    Py_DECREF(bases);
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Data.Json");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Data_Json",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Data_Json(void)
{
    return PyModuleDef_Init(&module_def);
}
