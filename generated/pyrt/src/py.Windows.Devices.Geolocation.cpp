// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Devices.Geolocation.h"

// ----- CivicAddress class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type;

static PyObject* CivicAddress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "CivicAddress is not activatable");
    return nullptr;
}

static void CivicAddress_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* CivicAddress_get_City(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.City();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_Country(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Country();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_PostalCode(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PostalCode();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_State(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.State();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Timestamp();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __CivicAddress_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::CivicAddress>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef CivicAddress_methods[] = {
    { "_from", (PyCFunction)__CivicAddress_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef CivicAddress_getset[] = {
    { const_cast<char*>("City"), (getter)CivicAddress_get_City, nullptr, nullptr, nullptr },
    { const_cast<char*>("Country"), (getter)CivicAddress_get_Country, nullptr, nullptr, nullptr },
    { const_cast<char*>("PostalCode"), (getter)CivicAddress_get_PostalCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("State"), (getter)CivicAddress_get_State, nullptr, nullptr, nullptr },
    { const_cast<char*>("Timestamp"), (getter)CivicAddress_get_Timestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot CivicAddress_Type_slots[] = 
{
    { Py_tp_dealloc, CivicAddress_dealloc },
    { Py_tp_new, CivicAddress_new },
    { Py_tp_methods, CivicAddress_methods },
    { Py_tp_getset, CivicAddress_getset },
    { 0, nullptr },
};

static PyType_Spec CivicAddress_Type_spec =
{
    "CivicAddress",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>),
    0,
    Py_TPFLAGS_DEFAULT,
    CivicAddress_Type_slots
};

// ----- GeoboundingBox class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type;

static PyObject* GeoboundingBox_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void GeoboundingBox_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeoboundingBox_TryCompute(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            
            auto return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            
            auto return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            auto return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1, param2);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* GeoboundingBox_get_Center(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Center();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_MaxAltitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MaxAltitude();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_MinAltitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MinAltitude();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_NorthwestCorner(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.NorthwestCorner();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_SoutheastCorner(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SoutheastCorner();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __GeoboundingBox_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::GeoboundingBox>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeoboundingBox_methods[] = {
    { "TryCompute", (PyCFunction)GeoboundingBox_TryCompute, METH_VARARGS | METH_STATIC, nullptr },
    { "_from", (PyCFunction)__GeoboundingBox_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeoboundingBox_getset[] = {
    { const_cast<char*>("Center"), (getter)GeoboundingBox_get_Center, nullptr, nullptr, nullptr },
    { const_cast<char*>("MaxAltitude"), (getter)GeoboundingBox_get_MaxAltitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("MinAltitude"), (getter)GeoboundingBox_get_MinAltitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("NorthwestCorner"), (getter)GeoboundingBox_get_NorthwestCorner, nullptr, nullptr, nullptr },
    { const_cast<char*>("SoutheastCorner"), (getter)GeoboundingBox_get_SoutheastCorner, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)GeoboundingBox_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)GeoboundingBox_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)GeoboundingBox_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeoboundingBox_Type_slots[] = 
{
    { Py_tp_dealloc, GeoboundingBox_dealloc },
    { Py_tp_new, GeoboundingBox_new },
    { Py_tp_methods, GeoboundingBox_methods },
    { Py_tp_getset, GeoboundingBox_getset },
    { 0, nullptr },
};

static PyType_Spec GeoboundingBox_Type_spec =
{
    "GeoboundingBox",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeoboundingBox_Type_slots
};

// ----- Geocircle class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type;

static PyObject* Geocircle_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void Geocircle_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocircle_get_Center(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Center();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_Radius(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Radius();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Geocircle_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::Geocircle>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Geocircle_methods[] = {
    { "_from", (PyCFunction)__Geocircle_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geocircle_getset[] = {
    { const_cast<char*>("Center"), (getter)Geocircle_get_Center, nullptr, nullptr, nullptr },
    { const_cast<char*>("Radius"), (getter)Geocircle_get_Radius, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)Geocircle_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)Geocircle_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)Geocircle_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geocircle_Type_slots[] = 
{
    { Py_tp_dealloc, Geocircle_dealloc },
    { Py_tp_new, Geocircle_new },
    { Py_tp_methods, Geocircle_methods },
    { Py_tp_getset, Geocircle_getset },
    { 0, nullptr },
};

static PyType_Spec Geocircle_Type_spec =
{
    "Geocircle",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geocircle_Type_slots
};

// ----- Geocoordinate class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type;

static PyObject* Geocoordinate_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "Geocoordinate is not activatable");
    return nullptr;
}

static void Geocoordinate_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocoordinate_get_Accuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Accuracy();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Altitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Altitude();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_AltitudeAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeAccuracy();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Heading(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Heading();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Latitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Latitude();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Longitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Longitude();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Speed(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Speed();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Timestamp();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Point(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Point();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_PositionSource(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PositionSource();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_SatelliteData(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SatelliteData();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_PositionSourceTimestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PositionSourceTimestamp();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Geocoordinate_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::Geocoordinate>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Geocoordinate_methods[] = {
    { "_from", (PyCFunction)__Geocoordinate_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geocoordinate_getset[] = {
    { const_cast<char*>("Accuracy"), (getter)Geocoordinate_get_Accuracy, nullptr, nullptr, nullptr },
    { const_cast<char*>("Altitude"), (getter)Geocoordinate_get_Altitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeAccuracy"), (getter)Geocoordinate_get_AltitudeAccuracy, nullptr, nullptr, nullptr },
    { const_cast<char*>("Heading"), (getter)Geocoordinate_get_Heading, nullptr, nullptr, nullptr },
    { const_cast<char*>("Latitude"), (getter)Geocoordinate_get_Latitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("Longitude"), (getter)Geocoordinate_get_Longitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("Speed"), (getter)Geocoordinate_get_Speed, nullptr, nullptr, nullptr },
    { const_cast<char*>("Timestamp"), (getter)Geocoordinate_get_Timestamp, nullptr, nullptr, nullptr },
    { const_cast<char*>("Point"), (getter)Geocoordinate_get_Point, nullptr, nullptr, nullptr },
    { const_cast<char*>("PositionSource"), (getter)Geocoordinate_get_PositionSource, nullptr, nullptr, nullptr },
    { const_cast<char*>("SatelliteData"), (getter)Geocoordinate_get_SatelliteData, nullptr, nullptr, nullptr },
    { const_cast<char*>("PositionSourceTimestamp"), (getter)Geocoordinate_get_PositionSourceTimestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geocoordinate_Type_slots[] = 
{
    { Py_tp_dealloc, Geocoordinate_dealloc },
    { Py_tp_new, Geocoordinate_new },
    { Py_tp_methods, Geocoordinate_methods },
    { Py_tp_getset, Geocoordinate_getset },
    { 0, nullptr },
};

static PyType_Spec Geocoordinate_Type_spec =
{
    "Geocoordinate",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geocoordinate_Type_slots
};

// ----- GeocoordinateSatelliteData class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type;

static PyObject* GeocoordinateSatelliteData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeocoordinateSatelliteData is not activatable");
    return nullptr;
}

static void GeocoordinateSatelliteData_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.HorizontalDilutionOfPrecision();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeocoordinateSatelliteData_get_PositionDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PositionDilutionOfPrecision();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.VerticalDilutionOfPrecision();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __GeocoordinateSatelliteData_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeocoordinateSatelliteData_methods[] = {
    { "_from", (PyCFunction)__GeocoordinateSatelliteData_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeocoordinateSatelliteData_getset[] = {
    { const_cast<char*>("HorizontalDilutionOfPrecision"), (getter)GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision, nullptr, nullptr, nullptr },
    { const_cast<char*>("PositionDilutionOfPrecision"), (getter)GeocoordinateSatelliteData_get_PositionDilutionOfPrecision, nullptr, nullptr, nullptr },
    { const_cast<char*>("VerticalDilutionOfPrecision"), (getter)GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeocoordinateSatelliteData_Type_slots[] = 
{
    { Py_tp_dealloc, GeocoordinateSatelliteData_dealloc },
    { Py_tp_new, GeocoordinateSatelliteData_new },
    { Py_tp_methods, GeocoordinateSatelliteData_methods },
    { Py_tp_getset, GeocoordinateSatelliteData_getset },
    { 0, nullptr },
};

static PyType_Spec GeocoordinateSatelliteData_Type_spec =
{
    "GeocoordinateSatelliteData",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeocoordinateSatelliteData_Type_slots
};

// ----- Geolocator class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type;

static PyObject* Geolocator_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Devices::Geolocation::Geolocator instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void Geolocator_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geolocator_AllowFallbackToConsentlessPositions(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.AllowFallbackToConsentlessPositions();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* Geolocator_GetGeopositionAsync(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.GetGeopositionAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
            
            auto return_value = self->obj.GetGeopositionAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* Geolocator_GetGeopositionHistoryAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            
            auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
            
            auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* Geolocator_RequestAccessAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::RequestAccessAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* Geolocator_get_ReportInterval(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ReportInterval();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_ReportInterval(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(arg);
        
        self->obj.ReportInterval(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Geolocator_get_MovementThreshold(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MovementThreshold();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_MovementThreshold(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<double>(arg);
        
        self->obj.MovementThreshold(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Geolocator_get_DesiredAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DesiredAccuracy();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_DesiredAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::PositionAccuracy>(arg);
        
        self->obj.DesiredAccuracy(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Geolocator_get_LocationStatus(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocationStatus();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_get_DesiredAccuracyInMeters(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DesiredAccuracyInMeters();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_DesiredAccuracyInMeters(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg, void* /*unused*/)
{
    if (arg == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);
        
        self->obj.DesiredAccuracyInMeters(param0);
        
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Geolocator_get_DefaultGeoposition(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_put_DefaultGeoposition(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(arg);
        
        winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition(param0);
        
        return 0;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_get_IsDefaultGeopositionRecommended(PyObject* /*unused*/, PyObject* /*unused*/)
{
    try
    {
        auto return_value = winrt::Windows::Devices::Geolocation::Geolocator::IsDefaultGeopositionRecommended();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_add_PositionChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>>(arg);
        
        auto return_value = self->obj.PositionChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_remove_PositionChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.PositionChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_add_StatusChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>>(arg);
        
        auto return_value = self->obj.StatusChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_remove_StatusChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.StatusChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Geolocator_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::Geolocator>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Geolocator_methods[] = {
    { "AllowFallbackToConsentlessPositions", (PyCFunction)Geolocator_AllowFallbackToConsentlessPositions, METH_VARARGS, nullptr },
    { "GetGeopositionAsync", (PyCFunction)Geolocator_GetGeopositionAsync, METH_VARARGS, nullptr },
    { "GetGeopositionHistoryAsync", (PyCFunction)Geolocator_GetGeopositionHistoryAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "RequestAccessAsync", (PyCFunction)Geolocator_RequestAccessAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "get_DefaultGeoposition", (PyCFunction)Geolocator_get_DefaultGeoposition, METH_NOARGS | METH_STATIC, nullptr },
    { "put_DefaultGeoposition", (PyCFunction)Geolocator_put_DefaultGeoposition, METH_O | METH_STATIC, nullptr },
    { "get_IsDefaultGeopositionRecommended", (PyCFunction)Geolocator_get_IsDefaultGeopositionRecommended, METH_NOARGS | METH_STATIC, nullptr },
    { "add_PositionChanged", (PyCFunction)Geolocator_add_PositionChanged, METH_O, nullptr },
    { "remove_PositionChanged", (PyCFunction)Geolocator_remove_PositionChanged, METH_O, nullptr },
    { "add_StatusChanged", (PyCFunction)Geolocator_add_StatusChanged, METH_O, nullptr },
    { "remove_StatusChanged", (PyCFunction)Geolocator_remove_StatusChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__Geolocator_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geolocator_getset[] = {
    { const_cast<char*>("ReportInterval"), (getter)Geolocator_get_ReportInterval, (setter)Geolocator_put_ReportInterval, nullptr, nullptr },
    { const_cast<char*>("MovementThreshold"), (getter)Geolocator_get_MovementThreshold, (setter)Geolocator_put_MovementThreshold, nullptr, nullptr },
    { const_cast<char*>("DesiredAccuracy"), (getter)Geolocator_get_DesiredAccuracy, (setter)Geolocator_put_DesiredAccuracy, nullptr, nullptr },
    { const_cast<char*>("LocationStatus"), (getter)Geolocator_get_LocationStatus, nullptr, nullptr, nullptr },
    { const_cast<char*>("DesiredAccuracyInMeters"), (getter)Geolocator_get_DesiredAccuracyInMeters, (setter)Geolocator_put_DesiredAccuracyInMeters, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geolocator_Type_slots[] = 
{
    { Py_tp_dealloc, Geolocator_dealloc },
    { Py_tp_new, Geolocator_new },
    { Py_tp_methods, Geolocator_methods },
    { Py_tp_getset, Geolocator_getset },
    { 0, nullptr },
};

static PyType_Spec Geolocator_Type_spec =
{
    "Geolocator",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geolocator_Type_slots
};

// ----- Geopath class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type;

static PyObject* Geopath_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void Geopath_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopath_get_Positions(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Positions();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopath_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopath_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopath_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Geopath_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::Geopath>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Geopath_methods[] = {
    { "_from", (PyCFunction)__Geopath_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geopath_getset[] = {
    { const_cast<char*>("Positions"), (getter)Geopath_get_Positions, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)Geopath_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)Geopath_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)Geopath_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geopath_Type_slots[] = 
{
    { Py_tp_dealloc, Geopath_dealloc },
    { Py_tp_new, Geopath_new },
    { Py_tp_methods, Geopath_methods },
    { Py_tp_getset, Geopath_getset },
    { 0, nullptr },
};

static PyType_Spec Geopath_Type_spec =
{
    "Geopath",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geopath_Type_slots
};

// ----- Geopoint class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type;

static PyObject* Geopoint_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void Geopoint_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopoint_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopoint_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopoint_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopoint_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Geopoint_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::Geopoint>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Geopoint_methods[] = {
    { "_from", (PyCFunction)__Geopoint_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geopoint_getset[] = {
    { const_cast<char*>("Position"), (getter)Geopoint_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)Geopoint_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)Geopoint_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)Geopoint_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geopoint_Type_slots[] = 
{
    { Py_tp_dealloc, Geopoint_dealloc },
    { Py_tp_new, Geopoint_new },
    { Py_tp_methods, Geopoint_methods },
    { Py_tp_getset, Geopoint_getset },
    { 0, nullptr },
};

static PyType_Spec Geopoint_Type_spec =
{
    "Geopoint",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geopoint_Type_slots
};

// ----- Geoposition class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type;

static PyObject* Geoposition_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "Geoposition is not activatable");
    return nullptr;
}

static void Geoposition_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geoposition_get_CivicAddress(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CivicAddress();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geoposition_get_Coordinate(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Coordinate();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geoposition_get_VenueData(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.VenueData();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Geoposition_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::Geoposition>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Geoposition_methods[] = {
    { "_from", (PyCFunction)__Geoposition_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geoposition_getset[] = {
    { const_cast<char*>("CivicAddress"), (getter)Geoposition_get_CivicAddress, nullptr, nullptr, nullptr },
    { const_cast<char*>("Coordinate"), (getter)Geoposition_get_Coordinate, nullptr, nullptr, nullptr },
    { const_cast<char*>("VenueData"), (getter)Geoposition_get_VenueData, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geoposition_Type_slots[] = 
{
    { Py_tp_dealloc, Geoposition_dealloc },
    { Py_tp_new, Geoposition_new },
    { Py_tp_methods, Geoposition_methods },
    { Py_tp_getset, Geoposition_getset },
    { 0, nullptr },
};

static PyType_Spec Geoposition_Type_spec =
{
    "Geoposition",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geoposition_Type_slots
};

// ----- Geovisit class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type;

static PyObject* Geovisit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "Geovisit is not activatable");
    return nullptr;
}

static void Geovisit_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geovisit_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geovisit_get_StateChange(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.StateChange();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geovisit_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Timestamp();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __Geovisit_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::Geovisit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Geovisit_methods[] = {
    { "_from", (PyCFunction)__Geovisit_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geovisit_getset[] = {
    { const_cast<char*>("Position"), (getter)Geovisit_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("StateChange"), (getter)Geovisit_get_StateChange, nullptr, nullptr, nullptr },
    { const_cast<char*>("Timestamp"), (getter)Geovisit_get_Timestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geovisit_Type_slots[] = 
{
    { Py_tp_dealloc, Geovisit_dealloc },
    { Py_tp_new, Geovisit_new },
    { Py_tp_methods, Geovisit_methods },
    { Py_tp_getset, Geovisit_getset },
    { 0, nullptr },
};

static PyType_Spec Geovisit_Type_spec =
{
    "Geovisit",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geovisit_Type_slots
};

// ----- GeovisitMonitor class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type;

static PyObject* GeovisitMonitor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }
    
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Devices::Geolocation::GeovisitMonitor instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static void GeovisitMonitor_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitMonitor_GetLastReportAsync(PyObject* /*unused*/, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = winrt::Windows::Devices::Geolocation::GeovisitMonitor::GetLastReportAsync();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* GeovisitMonitor_Start(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(args, 0);
            
            self->obj.Start(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* GeovisitMonitor_Stop(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            self->obj.Stop();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* GeovisitMonitor_get_MonitoringScope(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MonitoringScope();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeovisitMonitor_add_VisitStateChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::GeovisitMonitor, winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>>(arg);
        
        auto return_value = self->obj.VisitStateChanged(param0);
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeovisitMonitor_remove_VisitStateChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* arg)
{
    try
    {
        auto param0 = py::convert_to<winrt::event_token>(arg);
        
        self->obj.VisitStateChanged(param0);
        
        Py_RETURN_NONE;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __GeovisitMonitor_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::GeovisitMonitor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeovisitMonitor_methods[] = {
    { "GetLastReportAsync", (PyCFunction)GeovisitMonitor_GetLastReportAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "Start", (PyCFunction)GeovisitMonitor_Start, METH_VARARGS, nullptr },
    { "Stop", (PyCFunction)GeovisitMonitor_Stop, METH_VARARGS, nullptr },
    { "add_VisitStateChanged", (PyCFunction)GeovisitMonitor_add_VisitStateChanged, METH_O, nullptr },
    { "remove_VisitStateChanged", (PyCFunction)GeovisitMonitor_remove_VisitStateChanged, METH_O, nullptr },
    { "_from", (PyCFunction)__GeovisitMonitor_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeovisitMonitor_getset[] = {
    { const_cast<char*>("MonitoringScope"), (getter)GeovisitMonitor_get_MonitoringScope, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitMonitor_Type_slots[] = 
{
    { Py_tp_dealloc, GeovisitMonitor_dealloc },
    { Py_tp_new, GeovisitMonitor_new },
    { Py_tp_methods, GeovisitMonitor_methods },
    { Py_tp_getset, GeovisitMonitor_getset },
    { 0, nullptr },
};

static PyType_Spec GeovisitMonitor_Type_spec =
{
    "GeovisitMonitor",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitMonitor_Type_slots
};

// ----- GeovisitStateChangedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type;

static PyObject* GeovisitStateChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeovisitStateChangedEventArgs is not activatable");
    return nullptr;
}

static void GeovisitStateChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitStateChangedEventArgs_get_Visit(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Visit();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __GeovisitStateChangedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeovisitStateChangedEventArgs_methods[] = {
    { "_from", (PyCFunction)__GeovisitStateChangedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeovisitStateChangedEventArgs_getset[] = {
    { const_cast<char*>("Visit"), (getter)GeovisitStateChangedEventArgs_get_Visit, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitStateChangedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, GeovisitStateChangedEventArgs_dealloc },
    { Py_tp_new, GeovisitStateChangedEventArgs_new },
    { Py_tp_methods, GeovisitStateChangedEventArgs_methods },
    { Py_tp_getset, GeovisitStateChangedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec GeovisitStateChangedEventArgs_Type_spec =
{
    "GeovisitStateChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitStateChangedEventArgs_Type_slots
};

// ----- GeovisitTriggerDetails class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type;

static PyObject* GeovisitTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeovisitTriggerDetails is not activatable");
    return nullptr;
}

static void GeovisitTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitTriggerDetails_ReadReports(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>* self, PyObject* args)
{
    Py_ssize_t arg_count = PyTuple_Size(args);
    
    if (arg_count == 0)
    {
        try
        {
            auto return_value = self->obj.ReadReports();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count != -1)
    {
        PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    }
    
    return nullptr;
}

static PyObject* __GeovisitTriggerDetails_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeovisitTriggerDetails_methods[] = {
    { "ReadReports", (PyCFunction)GeovisitTriggerDetails_ReadReports, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)__GeovisitTriggerDetails_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeovisitTriggerDetails_getset[] = {
    { nullptr }
};

static PyType_Slot GeovisitTriggerDetails_Type_slots[] = 
{
    { Py_tp_dealloc, GeovisitTriggerDetails_dealloc },
    { Py_tp_new, GeovisitTriggerDetails_new },
    { Py_tp_methods, GeovisitTriggerDetails_methods },
    { Py_tp_getset, GeovisitTriggerDetails_getset },
    { 0, nullptr },
};

static PyType_Spec GeovisitTriggerDetails_Type_spec =
{
    "GeovisitTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitTriggerDetails_Type_slots
};

// ----- PositionChangedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type;

static PyObject* PositionChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PositionChangedEventArgs is not activatable");
    return nullptr;
}

static void PositionChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PositionChangedEventArgs_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __PositionChangedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef PositionChangedEventArgs_methods[] = {
    { "_from", (PyCFunction)__PositionChangedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef PositionChangedEventArgs_getset[] = {
    { const_cast<char*>("Position"), (getter)PositionChangedEventArgs_get_Position, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot PositionChangedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, PositionChangedEventArgs_dealloc },
    { Py_tp_new, PositionChangedEventArgs_new },
    { Py_tp_methods, PositionChangedEventArgs_methods },
    { Py_tp_getset, PositionChangedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec PositionChangedEventArgs_Type_spec =
{
    "PositionChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    PositionChangedEventArgs_Type_slots
};

// ----- StatusChangedEventArgs class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type;

static PyObject* StatusChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StatusChangedEventArgs is not activatable");
    return nullptr;
}

static void StatusChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StatusChangedEventArgs_get_Status(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Status();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __StatusChangedEventArgs_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef StatusChangedEventArgs_methods[] = {
    { "_from", (PyCFunction)__StatusChangedEventArgs_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef StatusChangedEventArgs_getset[] = {
    { const_cast<char*>("Status"), (getter)StatusChangedEventArgs_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StatusChangedEventArgs_Type_slots[] = 
{
    { Py_tp_dealloc, StatusChangedEventArgs_dealloc },
    { Py_tp_new, StatusChangedEventArgs_new },
    { Py_tp_methods, StatusChangedEventArgs_methods },
    { Py_tp_getset, StatusChangedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec StatusChangedEventArgs_Type_spec =
{
    "StatusChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    StatusChangedEventArgs_Type_slots
};

// ----- VenueData class --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type;

static PyObject* VenueData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "VenueData is not activatable");
    return nullptr;
}

static void VenueData_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* VenueData_get_Id(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* VenueData_get_Level(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Level();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __VenueData_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::VenueData>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef VenueData_methods[] = {
    { "_from", (PyCFunction)__VenueData_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef VenueData_getset[] = {
    { const_cast<char*>("Id"), (getter)VenueData_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("Level"), (getter)VenueData_get_Level, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot VenueData_Type_slots[] = 
{
    { Py_tp_dealloc, VenueData_dealloc },
    { Py_tp_new, VenueData_new },
    { Py_tp_methods, VenueData_methods },
    { Py_tp_getset, VenueData_getset },
    { 0, nullptr },
};

static PyType_Spec VenueData_Type_spec =
{
    "VenueData",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>),
    0,
    Py_TPFLAGS_DEFAULT,
    VenueData_Type_slots
};

// ----- IGeoshape interface --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type;

PyObject* IGeoshape_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IGeoshape interface is not activatable");
    return nullptr;
}

static void IGeoshape_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGeoshape_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IGeoshape_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IGeoshape_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        
        PyObject* out_return_value = py::convert(return_value);
        if (!out_return_value) 
        { 
            return nullptr;
        }
        
        return out_return_value;
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* __IGeoshape_from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::convert(instance.as<winrt::Windows::Devices::Geolocation::IGeoshape>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IGeoshape_methods[] = {
    { "_from", (PyCFunction)__IGeoshape_from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef IGeoshape_getset[] = {
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)IGeoshape_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)IGeoshape_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)IGeoshape_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IGeoshape_Type_slots[] = 
{
    { Py_tp_dealloc, IGeoshape_dealloc },
    { Py_tp_new, IGeoshape_new },
    { Py_tp_methods, IGeoshape_methods },
    { Py_tp_getset, IGeoshape_getset },
    { 0, nullptr },
};

static PyType_Spec IGeoshape_Type_spec =
{
    "IGeoshape",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>),
    0,
    Py_TPFLAGS_DEFAULT,
    IGeoshape_Type_slots
};

// ----- BasicGeoposition struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert(winrt::Windows::Devices::Geolocation::BasicGeoposition instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Devices::Geolocation::BasicGeoposition>(instance, py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>());
}

winrt::Windows::Devices::Geolocation::BasicGeoposition py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Devices::Geolocation::BasicGeoposition new_value{};
    
    PyObject* py_Latitude = PyDict_GetItemString(obj, "Latitude");
    if (!py_Latitude) { throw winrt::hresult_invalid_argument(); }
    new_value.Latitude = converter<double>::convert_to(py_Latitude);
    
    PyObject* py_Longitude = PyDict_GetItemString(obj, "Longitude");
    if (!py_Longitude) { throw winrt::hresult_invalid_argument(); }
    new_value.Longitude = converter<double>::convert_to(py_Longitude);
    
    PyObject* py_Altitude = PyDict_GetItemString(obj, "Altitude");
    if (!py_Altitude) { throw winrt::hresult_invalid_argument(); }
    new_value.Altitude = converter<double>::convert_to(py_Altitude);
    
    return new_value;
}

PyObject* BasicGeoposition_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    double _Latitude{};
    double _Longitude{};
    double _Altitude{};
    
    static char* kwlist[] = {"Latitude", "Longitude", "Altitude", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", kwlist, &_Latitude, &_Longitude, &_Altitude))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Devices::Geolocation::BasicGeoposition instance{ _Latitude, _Longitude, _Altitude };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BasicGeoposition_get_Latitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Latitude);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BasicGeoposition_set_Latitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Latitude = py::converter<double>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BasicGeoposition_get_Longitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Longitude);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BasicGeoposition_set_Longitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Longitude = py::converter<double>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BasicGeoposition_get_Altitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Altitude);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BasicGeoposition_set_Altitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Altitude = py::converter<double>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BasicGeoposition_getset[] = {
    { const_cast<char*>("Latitude"), (getter)BasicGeoposition_get_Latitude, (setter)BasicGeoposition_set_Latitude, nullptr, nullptr },
    { const_cast<char*>("Longitude"), (getter)BasicGeoposition_get_Longitude, (setter)BasicGeoposition_set_Longitude, nullptr, nullptr },
    { const_cast<char*>("Altitude"), (getter)BasicGeoposition_get_Altitude, (setter)BasicGeoposition_set_Altitude, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BasicGeoposition_Type_slots[] = 
{
    { Py_tp_new, BasicGeoposition_new },
    { Py_tp_getset, BasicGeoposition_getset },
    { 0, nullptr },
};

static PyType_Spec BasicGeoposition_Type_spec =
{
    "BasicGeoposition",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>),
    0,
    Py_TPFLAGS_DEFAULT,
    BasicGeoposition_Type_slots
};

// ----- Windows.Devices.Geolocation Initialization --------------------

static int module_exec(PyObject* module)
{
    PyObject* type_object{ nullptr };
    PyObject* bases = PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type);
    
    type_object = PyType_FromSpecWithBases(&CivicAddress_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "CivicAddress", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&GeoboundingBox_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeoboundingBox", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&Geocircle_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geocircle", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&Geocoordinate_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geocoordinate", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&GeocoordinateSatelliteData_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeocoordinateSatelliteData", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&Geolocator_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geolocator", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&Geopath_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geopath", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&Geopoint_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geopoint", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&Geoposition_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geoposition", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&Geovisit_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geovisit", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&GeovisitMonitor_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitMonitor", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&GeovisitStateChangedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitStateChangedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&GeovisitTriggerDetails_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitTriggerDetails", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&PositionChangedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PositionChangedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&StatusChangedEventArgs_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StatusChangedEventArgs", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&VenueData_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "VenueData", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpecWithBases(&IGeoshape_Type_spec, bases);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IGeoshape", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&BasicGeoposition_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BasicGeoposition", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    Py_DECREF(bases);
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Devices.Geolocation");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Devices_Geolocation",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Devices_Geolocation(void)
{
    return PyModuleDef_Init(&module_def);
}
