// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Foundation.Numerics.h"

// ----- Matrix3x2 struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float3x2>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float3x2>::convert(winrt::Windows::Foundation::Numerics::float3x2 instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::float3x2>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float3x2>());
}

winrt::Windows::Foundation::Numerics::float3x2 py::converter<winrt::Windows::Foundation::Numerics::float3x2>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float3x2>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::float3x2 new_value{};
    
    PyObject* py_m11 = PyDict_GetItemString(obj, "M11");
    if (!py_m11) { throw winrt::hresult_invalid_argument(); }
    new_value.m11 = converter<float>::convert_to(py_m11);
    
    PyObject* py_m12 = PyDict_GetItemString(obj, "M12");
    if (!py_m12) { throw winrt::hresult_invalid_argument(); }
    new_value.m12 = converter<float>::convert_to(py_m12);
    
    PyObject* py_m21 = PyDict_GetItemString(obj, "M21");
    if (!py_m21) { throw winrt::hresult_invalid_argument(); }
    new_value.m21 = converter<float>::convert_to(py_m21);
    
    PyObject* py_m22 = PyDict_GetItemString(obj, "M22");
    if (!py_m22) { throw winrt::hresult_invalid_argument(); }
    new_value.m22 = converter<float>::convert_to(py_m22);
    
    PyObject* py_m31 = PyDict_GetItemString(obj, "M31");
    if (!py_m31) { throw winrt::hresult_invalid_argument(); }
    new_value.m31 = converter<float>::convert_to(py_m31);
    
    PyObject* py_m32 = PyDict_GetItemString(obj, "M32");
    if (!py_m32) { throw winrt::hresult_invalid_argument(); }
    new_value.m32 = converter<float>::convert_to(py_m32);
    
    return new_value;
}

PyObject* Matrix3x2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::float3x2 instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::float3x2>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    float _M11{};
    float _M12{};
    float _M21{};
    float _M22{};
    float _M31{};
    float _M32{};
    
    static char* kwlist[] = {"M11", "M12", "M21", "M22", "M31", "M32", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffffff", kwlist, &_M11, &_M12, &_M21, &_M22, &_M31, &_M32))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::float3x2 instance{ _M11, _M12, _M21, _M22, _M31, _M32 };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Matrix3x2_get_M11(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m11);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix3x2_set_M11(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m11 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix3x2_get_M12(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m12);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix3x2_set_M12(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m12 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix3x2_get_M21(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m21);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix3x2_set_M21(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m21 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix3x2_get_M22(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m22);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix3x2_set_M22(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m22 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix3x2_get_M31(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m31);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix3x2_set_M31(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m31 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix3x2_get_M32(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m32);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix3x2_set_M32(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m32 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Matrix3x2_getset[] = {
    { const_cast<char*>("M11"), (getter)Matrix3x2_get_M11, (setter)Matrix3x2_set_M11, nullptr, nullptr },
    { const_cast<char*>("M12"), (getter)Matrix3x2_get_M12, (setter)Matrix3x2_set_M12, nullptr, nullptr },
    { const_cast<char*>("M21"), (getter)Matrix3x2_get_M21, (setter)Matrix3x2_set_M21, nullptr, nullptr },
    { const_cast<char*>("M22"), (getter)Matrix3x2_get_M22, (setter)Matrix3x2_set_M22, nullptr, nullptr },
    { const_cast<char*>("M31"), (getter)Matrix3x2_get_M31, (setter)Matrix3x2_set_M31, nullptr, nullptr },
    { const_cast<char*>("M32"), (getter)Matrix3x2_get_M32, (setter)Matrix3x2_set_M32, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Matrix3x2_Type_slots[] = 
{
    { Py_tp_new, Matrix3x2_new },
    { Py_tp_getset, Matrix3x2_getset },
    { 0, nullptr },
};

static PyType_Spec Matrix3x2_Type_spec =
{
    "Matrix3x2",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>),
    0,
    Py_TPFLAGS_DEFAULT,
    Matrix3x2_Type_slots
};

// ----- Matrix4x4 struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float4x4>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float4x4>::convert(winrt::Windows::Foundation::Numerics::float4x4 instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::float4x4>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float4x4>());
}

winrt::Windows::Foundation::Numerics::float4x4 py::converter<winrt::Windows::Foundation::Numerics::float4x4>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float4x4>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::float4x4 new_value{};
    
    PyObject* py_m11 = PyDict_GetItemString(obj, "M11");
    if (!py_m11) { throw winrt::hresult_invalid_argument(); }
    new_value.m11 = converter<float>::convert_to(py_m11);
    
    PyObject* py_m12 = PyDict_GetItemString(obj, "M12");
    if (!py_m12) { throw winrt::hresult_invalid_argument(); }
    new_value.m12 = converter<float>::convert_to(py_m12);
    
    PyObject* py_m13 = PyDict_GetItemString(obj, "M13");
    if (!py_m13) { throw winrt::hresult_invalid_argument(); }
    new_value.m13 = converter<float>::convert_to(py_m13);
    
    PyObject* py_m14 = PyDict_GetItemString(obj, "M14");
    if (!py_m14) { throw winrt::hresult_invalid_argument(); }
    new_value.m14 = converter<float>::convert_to(py_m14);
    
    PyObject* py_m21 = PyDict_GetItemString(obj, "M21");
    if (!py_m21) { throw winrt::hresult_invalid_argument(); }
    new_value.m21 = converter<float>::convert_to(py_m21);
    
    PyObject* py_m22 = PyDict_GetItemString(obj, "M22");
    if (!py_m22) { throw winrt::hresult_invalid_argument(); }
    new_value.m22 = converter<float>::convert_to(py_m22);
    
    PyObject* py_m23 = PyDict_GetItemString(obj, "M23");
    if (!py_m23) { throw winrt::hresult_invalid_argument(); }
    new_value.m23 = converter<float>::convert_to(py_m23);
    
    PyObject* py_m24 = PyDict_GetItemString(obj, "M24");
    if (!py_m24) { throw winrt::hresult_invalid_argument(); }
    new_value.m24 = converter<float>::convert_to(py_m24);
    
    PyObject* py_m31 = PyDict_GetItemString(obj, "M31");
    if (!py_m31) { throw winrt::hresult_invalid_argument(); }
    new_value.m31 = converter<float>::convert_to(py_m31);
    
    PyObject* py_m32 = PyDict_GetItemString(obj, "M32");
    if (!py_m32) { throw winrt::hresult_invalid_argument(); }
    new_value.m32 = converter<float>::convert_to(py_m32);
    
    PyObject* py_m33 = PyDict_GetItemString(obj, "M33");
    if (!py_m33) { throw winrt::hresult_invalid_argument(); }
    new_value.m33 = converter<float>::convert_to(py_m33);
    
    PyObject* py_m34 = PyDict_GetItemString(obj, "M34");
    if (!py_m34) { throw winrt::hresult_invalid_argument(); }
    new_value.m34 = converter<float>::convert_to(py_m34);
    
    PyObject* py_m41 = PyDict_GetItemString(obj, "M41");
    if (!py_m41) { throw winrt::hresult_invalid_argument(); }
    new_value.m41 = converter<float>::convert_to(py_m41);
    
    PyObject* py_m42 = PyDict_GetItemString(obj, "M42");
    if (!py_m42) { throw winrt::hresult_invalid_argument(); }
    new_value.m42 = converter<float>::convert_to(py_m42);
    
    PyObject* py_m43 = PyDict_GetItemString(obj, "M43");
    if (!py_m43) { throw winrt::hresult_invalid_argument(); }
    new_value.m43 = converter<float>::convert_to(py_m43);
    
    PyObject* py_m44 = PyDict_GetItemString(obj, "M44");
    if (!py_m44) { throw winrt::hresult_invalid_argument(); }
    new_value.m44 = converter<float>::convert_to(py_m44);
    
    return new_value;
}

PyObject* Matrix4x4_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::float4x4 instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::float4x4>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    float _M11{};
    float _M12{};
    float _M13{};
    float _M14{};
    float _M21{};
    float _M22{};
    float _M23{};
    float _M24{};
    float _M31{};
    float _M32{};
    float _M33{};
    float _M34{};
    float _M41{};
    float _M42{};
    float _M43{};
    float _M44{};
    
    static char* kwlist[] = {"M11", "M12", "M13", "M14", "M21", "M22", "M23", "M24", "M31", "M32", "M33", "M34", "M41", "M42", "M43", "M44", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffff", kwlist, &_M11, &_M12, &_M13, &_M14, &_M21, &_M22, &_M23, &_M24, &_M31, &_M32, &_M33, &_M34, &_M41, &_M42, &_M43, &_M44))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::float4x4 instance{ _M11, _M12, _M13, _M14, _M21, _M22, _M23, _M24, _M31, _M32, _M33, _M34, _M41, _M42, _M43, _M44 };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Matrix4x4_get_M11(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m11);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M11(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m11 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M12(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m12);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M12(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m12 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M13(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m13);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M13(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m13 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M14(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m14);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M14(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m14 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M21(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m21);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M21(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m21 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M22(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m22);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M22(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m22 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M23(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m23);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M23(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m23 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M24(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m24);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M24(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m24 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M31(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m31);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M31(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m31 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M32(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m32);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M32(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m32 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M33(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m33);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M33(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m33 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M34(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m34);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M34(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m34 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M41(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m41);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M41(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m41 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M42(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m42);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M42(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m42 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M43(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m43);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M43(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m43 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Matrix4x4_get_M44(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.m44);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Matrix4x4_set_M44(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.m44 = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Matrix4x4_getset[] = {
    { const_cast<char*>("M11"), (getter)Matrix4x4_get_M11, (setter)Matrix4x4_set_M11, nullptr, nullptr },
    { const_cast<char*>("M12"), (getter)Matrix4x4_get_M12, (setter)Matrix4x4_set_M12, nullptr, nullptr },
    { const_cast<char*>("M13"), (getter)Matrix4x4_get_M13, (setter)Matrix4x4_set_M13, nullptr, nullptr },
    { const_cast<char*>("M14"), (getter)Matrix4x4_get_M14, (setter)Matrix4x4_set_M14, nullptr, nullptr },
    { const_cast<char*>("M21"), (getter)Matrix4x4_get_M21, (setter)Matrix4x4_set_M21, nullptr, nullptr },
    { const_cast<char*>("M22"), (getter)Matrix4x4_get_M22, (setter)Matrix4x4_set_M22, nullptr, nullptr },
    { const_cast<char*>("M23"), (getter)Matrix4x4_get_M23, (setter)Matrix4x4_set_M23, nullptr, nullptr },
    { const_cast<char*>("M24"), (getter)Matrix4x4_get_M24, (setter)Matrix4x4_set_M24, nullptr, nullptr },
    { const_cast<char*>("M31"), (getter)Matrix4x4_get_M31, (setter)Matrix4x4_set_M31, nullptr, nullptr },
    { const_cast<char*>("M32"), (getter)Matrix4x4_get_M32, (setter)Matrix4x4_set_M32, nullptr, nullptr },
    { const_cast<char*>("M33"), (getter)Matrix4x4_get_M33, (setter)Matrix4x4_set_M33, nullptr, nullptr },
    { const_cast<char*>("M34"), (getter)Matrix4x4_get_M34, (setter)Matrix4x4_set_M34, nullptr, nullptr },
    { const_cast<char*>("M41"), (getter)Matrix4x4_get_M41, (setter)Matrix4x4_set_M41, nullptr, nullptr },
    { const_cast<char*>("M42"), (getter)Matrix4x4_get_M42, (setter)Matrix4x4_set_M42, nullptr, nullptr },
    { const_cast<char*>("M43"), (getter)Matrix4x4_get_M43, (setter)Matrix4x4_set_M43, nullptr, nullptr },
    { const_cast<char*>("M44"), (getter)Matrix4x4_get_M44, (setter)Matrix4x4_set_M44, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Matrix4x4_Type_slots[] = 
{
    { Py_tp_new, Matrix4x4_new },
    { Py_tp_getset, Matrix4x4_getset },
    { 0, nullptr },
};

static PyType_Spec Matrix4x4_Type_spec =
{
    "Matrix4x4",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>),
    0,
    Py_TPFLAGS_DEFAULT,
    Matrix4x4_Type_slots
};

// ----- Plane struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::plane>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::plane>::convert(winrt::Windows::Foundation::Numerics::plane instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::plane>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::plane>());
}

winrt::Windows::Foundation::Numerics::plane py::converter<winrt::Windows::Foundation::Numerics::plane>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::plane>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::plane new_value{};
    
    PyObject* py_normal = PyDict_GetItemString(obj, "Normal");
    if (!py_normal) { throw winrt::hresult_invalid_argument(); }
    new_value.normal = converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(py_normal);
    
    PyObject* py_d = PyDict_GetItemString(obj, "D");
    if (!py_d) { throw winrt::hresult_invalid_argument(); }
    new_value.d = converter<float>::convert_to(py_d);
    
    return new_value;
}

PyObject* Plane_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::plane instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::plane>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    PyObject* _Normal{};
    float _D{};
    
    static char* kwlist[] = {"Normal", "D", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "Of", kwlist, &_Normal, &_D))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::plane instance{ py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(_Normal), _D };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Plane_get_Normal(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.normal);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Plane_set_Normal(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.normal = py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Plane_get_D(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.d);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Plane_set_D(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.d = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Plane_getset[] = {
    { const_cast<char*>("Normal"), (getter)Plane_get_Normal, (setter)Plane_set_Normal, nullptr, nullptr },
    { const_cast<char*>("D"), (getter)Plane_get_D, (setter)Plane_set_D, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Plane_Type_slots[] = 
{
    { Py_tp_new, Plane_new },
    { Py_tp_getset, Plane_getset },
    { 0, nullptr },
};

static PyType_Spec Plane_Type_spec =
{
    "Plane",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>),
    0,
    Py_TPFLAGS_DEFAULT,
    Plane_Type_slots
};

// ----- Quaternion struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::quaternion>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::quaternion>::convert(winrt::Windows::Foundation::Numerics::quaternion instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::quaternion>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::quaternion>());
}

winrt::Windows::Foundation::Numerics::quaternion py::converter<winrt::Windows::Foundation::Numerics::quaternion>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::quaternion>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::quaternion new_value{};
    
    PyObject* py_x = PyDict_GetItemString(obj, "X");
    if (!py_x) { throw winrt::hresult_invalid_argument(); }
    new_value.x = converter<float>::convert_to(py_x);
    
    PyObject* py_y = PyDict_GetItemString(obj, "Y");
    if (!py_y) { throw winrt::hresult_invalid_argument(); }
    new_value.y = converter<float>::convert_to(py_y);
    
    PyObject* py_z = PyDict_GetItemString(obj, "Z");
    if (!py_z) { throw winrt::hresult_invalid_argument(); }
    new_value.z = converter<float>::convert_to(py_z);
    
    PyObject* py_w = PyDict_GetItemString(obj, "W");
    if (!py_w) { throw winrt::hresult_invalid_argument(); }
    new_value.w = converter<float>::convert_to(py_w);
    
    return new_value;
}

PyObject* Quaternion_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::quaternion instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::quaternion>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    float _X{};
    float _Y{};
    float _Z{};
    float _W{};
    
    static char* kwlist[] = {"X", "Y", "Z", "W", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", kwlist, &_X, &_Y, &_Z, &_W))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::quaternion instance{ _X, _Y, _Z, _W };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Quaternion_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.x);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Quaternion_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.x = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Quaternion_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Quaternion_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.y = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Quaternion_get_Z(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.z);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Quaternion_set_Z(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.z = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Quaternion_get_W(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.w);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Quaternion_set_W(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.w = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Quaternion_getset[] = {
    { const_cast<char*>("X"), (getter)Quaternion_get_X, (setter)Quaternion_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Quaternion_get_Y, (setter)Quaternion_set_Y, nullptr, nullptr },
    { const_cast<char*>("Z"), (getter)Quaternion_get_Z, (setter)Quaternion_set_Z, nullptr, nullptr },
    { const_cast<char*>("W"), (getter)Quaternion_get_W, (setter)Quaternion_set_W, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Quaternion_Type_slots[] = 
{
    { Py_tp_new, Quaternion_new },
    { Py_tp_getset, Quaternion_getset },
    { 0, nullptr },
};

static PyType_Spec Quaternion_Type_spec =
{
    "Quaternion",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>),
    0,
    Py_TPFLAGS_DEFAULT,
    Quaternion_Type_slots
};

// ----- Rational struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::Rational>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert(winrt::Windows::Foundation::Numerics::Rational instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::Rational>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::Rational>());
}

winrt::Windows::Foundation::Numerics::Rational py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::Rational>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::Rational new_value{};
    
    PyObject* py_Numerator = PyDict_GetItemString(obj, "Numerator");
    if (!py_Numerator) { throw winrt::hresult_invalid_argument(); }
    new_value.Numerator = converter<uint32_t>::convert_to(py_Numerator);
    
    PyObject* py_Denominator = PyDict_GetItemString(obj, "Denominator");
    if (!py_Denominator) { throw winrt::hresult_invalid_argument(); }
    new_value.Denominator = converter<uint32_t>::convert_to(py_Denominator);
    
    return new_value;
}

PyObject* Rational_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::Rational instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    uint32_t _Numerator{};
    uint32_t _Denominator{};
    
    static char* kwlist[] = {"Numerator", "Denominator", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", kwlist, &_Numerator, &_Denominator))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::Rational instance{ _Numerator, _Denominator };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Rational_get_Numerator(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Numerator);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rational_set_Numerator(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Numerator = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Rational_get_Denominator(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Denominator);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rational_set_Denominator(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Denominator = py::converter<uint32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Rational_getset[] = {
    { const_cast<char*>("Numerator"), (getter)Rational_get_Numerator, (setter)Rational_set_Numerator, nullptr, nullptr },
    { const_cast<char*>("Denominator"), (getter)Rational_get_Denominator, (setter)Rational_set_Denominator, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Rational_Type_slots[] = 
{
    { Py_tp_new, Rational_new },
    { Py_tp_getset, Rational_getset },
    { 0, nullptr },
};

static PyType_Spec Rational_Type_spec =
{
    "Rational",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>),
    0,
    Py_TPFLAGS_DEFAULT,
    Rational_Type_slots
};

// ----- Vector2 struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float2>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float2>::convert(winrt::Windows::Foundation::Numerics::float2 instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::float2>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float2>());
}

winrt::Windows::Foundation::Numerics::float2 py::converter<winrt::Windows::Foundation::Numerics::float2>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float2>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::float2 new_value{};
    
    PyObject* py_x = PyDict_GetItemString(obj, "X");
    if (!py_x) { throw winrt::hresult_invalid_argument(); }
    new_value.x = converter<float>::convert_to(py_x);
    
    PyObject* py_y = PyDict_GetItemString(obj, "Y");
    if (!py_y) { throw winrt::hresult_invalid_argument(); }
    new_value.y = converter<float>::convert_to(py_y);
    
    return new_value;
}

PyObject* Vector2_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::float2 instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::float2>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    float _X{};
    float _Y{};
    
    static char* kwlist[] = {"X", "Y", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", kwlist, &_X, &_Y))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::float2 instance{ _X, _Y };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Vector2_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.x);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector2_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.x = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Vector2_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector2_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.y = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Vector2_getset[] = {
    { const_cast<char*>("X"), (getter)Vector2_get_X, (setter)Vector2_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Vector2_get_Y, (setter)Vector2_set_Y, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Vector2_Type_slots[] = 
{
    { Py_tp_new, Vector2_new },
    { Py_tp_getset, Vector2_getset },
    { 0, nullptr },
};

static PyType_Spec Vector2_Type_spec =
{
    "Vector2",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>),
    0,
    Py_TPFLAGS_DEFAULT,
    Vector2_Type_slots
};

// ----- Vector3 struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float3>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float3>::convert(winrt::Windows::Foundation::Numerics::float3 instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::float3>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float3>());
}

winrt::Windows::Foundation::Numerics::float3 py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float3>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::float3 new_value{};
    
    PyObject* py_x = PyDict_GetItemString(obj, "X");
    if (!py_x) { throw winrt::hresult_invalid_argument(); }
    new_value.x = converter<float>::convert_to(py_x);
    
    PyObject* py_y = PyDict_GetItemString(obj, "Y");
    if (!py_y) { throw winrt::hresult_invalid_argument(); }
    new_value.y = converter<float>::convert_to(py_y);
    
    PyObject* py_z = PyDict_GetItemString(obj, "Z");
    if (!py_z) { throw winrt::hresult_invalid_argument(); }
    new_value.z = converter<float>::convert_to(py_z);
    
    return new_value;
}

PyObject* Vector3_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::float3 instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    float _X{};
    float _Y{};
    float _Z{};
    
    static char* kwlist[] = {"X", "Y", "Z", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "fff", kwlist, &_X, &_Y, &_Z))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::float3 instance{ _X, _Y, _Z };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Vector3_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.x);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector3_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.x = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Vector3_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector3_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.y = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Vector3_get_Z(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.z);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector3_set_Z(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.z = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Vector3_getset[] = {
    { const_cast<char*>("X"), (getter)Vector3_get_X, (setter)Vector3_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Vector3_get_Y, (setter)Vector3_set_Y, nullptr, nullptr },
    { const_cast<char*>("Z"), (getter)Vector3_get_Z, (setter)Vector3_set_Z, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Vector3_Type_slots[] = 
{
    { Py_tp_new, Vector3_new },
    { Py_tp_getset, Vector3_getset },
    { 0, nullptr },
};

static PyType_Spec Vector3_Type_spec =
{
    "Vector3",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>),
    0,
    Py_TPFLAGS_DEFAULT,
    Vector3_Type_slots
};

// ----- Vector4 struct --------------------

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float4>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float4>::convert(winrt::Windows::Foundation::Numerics::float4 instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Numerics::float4>(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float4>());
}

winrt::Windows::Foundation::Numerics::float4 py::converter<winrt::Windows::Foundation::Numerics::float4>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float4>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Numerics::float4 new_value{};
    
    PyObject* py_x = PyDict_GetItemString(obj, "X");
    if (!py_x) { throw winrt::hresult_invalid_argument(); }
    new_value.x = converter<float>::convert_to(py_x);
    
    PyObject* py_y = PyDict_GetItemString(obj, "Y");
    if (!py_y) { throw winrt::hresult_invalid_argument(); }
    new_value.y = converter<float>::convert_to(py_y);
    
    PyObject* py_z = PyDict_GetItemString(obj, "Z");
    if (!py_z) { throw winrt::hresult_invalid_argument(); }
    new_value.z = converter<float>::convert_to(py_z);
    
    PyObject* py_w = PyDict_GetItemString(obj, "W");
    if (!py_w) { throw winrt::hresult_invalid_argument(); }
    new_value.w = converter<float>::convert_to(py_w);
    
    return new_value;
}

PyObject* Vector4_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Numerics::float4 instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Numerics::float4>::convert_to(arg);
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        };
    };
    
    float _X{};
    float _Y{};
    float _Z{};
    float _W{};
    
    static char* kwlist[] = {"X", "Y", "Z", "W", nullptr};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", kwlist, &_X, &_Y, &_Z, &_W))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Numerics::float4 instance{ _X, _Y, _Z, _W };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Vector4_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.x);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector4_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.x = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Vector4_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector4_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.y = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Vector4_get_Z(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.z);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector4_set_Z(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.z = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Vector4_get_W(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.w);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Vector4_set_W(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.w = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Vector4_getset[] = {
    { const_cast<char*>("X"), (getter)Vector4_get_X, (setter)Vector4_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Vector4_get_Y, (setter)Vector4_set_Y, nullptr, nullptr },
    { const_cast<char*>("Z"), (getter)Vector4_get_Z, (setter)Vector4_set_Z, nullptr, nullptr },
    { const_cast<char*>("W"), (getter)Vector4_get_W, (setter)Vector4_set_W, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Vector4_Type_slots[] = 
{
    { Py_tp_new, Vector4_new },
    { Py_tp_getset, Vector4_getset },
    { 0, nullptr },
};

static PyType_Spec Vector4_Type_spec =
{
    "Vector4",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>),
    0,
    Py_TPFLAGS_DEFAULT,
    Vector4_Type_slots
};

// ----- Windows.Foundation.Numerics Initialization --------------------

static int module_exec(PyObject* module)
{
    PyObject* type_object{ nullptr };
    PyObject* bases = PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type);
    
    type_object = PyType_FromSpec(&Matrix3x2_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Matrix3x2", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::float3x2>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&Matrix4x4_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Matrix4x4", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::float4x4>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&Plane_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Plane", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::plane>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&Quaternion_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Quaternion", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::quaternion>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&Rational_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Rational", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::Rational>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&Vector2_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Vector2", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::float2>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&Vector3_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Vector3", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::float3>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    type_object = PyType_FromSpec(&Vector4_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Vector4", type_object) != 0)
    {
        Py_DECREF(type_object);
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Numerics::float4>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    type_object = nullptr;
    
    Py_DECREF(bases);
    return 0;
}

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_exec, module_exec},
    {0, nullptr}
};

PyDoc_STRVAR(module_doc, "Windows.Foundation.Numerics");

static PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    "_pyrt_Windows_Foundation_Numerics",
    module_doc,
    0,
    nullptr,
    module_slots,
    nullptr,
    nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit__pyrt_Windows_Foundation_Numerics(void)
{
    return PyModuleDef_Init(&module_def);
}
