// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"

#if __has_include("py.Windows.Foundation.h")
#include "py.Windows.Foundation.h"
#endif

#include <winrt/Windows.Foundation.Collections.h>

template <typename K, typename V>
struct pyMapChangedEventHandler
{
    static winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }
        
        Py_INCREF(callable);
        
        return [callable](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            PyObject* py_param0 = py::convert(param0);
            PyObject* py_param1 = py::convert(param1);
            
            PyObject* args = PyTuple_Pack(2, py_param0, py_param1);
            
            PyObject_CallObject(callable, args);
            Py_DECREF(callable);
        };
    };
};

template <typename T>
struct pyVectorChangedEventHandler
{
    static winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }
        
        Py_INCREF(callable);
        
        return [callable](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            PyObject* py_param0 = py::convert(param0);
            PyObject* py_param1 = py::convert(param1);
            
            PyObject* args = PyTuple_Pack(2, py_param0, py_param1);
            
            PyObject_CallObject(callable, args);
            Py_DECREF(callable);
        };
    };
};

struct pyIIterable
{
    virtual ~pyIIterable() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* First(PyObject* args) = 0;
};

template<typename T>
struct pyIIterableImpl : public pyIIterable
{
    pyIIterableImpl(winrt::Windows::Foundation::Collections::IIterable<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* First(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<T> return_value = obj.First();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IIterable<T> obj{ nullptr };
};

struct pyIIterator
{
    virtual ~pyIIterator() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* MoveNext(PyObject* args) = 0;
    virtual PyObject* get_Current() = 0;
    virtual PyObject* get_HasCurrent() = 0;
};

template<typename T>
struct pyIIteratorImpl : public pyIIterator
{
    pyIIteratorImpl(winrt::Windows::Foundation::Collections::IIterator<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* GetMany(PyObject* args) override
    {
        try
        {
            /*f*/ winrt::array_view<T> param0 { }; // TODO: Convert incoming python parameter
            
            uint32_t return_value = obj.GetMany(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* MoveNext(PyObject* args) override
    {
        try
        {
            bool return_value = obj.MoveNext();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Current() override
    {
        try
        {
            T return_value = obj.Current();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_HasCurrent() override
    {
        try
        {
            bool return_value = obj.HasCurrent();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IIterator<T> obj{ nullptr };
};

struct pyIKeyValuePair
{
    virtual ~pyIKeyValuePair() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* get_Key() = 0;
    virtual PyObject* get_Value() = 0;
};

template<typename K, typename V>
struct pyIKeyValuePairImpl : public pyIKeyValuePair
{
    pyIKeyValuePairImpl(winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* get_Key() override
    {
        try
        {
            K return_value = obj.Key();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Value() override
    {
        try
        {
            V return_value = obj.Value();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> obj{ nullptr };
};

struct pyIMapChangedEventArgs
{
    virtual ~pyIMapChangedEventArgs() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* get_CollectionChange() = 0;
    virtual PyObject* get_Key() = 0;
};

template<typename K>
struct pyIMapChangedEventArgsImpl : public pyIMapChangedEventArgs
{
    pyIMapChangedEventArgsImpl(winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* get_CollectionChange() override
    {
        try
        {
            winrt::Windows::Foundation::Collections::CollectionChange return_value = obj.CollectionChange();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Key() override
    {
        try
        {
            K return_value = obj.Key();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> obj{ nullptr };
};

struct pyIMapView
{
    virtual ~pyIMapView() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* Split(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename K, typename V>
struct pyIMapViewImpl : public pyIMapView
{
    pyIMapViewImpl(winrt::Windows::Foundation::Collections::IMapView<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* First(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>> return_value = obj.First();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* HasKey(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            bool return_value = obj.HasKey(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Lookup(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            V return_value = obj.Lookup(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Split(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<K, V> param0 { nullptr };
            winrt::Windows::Foundation::Collections::IMapView<K, V> param1 { nullptr };
            
            obj.Split(param0, param1);
            
            PyObject* out_param0 = py::convert(param0);
            if (!out_param0) 
            { 
                return nullptr;
            };
            
            PyObject* out_param1 = py::convert(param1);
            if (!out_param1) 
            { 
                return nullptr;
            };
            
            return PyTuple_Pack(2, out_param0, out_param1);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            uint32_t return_value = obj.Size();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IMapView<K, V> obj{ nullptr };
};

struct pyIMap
{
    virtual ~pyIMap() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* Insert(PyObject* args) = 0;
    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* Remove(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename K, typename V>
struct pyIMapImpl : public pyIMap
{
    pyIMapImpl(winrt::Windows::Foundation::Collections::IMap<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* Clear(PyObject* args) override
    {
        try
        {
            obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* First(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>> return_value = obj.First();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetView(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<K, V> return_value = obj.GetView();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* HasKey(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            bool return_value = obj.HasKey(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Insert(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            auto param1 = py::convert_to<V>(args, 1);
            
            bool return_value = obj.Insert(param0, param1);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Lookup(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            V return_value = obj.Lookup(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Remove(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            obj.Remove(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            uint32_t return_value = obj.Size();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IMap<K, V> obj{ nullptr };
};

struct pyIObservableMap
{
    virtual ~pyIObservableMap() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* Insert(PyObject* args) = 0;
    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* Remove(PyObject* args) = 0;
    virtual PyObject* add_MapChanged(PyObject* arg) = 0;
    virtual PyObject* get_Size() = 0;
    virtual PyObject* remove_MapChanged(PyObject* arg) = 0;
};

template<typename K, typename V>
struct pyIObservableMapImpl : public pyIObservableMap
{
    pyIObservableMapImpl(winrt::Windows::Foundation::Collections::IObservableMap<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* Clear(PyObject* args) override
    {
        try
        {
            obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* First(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>> return_value = obj.First();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetView(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<K, V> return_value = obj.GetView();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* HasKey(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            bool return_value = obj.HasKey(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Insert(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            auto param1 = py::convert_to<V>(args, 1);
            
            bool return_value = obj.Insert(param0, param1);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Lookup(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            V return_value = obj.Lookup(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Remove(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            
            obj.Remove(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* add_MapChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>::convert_to(arg);
            
            winrt::event_token return_value = obj.MapChanged(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            uint32_t return_value = obj.Size();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* remove_MapChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(arg);
            
            obj.MapChanged(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IObservableMap<K, V> obj{ nullptr };
};

struct pyIObservableVector
{
    virtual ~pyIObservableVector() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* Append(PyObject* args) = 0;
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* InsertAt(PyObject* args) = 0;
    virtual PyObject* RemoveAt(PyObject* args) = 0;
    virtual PyObject* RemoveAtEnd(PyObject* args) = 0;
    virtual PyObject* ReplaceAll(PyObject* args) = 0;
    virtual PyObject* SetAt(PyObject* args) = 0;
    virtual PyObject* add_VectorChanged(PyObject* arg) = 0;
    virtual PyObject* get_Size() = 0;
    virtual PyObject* remove_VectorChanged(PyObject* arg) = 0;
};

template<typename T>
struct pyIObservableVectorImpl : public pyIObservableVector
{
    pyIObservableVectorImpl(winrt::Windows::Foundation::Collections::IObservableVector<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* Append(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);
            
            obj.Append(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Clear(PyObject* args) override
    {
        try
        {
            obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* First(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<T> return_value = obj.First();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            T return_value = obj.GetAt(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetMany(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*f*/ winrt::array_view<T> param1 { }; // TODO: Convert incoming python parameter
            
            uint32_t return_value = obj.GetMany(param0, param1);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetView(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<T> return_value = obj.GetView();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* IndexOf(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);
            uint32_t param1 {  };
            
            bool return_value = obj.IndexOf(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };
            
            PyObject* out_param1 = py::convert(param1);
            if (!out_param1) 
            { 
                return nullptr;
            };
            
            return PyTuple_Pack(2, out_return_value, out_param1);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* InsertAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<T>(args, 1);
            
            obj.InsertAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* RemoveAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            obj.RemoveAt(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* RemoveAtEnd(PyObject* args) override
    {
        try
        {
            obj.RemoveAtEnd();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* ReplaceAll(PyObject* args) override
    {
        try
        {
            /*p*/ winrt::array_view<T const> param0 { }; // TODO: Convert incoming python parameter
            
            obj.ReplaceAll(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* SetAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<T>(args, 1);
            
            obj.SetAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* add_VectorChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>::convert_to(arg);
            
            winrt::event_token return_value = obj.VectorChanged(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            uint32_t return_value = obj.Size();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* remove_VectorChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(arg);
            
            obj.VectorChanged(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IObservableVector<T> obj{ nullptr };
};

struct pyIVectorView
{
    virtual ~pyIVectorView() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename T>
struct pyIVectorViewImpl : public pyIVectorView
{
    pyIVectorViewImpl(winrt::Windows::Foundation::Collections::IVectorView<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* First(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<T> return_value = obj.First();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            T return_value = obj.GetAt(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetMany(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*f*/ winrt::array_view<T> param1 { }; // TODO: Convert incoming python parameter
            
            uint32_t return_value = obj.GetMany(param0, param1);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* IndexOf(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);
            uint32_t param1 {  };
            
            bool return_value = obj.IndexOf(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };
            
            PyObject* out_param1 = py::convert(param1);
            if (!out_param1) 
            { 
                return nullptr;
            };
            
            return PyTuple_Pack(2, out_return_value, out_param1);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            uint32_t return_value = obj.Size();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IVectorView<T> obj{ nullptr };
};

struct pyIVector
{
    virtual ~pyIVector() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* Append(PyObject* args) = 0;
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* InsertAt(PyObject* args) = 0;
    virtual PyObject* RemoveAt(PyObject* args) = 0;
    virtual PyObject* RemoveAtEnd(PyObject* args) = 0;
    virtual PyObject* ReplaceAll(PyObject* args) = 0;
    virtual PyObject* SetAt(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename T>
struct pyIVectorImpl : public pyIVector
{
    pyIVectorImpl(winrt::Windows::Foundation::Collections::IVector<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* Append(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);
            
            obj.Append(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* Clear(PyObject* args) override
    {
        try
        {
            obj.Clear();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* First(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<T> return_value = obj.First();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            T return_value = obj.GetAt(param0);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetMany(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*f*/ winrt::array_view<T> param1 { }; // TODO: Convert incoming python parameter
            
            uint32_t return_value = obj.GetMany(param0, param1);
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* GetView(PyObject* args) override
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<T> return_value = obj.GetView();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* IndexOf(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);
            uint32_t param1 {  };
            
            bool return_value = obj.IndexOf(param0, param1);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };
            
            PyObject* out_param1 = py::convert(param1);
            if (!out_param1) 
            { 
                return nullptr;
            };
            
            return PyTuple_Pack(2, out_return_value, out_param1);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* InsertAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<T>(args, 1);
            
            obj.InsertAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* RemoveAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            
            obj.RemoveAt(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* RemoveAtEnd(PyObject* args) override
    {
        try
        {
            obj.RemoveAtEnd();
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* ReplaceAll(PyObject* args) override
    {
        try
        {
            /*p*/ winrt::array_view<T const> param0 { }; // TODO: Convert incoming python parameter
            
            obj.ReplaceAll(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* SetAt(PyObject* args) override
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<T>(args, 1);
            
            obj.SetAt(param0, param1);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            uint32_t return_value = obj.Size();
            
            return py::convert(return_value);
        }
        catch (...)
        {
            return  py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IVector<T> obj{ nullptr };
};

namespace py
{
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::PropertySet>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::StringMap>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::ValueSet>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIIterable>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIIterator>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIKeyValuePair>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIMapChangedEventArgs>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIMapView>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIMap>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIObservableMap>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIObservableVector>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::IPropertySet>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIVectorView>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIVector>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        using abstract = ::pyIIterable;
        using concrete = ::pyIIterableImpl<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterator<T>>
    {
        using abstract = ::pyIIterator;
        using concrete = ::pyIIteratorImpl<T>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>
    {
        using abstract = ::pyIKeyValuePair;
        using concrete = ::pyIKeyValuePairImpl<K, V>;
    };
    
    template <typename K>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>>
    {
        using abstract = ::pyIMapChangedEventArgs;
        using concrete = ::pyIMapChangedEventArgsImpl<K>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapView<K, V>>
    {
        using abstract = ::pyIMapView;
        using concrete = ::pyIMapViewImpl<K, V>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMap<K, V>>
    {
        using abstract = ::pyIMap;
        using concrete = ::pyIMapImpl<K, V>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableMap<K, V>>
    {
        using abstract = ::pyIObservableMap;
        using concrete = ::pyIObservableMapImpl<K, V>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableVector<T>>
    {
        using abstract = ::pyIObservableVector;
        using concrete = ::pyIObservableVectorImpl<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVectorView<T>>
    {
        using abstract = ::pyIVectorView;
        using concrete = ::pyIVectorViewImpl<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVector<T>>
    {
        using abstract = ::pyIVector;
        using concrete = ::pyIVectorImpl<T>;
    };
    
    template <typename K, typename V>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>
    {
        using type = ::pyMapChangedEventHandler<K, V>;
    };
    
    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>
    {
        using type = ::pyVectorChangedEventHandler<T>;
    };
    
}
