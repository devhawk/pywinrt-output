// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"

#if __has_include("py.Windows.Foundation.h")
#include "py.Windows.Foundation.h"
#endif

#include <winrt/Windows.Foundation.Collections.h>

template <typename K, typename V>
struct pyMapChangedEventHandler
{
    static winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }
        
        Py_INCREF(callable);
        
        return [callable](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            PyObject* py_param0 = py::convert(param0);
            PyObject* py_param1 = py::convert(param1);
            
            PyObject* args = PyTuple_Pack(2, py_param0, py_param1);
            
            PyObject_CallObject(callable, args);
            Py_DECREF(callable);
        };
    };
};

template <typename T>
struct pyVectorChangedEventHandler
{
    static winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }
        
        Py_INCREF(callable);
        
        return [callable](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            PyObject* py_param0 = py::convert(param0);
            PyObject* py_param1 = py::convert(param1);
            
            PyObject* args = PyTuple_Pack(2, py_param0, py_param1);
            
            PyObject_CallObject(callable, args);
            Py_DECREF(callable);
        };
    };
};

struct pyIIterable
{
    virtual ~pyIIterable() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    
    virtual PyObject* First(PyObject* args) = 0;
};

template<typename T>
struct pyIIterableImpl : public pyIIterable
{
    pyIIterableImpl(winrt::Windows::Foundation::Collections::IIterable<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* dunder_iter() override
    {
        try
        {
            return py::convert(obj.First());
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    PyObject* First(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.First();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    
    winrt::Windows::Foundation::Collections::IIterable<T> obj{ nullptr };
};

struct pyIIterator
{
    virtual ~pyIIterator() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    virtual PyObject* dunder_iternext() = 0;
    
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* MoveNext(PyObject* args) = 0;
    virtual PyObject* get_Current() = 0;
    virtual PyObject* get_HasCurrent() = 0;
};

template<typename T>
struct pyIIteratorImpl : public pyIIterator
{
    pyIIteratorImpl(winrt::Windows::Foundation::Collections::IIterator<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    PyObject* dunder_iter() override { return reinterpret_cast<PyObject*>(this); }
    
    PyObject* dunder_iternext() override
    {
        try
        {
            if (obj.HasCurrent())
            {
                auto cur = obj.Current();
                obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    PyObject* GetMany(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<T>::size_type>(args, 0);
                winrt::com_array<T> param0 ( param0_count, py::empty_instance<T>::get() );
                
                auto return_value = obj.GetMany(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                PyObject* out0 = py::convert(param0);
                if (!out0) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out_return_value, out0);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* MoveNext(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.MoveNext();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Current() override
    {
        try
        {
            auto return_value = obj.Current();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_HasCurrent() override
    {
        try
        {
            auto return_value = obj.HasCurrent();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IIterator<T> obj{ nullptr };
};

struct pyIKeyValuePair
{
    virtual ~pyIKeyValuePair() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* get_Key() = 0;
    virtual PyObject* get_Value() = 0;
};

template<typename K, typename V>
struct pyIKeyValuePairImpl : public pyIKeyValuePair
{
    pyIKeyValuePairImpl(winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* get_Key() override
    {
        try
        {
            auto return_value = obj.Key();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Value() override
    {
        try
        {
            auto return_value = obj.Value();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> obj{ nullptr };
};

struct pyIMapChangedEventArgs
{
    virtual ~pyIMapChangedEventArgs() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* get_CollectionChange() = 0;
    virtual PyObject* get_Key() = 0;
};

template<typename K>
struct pyIMapChangedEventArgsImpl : public pyIMapChangedEventArgs
{
    pyIMapChangedEventArgsImpl(winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* get_CollectionChange() override
    {
        try
        {
            auto return_value = obj.CollectionChange();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Key() override
    {
        try
        {
            auto return_value = obj.Key();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> obj{ nullptr };
};

struct pyIMapView
{
    virtual ~pyIMapView() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    virtual Py_ssize_t _mp_length() = 0;
    virtual PyObject* _mp_subscript(PyObject* key) = 0;
    
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* Split(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename K, typename V>
struct pyIMapViewImpl : public pyIMapView
{
    pyIMapViewImpl(winrt::Windows::Foundation::Collections::IMapView<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* dunder_iter() override
    {
        try
        {
            return py::convert(obj.First());
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    Py_ssize_t _mp_length() override
    {
        try
        {
            return static_cast<Py_ssize_t>(obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* _mp_subscript(PyObject* key) override
    {
        try
        {
            return py::convert(obj.Lookup(py::convert_to<K>(key)));
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    PyObject* First(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.First();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* HasKey(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                auto return_value = obj.HasKey(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Lookup(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                auto return_value = obj.Lookup(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Split(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Collections::IMapView<K, V> param0 { nullptr };
                winrt::Windows::Foundation::Collections::IMapView<K, V> param1 { nullptr };
                
                obj.Split(param0, param1);
                
                PyObject* out0 = py::convert(param0);
                if (!out0) 
                {
                    return nullptr;
                }
                
                PyObject* out1 = py::convert(param1);
                if (!out1) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out0, out1);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Size() override
    {
        try
        {
            auto return_value = obj.Size();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IMapView<K, V> obj{ nullptr };
};

struct pyIMap
{
    virtual ~pyIMap() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    virtual Py_ssize_t _mp_length() = 0;
    virtual PyObject* _mp_subscript(PyObject* key) = 0;
    virtual int _mp_ass_item(PyObject* key, PyObject* value) = 0;
    
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* Insert(PyObject* args) = 0;
    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* Remove(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename K, typename V>
struct pyIMapImpl : public pyIMap
{
    pyIMapImpl(winrt::Windows::Foundation::Collections::IMap<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* dunder_iter() override
    {
        try
        {
            return py::convert(obj.First());
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    Py_ssize_t _mp_length() override
    {
        try
        {
            return static_cast<Py_ssize_t>(obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* _mp_subscript(PyObject* key) override
    {
        try
        {
            return py::convert(obj.Lookup(py::convert_to<K>(key)));
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    int _mp_ass_item(PyObject* key, PyObject* value) override
    {
        try
        {
            if (value == nullptr) { obj.Remove(py::convert_to<K>(key)); }
            else { obj.Insert(py::convert_to<K>(key), py::convert_to<V>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* Clear(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Clear();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* First(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.First();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetView(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetView();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* HasKey(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                auto return_value = obj.HasKey(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Insert(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                auto param1 = py::convert_to<V>(args, 1);
                
                auto return_value = obj.Insert(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Lookup(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                auto return_value = obj.Lookup(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Remove(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                obj.Remove(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Size() override
    {
        try
        {
            auto return_value = obj.Size();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IMap<K, V> obj{ nullptr };
};

struct pyIObservableMap
{
    virtual ~pyIObservableMap() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    virtual Py_ssize_t _mp_length() = 0;
    virtual PyObject* _mp_subscript(PyObject* key) = 0;
    virtual int _mp_ass_item(PyObject* key, PyObject* value) = 0;
    
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* Insert(PyObject* args) = 0;
    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* Remove(PyObject* args) = 0;
    virtual PyObject* add_MapChanged(PyObject* arg) = 0;
    virtual PyObject* get_Size() = 0;
    virtual PyObject* remove_MapChanged(PyObject* arg) = 0;
};

template<typename K, typename V>
struct pyIObservableMapImpl : public pyIObservableMap
{
    pyIObservableMapImpl(winrt::Windows::Foundation::Collections::IObservableMap<K, V> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* dunder_iter() override
    {
        try
        {
            return py::convert(obj.First());
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    Py_ssize_t _mp_length() override
    {
        try
        {
            return static_cast<Py_ssize_t>(obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* _mp_subscript(PyObject* key) override
    {
        try
        {
            return py::convert(obj.Lookup(py::convert_to<K>(key)));
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    int _mp_ass_item(PyObject* key, PyObject* value) override
    {
        try
        {
            if (value == nullptr) { obj.Remove(py::convert_to<K>(key)); }
            else { obj.Insert(py::convert_to<K>(key), py::convert_to<V>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* Clear(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Clear();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* First(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.First();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetView(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetView();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* HasKey(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                auto return_value = obj.HasKey(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Insert(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                auto param1 = py::convert_to<V>(args, 1);
                
                auto return_value = obj.Insert(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Lookup(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                auto return_value = obj.Lookup(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Remove(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<K>(args, 0);
                
                obj.Remove(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* add_MapChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>(arg);
            
            auto return_value = obj.MapChanged(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            auto return_value = obj.Size();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* remove_MapChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);
            
            obj.MapChanged(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IObservableMap<K, V> obj{ nullptr };
};

struct pyIObservableVector
{
    virtual ~pyIObservableVector() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    virtual Py_ssize_t _sq_length() = 0;
    virtual PyObject* _sq_item(Py_ssize_t i) = 0;
    virtual int _sq_ass_item(Py_ssize_t i, PyObject* value) = 0;
    
    virtual PyObject* Append(PyObject* args) = 0;
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* InsertAt(PyObject* args) = 0;
    virtual PyObject* RemoveAt(PyObject* args) = 0;
    virtual PyObject* RemoveAtEnd(PyObject* args) = 0;
    virtual PyObject* ReplaceAll(PyObject* args) = 0;
    virtual PyObject* SetAt(PyObject* args) = 0;
    virtual PyObject* add_VectorChanged(PyObject* arg) = 0;
    virtual PyObject* get_Size() = 0;
    virtual PyObject* remove_VectorChanged(PyObject* arg) = 0;
};

template<typename T>
struct pyIObservableVectorImpl : public pyIObservableVector
{
    pyIObservableVectorImpl(winrt::Windows::Foundation::Collections::IObservableVector<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* dunder_iter() override
    {
        try
        {
            return py::convert(obj.First());
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    Py_ssize_t _sq_length() override
    {
        try
        {
            return static_cast<Py_ssize_t>(obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* _sq_item(Py_ssize_t i) override
    {
        try
        {
            return py::convert(obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    int _sq_ass_item(Py_ssize_t i, PyObject* value) override
    {
        try
        {
            if (value == nullptr) { obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { obj.SetAt(static_cast<uint32_t>(i), py::convert_to<T>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* Append(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<T>(args, 0);
                
                obj.Append(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Clear(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Clear();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* First(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.First();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                
                auto return_value = obj.GetAt(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetMany(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<T>::size_type>(args, 1);
                winrt::com_array<T> param1 ( param1_count, py::empty_instance<T>::get() );
                
                auto return_value = obj.GetMany(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                PyObject* out1 = py::convert(param1);
                if (!out1) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out_return_value, out1);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetView(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetView();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* IndexOf(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<T>(args, 0);
                uint32_t param1 {  };
                
                auto return_value = obj.IndexOf(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                PyObject* out1 = py::convert(param1);
                if (!out1) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out_return_value, out1);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* InsertAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<T>(args, 1);
                
                obj.InsertAt(param0, param1);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* RemoveAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                
                obj.RemoveAt(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* RemoveAtEnd(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.RemoveAtEnd();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* ReplaceAll(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto _param0 = py::convert_to<winrt::com_array<T>>(args, 0);
                auto param0 = winrt::array_view<const T>(_param0.begin(), _param0.end());
                
                obj.ReplaceAll(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* SetAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<T>(args, 1);
                
                obj.SetAt(param0, param1);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* add_VectorChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>(arg);
            
            auto return_value = obj.VectorChanged(param0);
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Size() override
    {
        try
        {
            auto return_value = obj.Size();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* remove_VectorChanged(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);
            
            obj.VectorChanged(param0);
            
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IObservableVector<T> obj{ nullptr };
};

struct pyIVectorView
{
    virtual ~pyIVectorView() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    virtual Py_ssize_t _sq_length() = 0;
    virtual PyObject* _sq_item(Py_ssize_t i) = 0;
    
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename T>
struct pyIVectorViewImpl : public pyIVectorView
{
    pyIVectorViewImpl(winrt::Windows::Foundation::Collections::IVectorView<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* dunder_iter() override
    {
        try
        {
            return py::convert(obj.First());
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    Py_ssize_t _sq_length() override
    {
        try
        {
            return static_cast<Py_ssize_t>(obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* _sq_item(Py_ssize_t i) override
    {
        try
        {
            return py::convert(obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    PyObject* First(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.First();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                
                auto return_value = obj.GetAt(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetMany(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<T>::size_type>(args, 1);
                winrt::com_array<T> param1 ( param1_count, py::empty_instance<T>::get() );
                
                auto return_value = obj.GetMany(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                PyObject* out1 = py::convert(param1);
                if (!out1) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out_return_value, out1);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* IndexOf(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<T>(args, 0);
                uint32_t param1 {  };
                
                auto return_value = obj.IndexOf(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                PyObject* out1 = py::convert(param1);
                if (!out1) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out_return_value, out1);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Size() override
    {
        try
        {
            auto return_value = obj.Size();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IVectorView<T> obj{ nullptr };
};

struct pyIVector
{
    virtual ~pyIVector() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_iter() = 0;
    virtual Py_ssize_t _sq_length() = 0;
    virtual PyObject* _sq_item(Py_ssize_t i) = 0;
    virtual int _sq_ass_item(Py_ssize_t i, PyObject* value) = 0;
    
    virtual PyObject* Append(PyObject* args) = 0;
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* First(PyObject* args) = 0;
    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* InsertAt(PyObject* args) = 0;
    virtual PyObject* RemoveAt(PyObject* args) = 0;
    virtual PyObject* RemoveAtEnd(PyObject* args) = 0;
    virtual PyObject* ReplaceAll(PyObject* args) = 0;
    virtual PyObject* SetAt(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename T>
struct pyIVectorImpl : public pyIVector
{
    pyIVectorImpl(winrt::Windows::Foundation::Collections::IVector<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* dunder_iter() override
    {
        try
        {
            return py::convert(obj.First());
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    Py_ssize_t _sq_length() override
    {
        try
        {
            return static_cast<Py_ssize_t>(obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* _sq_item(Py_ssize_t i) override
    {
        try
        {
            return py::convert(obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    int _sq_ass_item(Py_ssize_t i, PyObject* value) override
    {
        try
        {
            if (value == nullptr) { obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { obj.SetAt(static_cast<uint32_t>(i), py::convert_to<T>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }
    
    PyObject* Append(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<T>(args, 0);
                
                obj.Append(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Clear(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Clear();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* First(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.First();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                
                auto return_value = obj.GetAt(param0);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetMany(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<T>::size_type>(args, 1);
                winrt::com_array<T> param1 ( param1_count, py::empty_instance<T>::get() );
                
                auto return_value = obj.GetMany(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                PyObject* out1 = py::convert(param1);
                if (!out1) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out_return_value, out1);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetView(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetView();
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* IndexOf(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<T>(args, 0);
                uint32_t param1 {  };
                
                auto return_value = obj.IndexOf(param0, param1);
                
                PyObject* out_return_value = py::convert(return_value);
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                PyObject* out1 = py::convert(param1);
                if (!out1) 
                {
                    return nullptr;
                }
                
                return PyTuple_Pack(2, out_return_value, out1);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* InsertAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<T>(args, 1);
                
                obj.InsertAt(param0, param1);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* RemoveAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                
                obj.RemoveAt(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* RemoveAtEnd(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.RemoveAtEnd();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* ReplaceAll(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 1)
        {
            try
            {
                auto _param0 = py::convert_to<winrt::com_array<T>>(args, 0);
                auto param0 = winrt::array_view<const T>(_param0.begin(), _param0.end());
                
                obj.ReplaceAll(param0);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* SetAt(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<T>(args, 1);
                
                obj.SetAt(param0, param1);
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Size() override
    {
        try
        {
            auto return_value = obj.Size();
            
            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::Collections::IVector<T> obj{ nullptr };
};

namespace py
{
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::PropertySet>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::StringMap>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::ValueSet>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIIterable>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIIterator>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIKeyValuePair>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIMapChangedEventArgs>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIMapView>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIMap>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIObservableMap>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIObservableVector>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::IPropertySet>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIVectorView>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIVector>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        using abstract = ::pyIIterable;
        using concrete = ::pyIIterableImpl<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterator<T>>
    {
        using abstract = ::pyIIterator;
        using concrete = ::pyIIteratorImpl<T>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>
    {
        using abstract = ::pyIKeyValuePair;
        using concrete = ::pyIKeyValuePairImpl<K, V>;
    };
    
    template <typename K>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>>
    {
        using abstract = ::pyIMapChangedEventArgs;
        using concrete = ::pyIMapChangedEventArgsImpl<K>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapView<K, V>>
    {
        using abstract = ::pyIMapView;
        using concrete = ::pyIMapViewImpl<K, V>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMap<K, V>>
    {
        using abstract = ::pyIMap;
        using concrete = ::pyIMapImpl<K, V>;
    };
    
    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableMap<K, V>>
    {
        using abstract = ::pyIObservableMap;
        using concrete = ::pyIObservableMapImpl<K, V>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableVector<T>>
    {
        using abstract = ::pyIObservableVector;
        using concrete = ::pyIObservableVectorImpl<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVectorView<T>>
    {
        using abstract = ::pyIVectorView;
        using concrete = ::pyIVectorViewImpl<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVector<T>>
    {
        using abstract = ::pyIVector;
        using concrete = ::pyIVectorImpl<T>;
    };
    
    template <typename K, typename V>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>
    {
        using type = ::pyMapChangedEventHandler<K, V>;
    };
    
    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>
    {
        using type = ::pyVectorChangedEventHandler<T>;
    };
    
}
