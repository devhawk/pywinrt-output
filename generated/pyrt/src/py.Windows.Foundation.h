// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"

#if __has_include("py.Windows.Foundation.Collections.h")
#include "py.Windows.Foundation.Collections.h"
#endif

#include <winrt/Windows.Foundation.h>

struct pyAsyncActionCompletedHandler
{
    static winrt::Windows::Foundation::AsyncActionCompletedHandler get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

template <typename TProgress>
struct pyAsyncActionProgressHandler
{
    static winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress> get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

template <typename TProgress>
struct pyAsyncActionWithProgressCompletedHandler
{
    static winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress> get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

template <typename TResult>
struct pyAsyncOperationCompletedHandler
{
    static winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult> get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

template <typename TResult, typename TProgress>
struct pyAsyncOperationProgressHandler
{
    static winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress> get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

template <typename TResult, typename TProgress>
struct pyAsyncOperationWithProgressCompletedHandler
{
    static winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress> get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

struct pyDeferralCompletedHandler
{
    static winrt::Windows::Foundation::DeferralCompletedHandler get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)]()
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle args{ nullptr };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

template <typename T>
struct pyEventHandler
{
    static winrt::Windows::Foundation::EventHandler<T> get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

template <typename TSender, typename TResult>
struct pyTypedEventHandler
{
    static winrt::Windows::Foundation::TypedEventHandler<TSender, TResult> get(PyObject* callable)
    {
        py::throw_if_pyobj_null(callable);
        
        py::delegate_callable cb{ callable };
        
        return [cb = std::move(cb)](auto param0, auto param1)
        {
            winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };
            
            py::pyobj_handle py_param0{ py::convert(param0) };
            py::pyobj_handle py_param1{ py::convert(param1) };
            
            py::pyobj_handle args{ PyTuple_Pack(2, py_param0.detach(), py_param1.detach()) };
            
            PyObject_CallObject(cb.callable(), args.get());
        };
    };
};

struct pyIAsyncActionWithProgress
{
    virtual ~pyIAsyncActionWithProgress() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_await() = 0;
    
    virtual PyObject* Cancel(PyObject* args) = 0;
    virtual PyObject* Close(PyObject* args) = 0;
    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Completed() = 0;
    virtual PyObject* get_ErrorCode() = 0;
    virtual PyObject* get_Id() = 0;
    virtual PyObject* get_Progress() = 0;
    virtual PyObject* get_Status() = 0;
    virtual int put_Completed(PyObject* arg) = 0;
    virtual int put_Progress(PyObject* arg) = 0;
};

template<typename TProgress>
struct pyIAsyncActionWithProgressImpl : public pyIAsyncActionWithProgress
{
    pyIAsyncActionWithProgressImpl(winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    PyObject* dunder_await() override { return py::dunder_await(obj); }
    
    PyObject* Cancel(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Cancel();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Close(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Close();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetResults(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.GetResults();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Completed() override
    {
        try
        {
            auto return_value = obj.Completed();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_ErrorCode() override
    {
        try
        {
            auto return_value = obj.ErrorCode();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Id() override
    {
        try
        {
            auto return_value = obj.Id();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Progress() override
    {
        try
        {
            auto return_value = obj.Progress();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Status() override
    {
        try
        {
            auto return_value = obj.Status();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    int put_Completed(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>(arg);
            
            obj.Completed(param0);
            
            return 0;
        }
        catch (...)
        {
            return -1;
        }
    };
    
    int put_Progress(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>(arg);
            
            obj.Progress(param0);
            
            return 0;
        }
        catch (...)
        {
            return -1;
        }
    };
    
    
    winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> obj{ nullptr };
};

struct pyIAsyncOperationWithProgress
{
    virtual ~pyIAsyncOperationWithProgress() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_await() = 0;
    
    virtual PyObject* Cancel(PyObject* args) = 0;
    virtual PyObject* Close(PyObject* args) = 0;
    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Completed() = 0;
    virtual PyObject* get_ErrorCode() = 0;
    virtual PyObject* get_Id() = 0;
    virtual PyObject* get_Progress() = 0;
    virtual PyObject* get_Status() = 0;
    virtual int put_Completed(PyObject* arg) = 0;
    virtual int put_Progress(PyObject* arg) = 0;
};

template<typename TResult, typename TProgress>
struct pyIAsyncOperationWithProgressImpl : public pyIAsyncOperationWithProgress
{
    pyIAsyncOperationWithProgressImpl(winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    PyObject* dunder_await() override { return py::dunder_await(obj); }
    
    PyObject* Cancel(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Cancel();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Close(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Close();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetResults(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetResults();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Completed() override
    {
        try
        {
            auto return_value = obj.Completed();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_ErrorCode() override
    {
        try
        {
            auto return_value = obj.ErrorCode();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Id() override
    {
        try
        {
            auto return_value = obj.Id();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Progress() override
    {
        try
        {
            auto return_value = obj.Progress();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Status() override
    {
        try
        {
            auto return_value = obj.Status();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    int put_Completed(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>(arg);
            
            obj.Completed(param0);
            
            return 0;
        }
        catch (...)
        {
            return -1;
        }
    };
    
    int put_Progress(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>(arg);
            
            obj.Progress(param0);
            
            return 0;
        }
        catch (...)
        {
            return -1;
        }
    };
    
    
    winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> obj{ nullptr };
};

struct pyIAsyncOperation
{
    virtual ~pyIAsyncOperation() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    virtual PyObject* dunder_await() = 0;
    
    virtual PyObject* Cancel(PyObject* args) = 0;
    virtual PyObject* Close(PyObject* args) = 0;
    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Completed() = 0;
    virtual PyObject* get_ErrorCode() = 0;
    virtual PyObject* get_Id() = 0;
    virtual PyObject* get_Status() = 0;
    virtual int put_Completed(PyObject* arg) = 0;
};

template<typename TResult>
struct pyIAsyncOperationImpl : public pyIAsyncOperation
{
    pyIAsyncOperationImpl(winrt::Windows::Foundation::IAsyncOperation<TResult> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    PyObject* dunder_await() override { return py::dunder_await(obj); }
    
    PyObject* Cancel(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Cancel();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* Close(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                obj.Close();
                
                Py_RETURN_NONE;
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetResults(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetResults();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_Completed() override
    {
        try
        {
            auto return_value = obj.Completed();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_ErrorCode() override
    {
        try
        {
            auto return_value = obj.ErrorCode();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Id() override
    {
        try
        {
            auto return_value = obj.Id();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Status() override
    {
        try
        {
            auto return_value = obj.Status();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    int put_Completed(PyObject* arg) override
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>(arg);
            
            obj.Completed(param0);
            
            return 0;
        }
        catch (...)
        {
            return -1;
        }
    };
    
    
    winrt::Windows::Foundation::IAsyncOperation<TResult> obj{ nullptr };
};

struct pyIReferenceArray
{
    virtual ~pyIReferenceArray() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* GetBoolean(PyObject* args) = 0;
    virtual PyObject* GetBooleanArray(PyObject* args) = 0;
    virtual PyObject* GetChar16(PyObject* args) = 0;
    virtual PyObject* GetChar16Array(PyObject* args) = 0;
    virtual PyObject* GetDateTime(PyObject* args) = 0;
    virtual PyObject* GetDateTimeArray(PyObject* args) = 0;
    virtual PyObject* GetDouble(PyObject* args) = 0;
    virtual PyObject* GetDoubleArray(PyObject* args) = 0;
    virtual PyObject* GetGuid(PyObject* args) = 0;
    virtual PyObject* GetGuidArray(PyObject* args) = 0;
    virtual PyObject* GetInspectableArray(PyObject* args) = 0;
    virtual PyObject* GetInt16(PyObject* args) = 0;
    virtual PyObject* GetInt16Array(PyObject* args) = 0;
    virtual PyObject* GetInt32(PyObject* args) = 0;
    virtual PyObject* GetInt32Array(PyObject* args) = 0;
    virtual PyObject* GetInt64(PyObject* args) = 0;
    virtual PyObject* GetInt64Array(PyObject* args) = 0;
    virtual PyObject* GetPoint(PyObject* args) = 0;
    virtual PyObject* GetPointArray(PyObject* args) = 0;
    virtual PyObject* GetRect(PyObject* args) = 0;
    virtual PyObject* GetRectArray(PyObject* args) = 0;
    virtual PyObject* GetSingle(PyObject* args) = 0;
    virtual PyObject* GetSingleArray(PyObject* args) = 0;
    virtual PyObject* GetSize(PyObject* args) = 0;
    virtual PyObject* GetSizeArray(PyObject* args) = 0;
    virtual PyObject* GetString(PyObject* args) = 0;
    virtual PyObject* GetStringArray(PyObject* args) = 0;
    virtual PyObject* GetTimeSpan(PyObject* args) = 0;
    virtual PyObject* GetTimeSpanArray(PyObject* args) = 0;
    virtual PyObject* GetUInt16(PyObject* args) = 0;
    virtual PyObject* GetUInt16Array(PyObject* args) = 0;
    virtual PyObject* GetUInt32(PyObject* args) = 0;
    virtual PyObject* GetUInt32Array(PyObject* args) = 0;
    virtual PyObject* GetUInt64(PyObject* args) = 0;
    virtual PyObject* GetUInt64Array(PyObject* args) = 0;
    virtual PyObject* GetUInt8(PyObject* args) = 0;
    virtual PyObject* GetUInt8Array(PyObject* args) = 0;
    virtual PyObject* get_IsNumericScalar() = 0;
    virtual PyObject* get_Type() = 0;
    virtual PyObject* get_Value() = 0;
};

template<typename T>
struct pyIReferenceArrayImpl : public pyIReferenceArray
{
    pyIReferenceArrayImpl(winrt::Windows::Foundation::IReferenceArray<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* GetBoolean(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetBoolean();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetBooleanArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<bool> param0 { };
                
                obj.GetBooleanArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetChar16(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetChar16();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetChar16Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<char16_t> param0 { };
                
                obj.GetChar16Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDateTime(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetDateTime();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDateTimeArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };
                
                obj.GetDateTimeArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDouble(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetDouble();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDoubleArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<double> param0 { };
                
                obj.GetDoubleArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetGuid(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetGuid();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetGuidArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::guid> param0 { };
                
                obj.GetGuidArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInspectableArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };
                
                obj.GetInspectableArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt16(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetInt16();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt16Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int16_t> param0 { };
                
                obj.GetInt16Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt32(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetInt32();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt32Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int32_t> param0 { };
                
                obj.GetInt32Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt64(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetInt64();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt64Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int64_t> param0 { };
                
                obj.GetInt64Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetPoint(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetPoint();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetPointArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Point> param0 { };
                
                obj.GetPointArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetRect(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetRect();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetRectArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };
                
                obj.GetRectArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSingle(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetSingle();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSingleArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<float> param0 { };
                
                obj.GetSingleArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSize(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetSize();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSizeArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Size> param0 { };
                
                obj.GetSizeArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetString(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetString();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetStringArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::hstring> param0 { };
                
                obj.GetStringArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetTimeSpan(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetTimeSpan();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetTimeSpanArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };
                
                obj.GetTimeSpanArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt16(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt16();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt16Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint16_t> param0 { };
                
                obj.GetUInt16Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt32(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt32();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt32Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint32_t> param0 { };
                
                obj.GetUInt32Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt64(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt64();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt64Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint64_t> param0 { };
                
                obj.GetUInt64Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt8(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt8();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt8Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };
                
                obj.GetUInt8Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_IsNumericScalar() override
    {
        try
        {
            auto return_value = obj.IsNumericScalar();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Type() override
    {
        try
        {
            auto return_value = obj.Type();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Value() override
    {
        try
        {
            auto return_value = obj.Value();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::IReferenceArray<T> obj{ nullptr };
};

struct pyIReference
{
    virtual ~pyIReference() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;
    
    virtual PyObject* GetBoolean(PyObject* args) = 0;
    virtual PyObject* GetBooleanArray(PyObject* args) = 0;
    virtual PyObject* GetChar16(PyObject* args) = 0;
    virtual PyObject* GetChar16Array(PyObject* args) = 0;
    virtual PyObject* GetDateTime(PyObject* args) = 0;
    virtual PyObject* GetDateTimeArray(PyObject* args) = 0;
    virtual PyObject* GetDouble(PyObject* args) = 0;
    virtual PyObject* GetDoubleArray(PyObject* args) = 0;
    virtual PyObject* GetGuid(PyObject* args) = 0;
    virtual PyObject* GetGuidArray(PyObject* args) = 0;
    virtual PyObject* GetInspectableArray(PyObject* args) = 0;
    virtual PyObject* GetInt16(PyObject* args) = 0;
    virtual PyObject* GetInt16Array(PyObject* args) = 0;
    virtual PyObject* GetInt32(PyObject* args) = 0;
    virtual PyObject* GetInt32Array(PyObject* args) = 0;
    virtual PyObject* GetInt64(PyObject* args) = 0;
    virtual PyObject* GetInt64Array(PyObject* args) = 0;
    virtual PyObject* GetPoint(PyObject* args) = 0;
    virtual PyObject* GetPointArray(PyObject* args) = 0;
    virtual PyObject* GetRect(PyObject* args) = 0;
    virtual PyObject* GetRectArray(PyObject* args) = 0;
    virtual PyObject* GetSingle(PyObject* args) = 0;
    virtual PyObject* GetSingleArray(PyObject* args) = 0;
    virtual PyObject* GetSize(PyObject* args) = 0;
    virtual PyObject* GetSizeArray(PyObject* args) = 0;
    virtual PyObject* GetString(PyObject* args) = 0;
    virtual PyObject* GetStringArray(PyObject* args) = 0;
    virtual PyObject* GetTimeSpan(PyObject* args) = 0;
    virtual PyObject* GetTimeSpanArray(PyObject* args) = 0;
    virtual PyObject* GetUInt16(PyObject* args) = 0;
    virtual PyObject* GetUInt16Array(PyObject* args) = 0;
    virtual PyObject* GetUInt32(PyObject* args) = 0;
    virtual PyObject* GetUInt32Array(PyObject* args) = 0;
    virtual PyObject* GetUInt64(PyObject* args) = 0;
    virtual PyObject* GetUInt64Array(PyObject* args) = 0;
    virtual PyObject* GetUInt8(PyObject* args) = 0;
    virtual PyObject* GetUInt8Array(PyObject* args) = 0;
    virtual PyObject* get_IsNumericScalar() = 0;
    virtual PyObject* get_Type() = 0;
    virtual PyObject* get_Value() = 0;
};

template<typename T>
struct pyIReferenceImpl : public pyIReference
{
    pyIReferenceImpl(winrt::Windows::Foundation::IReference<T> o) : obj(o) {}
    winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
    std::size_t hash() override { return py::get_instance_hash(obj); }
    
    PyObject* GetBoolean(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetBoolean();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetBooleanArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<bool> param0 { };
                
                obj.GetBooleanArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetChar16(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetChar16();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetChar16Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<char16_t> param0 { };
                
                obj.GetChar16Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDateTime(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetDateTime();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDateTimeArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };
                
                obj.GetDateTimeArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDouble(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetDouble();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetDoubleArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<double> param0 { };
                
                obj.GetDoubleArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetGuid(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetGuid();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetGuidArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::guid> param0 { };
                
                obj.GetGuidArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInspectableArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };
                
                obj.GetInspectableArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt16(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetInt16();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt16Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int16_t> param0 { };
                
                obj.GetInt16Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt32(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetInt32();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt32Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int32_t> param0 { };
                
                obj.GetInt32Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt64(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetInt64();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetInt64Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int64_t> param0 { };
                
                obj.GetInt64Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetPoint(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetPoint();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetPointArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Point> param0 { };
                
                obj.GetPointArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetRect(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetRect();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetRectArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };
                
                obj.GetRectArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSingle(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetSingle();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSingleArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<float> param0 { };
                
                obj.GetSingleArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSize(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetSize();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetSizeArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Size> param0 { };
                
                obj.GetSizeArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetString(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetString();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetStringArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::hstring> param0 { };
                
                obj.GetStringArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetTimeSpan(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetTimeSpan();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetTimeSpanArray(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };
                
                obj.GetTimeSpanArray(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt16(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt16();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt16Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint16_t> param0 { };
                
                obj.GetUInt16Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt32(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt32();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt32Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint32_t> param0 { };
                
                obj.GetUInt32Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt64(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt64();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt64Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint64_t> param0 { };
                
                obj.GetUInt64Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt8(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                auto return_value = obj.GetUInt8();
                
                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value) 
                { 
                    return nullptr;
                }
                
                return out_return_value.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* GetUInt8Array(PyObject* args) override
    {
        Py_ssize_t arg_count = PyTuple_Size(args);
        
        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };
                
                obj.GetUInt8Array(param0);
                
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0) 
                {
                    return nullptr;
                }
                
                return out0.detach();
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
        else if (arg_count != -1)
        {
            PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
        }
        
        return nullptr;
    };
    
    PyObject* get_IsNumericScalar() override
    {
        try
        {
            auto return_value = obj.IsNumericScalar();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Type() override
    {
        try
        {
            auto return_value = obj.Type();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    PyObject* get_Value() override
    {
        try
        {
            auto return_value = obj.Value();
            
            py::pyobj_handle out_return_value{ py::convert(return_value) };
            if (!out_return_value) 
            { 
                return nullptr;
            }
            
            return out_return_value.detach();
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    };
    
    
    winrt::Windows::Foundation::IReference<T> obj{ nullptr };
};

namespace py
{
    template<>
    struct winrt_type<winrt::Windows::Foundation::Deferral>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::GuidHelper>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::MemoryBuffer>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::PropertyValue>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Uri>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IAsyncAction>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIAsyncActionWithProgress>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IAsyncInfo>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIAsyncOperationWithProgress>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIAsyncOperation>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IClosable>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IGetActivationFactory>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IMemoryBuffer>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IPropertyValue>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIReferenceArray>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<pyIReference>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IStringable>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::DateTime>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::event_token>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::hresult>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Point>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Rect>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::Size>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct winrt_type<winrt::Windows::Foundation::TimeSpan>
    {
        static PyTypeObject* python_type;
    
        static PyTypeObject* get_python_type()
        {
            return python_type;
        }
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::DateTime>
    {
        static PyObject* convert(winrt::Windows::Foundation::DateTime instance) noexcept;
        static winrt::Windows::Foundation::DateTime convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::event_token>
    {
        static PyObject* convert(winrt::event_token instance) noexcept;
        static winrt::event_token convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::hresult>
    {
        static PyObject* convert(winrt::hresult instance) noexcept;
        static winrt::hresult convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Point>
    {
        static PyObject* convert(winrt::Windows::Foundation::Point instance) noexcept;
        static winrt::Windows::Foundation::Point convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Rect>
    {
        static PyObject* convert(winrt::Windows::Foundation::Rect instance) noexcept;
        static winrt::Windows::Foundation::Rect convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Size>
    {
        static PyObject* convert(winrt::Windows::Foundation::Size instance) noexcept;
        static winrt::Windows::Foundation::Size convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::TimeSpan>
    {
        static PyObject* convert(winrt::Windows::Foundation::TimeSpan instance) noexcept;
        static winrt::Windows::Foundation::TimeSpan convert_to(PyObject* obj);
    };
    
    template <typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress>>
    {
        using abstract = ::pyIAsyncActionWithProgress;
        using concrete = ::pyIAsyncActionWithProgressImpl<TProgress>;
    };
    
    template <typename TResult, typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress>>
    {
        using abstract = ::pyIAsyncOperationWithProgress;
        using concrete = ::pyIAsyncOperationWithProgressImpl<TResult, TProgress>;
    };
    
    template <typename TResult>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperation<TResult>>
    {
        using abstract = ::pyIAsyncOperation;
        using concrete = ::pyIAsyncOperationImpl<TResult>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::IReferenceArray<T>>
    {
        using abstract = ::pyIReferenceArray;
        using concrete = ::pyIReferenceArrayImpl<T>;
    };
    
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::IReference<T>>
    {
        using abstract = ::pyIReference;
        using concrete = ::pyIReferenceImpl<T>;
    };
    
    template <>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionCompletedHandler>
    {
        using type = ::pyAsyncActionCompletedHandler;
    };
    
    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>
    {
        using type = ::pyAsyncActionProgressHandler<TProgress>;
    };
    
    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>
    {
        using type = ::pyAsyncActionWithProgressCompletedHandler<TProgress>;
    };
    
    template <typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>
    {
        using type = ::pyAsyncOperationCompletedHandler<TResult>;
    };
    
    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>
    {
        using type = ::pyAsyncOperationProgressHandler<TResult, TProgress>;
    };
    
    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>
    {
        using type = ::pyAsyncOperationWithProgressCompletedHandler<TResult, TProgress>;
    };
    
    template <>
    struct delegate_python_type<winrt::Windows::Foundation::DeferralCompletedHandler>
    {
        using type = ::pyDeferralCompletedHandler;
    };
    
    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::EventHandler<T>>
    {
        using type = ::pyEventHandler<T>;
    };
    
    template <typename TSender, typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::TypedEventHandler<TSender, TResult>>
    {
        using type = ::pyTypedEventHandler<TSender, TResult>;
    };
    
}
