// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Foundation.h"

// ----- Deferral class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Deferral>::python_type;


PyObject* Deferral_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DeferralCompletedHandler>(args, 0);
            winrt::Windows::Foundation::Deferral instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void Deferral_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::Deferral>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Deferral__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::Deferral>::convert(instance.as<winrt::Windows::Foundation::Deferral>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Deferral_Close(py::winrt_wrapper<winrt::Windows::Foundation::Deferral>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Deferral_Complete(py::winrt_wrapper<winrt::Windows::Foundation::Deferral>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Complete();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef Deferral_methods[] = {
    { "Close", (PyCFunction)Deferral_Close, METH_VARARGS, nullptr },
    { "Complete", (PyCFunction)Deferral_Complete, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)Deferral__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Deferral_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Deferral_dealloc },
    { Py_tp_new, Deferral_new },
    { Py_tp_methods, Deferral_methods },
    { 0, nullptr },
};

static PyType_Spec Deferral_Type_spec =
{
    "Deferral",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::Deferral>),
    0,
    Py_TPFLAGS_DEFAULT,
    Deferral_Type_slots
};

// ----- GuidHelper class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type;


PyObject* GuidHelper_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GuidHelper is not activatable");
    return nullptr;
}

static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = winrt::Windows::Foundation::GuidHelper::CreateNewGuid();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);

            bool return_value = winrt::Windows::Foundation::GuidHelper::Equals(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GuidHelper_get_Empty(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::guid return_value = winrt::Windows::Foundation::GuidHelper::Empty();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef GuidHelper_methods[] = {
    { "CreateNewGuid", (PyCFunction)GuidHelper_CreateNewGuid, METH_VARARGS | METH_STATIC, nullptr },
    { "Equals", (PyCFunction)GuidHelper_Equals, METH_VARARGS | METH_STATIC, nullptr },
    { "get_Empty", (PyCFunction)GuidHelper_get_Empty, METH_NOARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GuidHelper_Type_slots[] = 
{
    { Py_tp_new, GuidHelper_new },
    { Py_tp_methods, GuidHelper_methods },
    { 0, nullptr },
};

static PyType_Spec GuidHelper_Type_spec =
{
    "GuidHelper",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    GuidHelper_Type_slots
};

// ----- MemoryBuffer class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type;


PyObject* MemoryBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            winrt::Windows::Foundation::MemoryBuffer instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void MemoryBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MemoryBuffer__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::MemoryBuffer>::convert(instance.as<winrt::Windows::Foundation::MemoryBuffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* MemoryBuffer_Close(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* MemoryBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IMemoryBufferReference return_value = self->obj.CreateReference();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef MemoryBuffer_methods[] = {
    { "Close", (PyCFunction)MemoryBuffer_Close, METH_VARARGS, nullptr },
    { "CreateReference", (PyCFunction)MemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)MemoryBuffer__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot MemoryBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, MemoryBuffer_dealloc },
    { Py_tp_new, MemoryBuffer_new },
    { Py_tp_methods, MemoryBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec MemoryBuffer_Type_spec =
{
    "MemoryBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    MemoryBuffer_Type_slots
};

// ----- PropertyValue class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::PropertyValue>::python_type;


PyObject* PropertyValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PropertyValue is not activatable");
    return nullptr;
}

static PyObject* PropertyValue_CreateBoolean(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<bool>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateBoolean(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateBooleanArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<bool const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateBooleanArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateChar16(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<char16_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateChar16(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateChar16Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<char16_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateChar16Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateDateTime(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateDateTime(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateDateTimeArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::Windows::Foundation::DateTime const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateDateTimeArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateDouble(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<double>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateDouble(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateDoubleArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<double const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateDoubleArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateEmpty(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateEmpty();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateGuid(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateGuid(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateGuidArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::guid const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateGuidArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInspectable(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInspectable(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInspectableArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::Windows::Foundation::IInspectable const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInspectableArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInt16(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int16_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInt16(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInt16Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<int16_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInt16Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInt32(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int32_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInt32(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInt32Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<int32_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInt32Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInt64(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<int64_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInt64(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateInt64Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<int64_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateInt64Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreatePoint(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreatePoint(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreatePointArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::Windows::Foundation::Point const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreatePointArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateRect(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateRect(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateRectArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::Windows::Foundation::Rect const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateRectArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateSingle(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<float>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateSingle(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateSingleArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<float const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateSingleArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateSize(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateSize(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateSizeArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::Windows::Foundation::Size const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateSizeArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateString(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateString(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateStringArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::hstring const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateStringArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateTimeSpan(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateTimeSpan(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateTimeSpanArray(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<winrt::Windows::Foundation::TimeSpan const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateTimeSpanArray(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt16(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint16_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt16(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt16Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<uint16_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt16Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt32(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt32(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt32Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<uint32_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt32Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt64(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint64_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt64(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt64Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<uint64_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt64Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt8(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint8_t>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt8(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* PropertyValue_CreateUInt8Array(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<uint8_t const> param0 { }; // TODO: Convert incoming python parameter

            winrt::Windows::Foundation::IInspectable return_value = winrt::Windows::Foundation::PropertyValue::CreateUInt8Array(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef PropertyValue_methods[] = {
    { "CreateBoolean", (PyCFunction)PropertyValue_CreateBoolean, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateBooleanArray", (PyCFunction)PropertyValue_CreateBooleanArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateChar16", (PyCFunction)PropertyValue_CreateChar16, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateChar16Array", (PyCFunction)PropertyValue_CreateChar16Array, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateDateTime", (PyCFunction)PropertyValue_CreateDateTime, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateDateTimeArray", (PyCFunction)PropertyValue_CreateDateTimeArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateDouble", (PyCFunction)PropertyValue_CreateDouble, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateDoubleArray", (PyCFunction)PropertyValue_CreateDoubleArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateEmpty", (PyCFunction)PropertyValue_CreateEmpty, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateGuid", (PyCFunction)PropertyValue_CreateGuid, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateGuidArray", (PyCFunction)PropertyValue_CreateGuidArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInspectable", (PyCFunction)PropertyValue_CreateInspectable, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInspectableArray", (PyCFunction)PropertyValue_CreateInspectableArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInt16", (PyCFunction)PropertyValue_CreateInt16, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInt16Array", (PyCFunction)PropertyValue_CreateInt16Array, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInt32", (PyCFunction)PropertyValue_CreateInt32, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInt32Array", (PyCFunction)PropertyValue_CreateInt32Array, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInt64", (PyCFunction)PropertyValue_CreateInt64, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateInt64Array", (PyCFunction)PropertyValue_CreateInt64Array, METH_VARARGS | METH_STATIC, nullptr },
    { "CreatePoint", (PyCFunction)PropertyValue_CreatePoint, METH_VARARGS | METH_STATIC, nullptr },
    { "CreatePointArray", (PyCFunction)PropertyValue_CreatePointArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateRect", (PyCFunction)PropertyValue_CreateRect, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateRectArray", (PyCFunction)PropertyValue_CreateRectArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateSingle", (PyCFunction)PropertyValue_CreateSingle, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateSingleArray", (PyCFunction)PropertyValue_CreateSingleArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateSize", (PyCFunction)PropertyValue_CreateSize, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateSizeArray", (PyCFunction)PropertyValue_CreateSizeArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateString", (PyCFunction)PropertyValue_CreateString, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateStringArray", (PyCFunction)PropertyValue_CreateStringArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateTimeSpan", (PyCFunction)PropertyValue_CreateTimeSpan, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateTimeSpanArray", (PyCFunction)PropertyValue_CreateTimeSpanArray, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt16", (PyCFunction)PropertyValue_CreateUInt16, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt16Array", (PyCFunction)PropertyValue_CreateUInt16Array, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt32", (PyCFunction)PropertyValue_CreateUInt32, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt32Array", (PyCFunction)PropertyValue_CreateUInt32Array, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt64", (PyCFunction)PropertyValue_CreateUInt64, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt64Array", (PyCFunction)PropertyValue_CreateUInt64Array, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt8", (PyCFunction)PropertyValue_CreateUInt8, METH_VARARGS | METH_STATIC, nullptr },
    { "CreateUInt8Array", (PyCFunction)PropertyValue_CreateUInt8Array, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot PropertyValue_Type_slots[] = 
{
    { Py_tp_new, PropertyValue_new },
    { Py_tp_methods, PropertyValue_methods },
    { 0, nullptr },
};

static PyType_Spec PropertyValue_Type_spec =
{
    "PropertyValue",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    PropertyValue_Type_slots
};

// ----- Uri class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Uri>::python_type;


PyObject* Uri_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Foundation::Uri instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            winrt::Windows::Foundation::Uri instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void Uri_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Uri__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::Uri>::convert(instance.as<winrt::Windows::Foundation::Uri>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_CombineUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::Uri return_value = self->obj.CombineUri(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_Equals(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

            bool return_value = self->obj.Equals(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = winrt::Windows::Foundation::Uri::EscapeComponent(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_ToString(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.ToString();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = winrt::Windows::Foundation::Uri::UnescapeComponent(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_get_AbsoluteCanonicalUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.AbsoluteCanonicalUri();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_AbsoluteUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.AbsoluteUri();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_DisplayIri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayIri();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_DisplayUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.DisplayUri();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Domain(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Domain();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Extension(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Extension();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Fragment(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Fragment();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Host(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Host();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Password(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Password();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Path(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Path();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Port(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            int32_t return_value = self->obj.Port();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Query(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Query();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_QueryParsed(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::WwwFormUrlDecoder return_value = self->obj.QueryParsed();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_RawUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.RawUri();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_SchemeName(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.SchemeName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_Suspicious(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.Suspicious();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Uri_get_UserName(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.UserName();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Uri_methods[] = {
    { "CombineUri", (PyCFunction)Uri_CombineUri, METH_VARARGS, nullptr },
    { "Equals", (PyCFunction)Uri_Equals, METH_VARARGS, nullptr },
    { "EscapeComponent", (PyCFunction)Uri_EscapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { "ToString", (PyCFunction)Uri_ToString, METH_VARARGS, nullptr },
    { "UnescapeComponent", (PyCFunction)Uri_UnescapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { "get_AbsoluteCanonicalUri", (PyCFunction)Uri_get_AbsoluteCanonicalUri, METH_NOARGS, nullptr },
    { "get_AbsoluteUri", (PyCFunction)Uri_get_AbsoluteUri, METH_NOARGS, nullptr },
    { "get_DisplayIri", (PyCFunction)Uri_get_DisplayIri, METH_NOARGS, nullptr },
    { "get_DisplayUri", (PyCFunction)Uri_get_DisplayUri, METH_NOARGS, nullptr },
    { "get_Domain", (PyCFunction)Uri_get_Domain, METH_NOARGS, nullptr },
    { "get_Extension", (PyCFunction)Uri_get_Extension, METH_NOARGS, nullptr },
    { "get_Fragment", (PyCFunction)Uri_get_Fragment, METH_NOARGS, nullptr },
    { "get_Host", (PyCFunction)Uri_get_Host, METH_NOARGS, nullptr },
    { "get_Password", (PyCFunction)Uri_get_Password, METH_NOARGS, nullptr },
    { "get_Path", (PyCFunction)Uri_get_Path, METH_NOARGS, nullptr },
    { "get_Port", (PyCFunction)Uri_get_Port, METH_NOARGS, nullptr },
    { "get_Query", (PyCFunction)Uri_get_Query, METH_NOARGS, nullptr },
    { "get_QueryParsed", (PyCFunction)Uri_get_QueryParsed, METH_NOARGS, nullptr },
    { "get_RawUri", (PyCFunction)Uri_get_RawUri, METH_NOARGS, nullptr },
    { "get_SchemeName", (PyCFunction)Uri_get_SchemeName, METH_NOARGS, nullptr },
    { "get_Suspicious", (PyCFunction)Uri_get_Suspicious, METH_NOARGS, nullptr },
    { "get_UserName", (PyCFunction)Uri_get_UserName, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)Uri__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Uri_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Uri_dealloc },
    { Py_tp_new, Uri_new },
    { Py_tp_methods, Uri_methods },
    { 0, nullptr },
};

static PyType_Spec Uri_Type_spec =
{
    "Uri",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::Uri>),
    0,
    Py_TPFLAGS_DEFAULT,
    Uri_Type_slots
};

// ----- WwwFormUrlDecoder class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type;


PyObject* WwwFormUrlDecoder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Foundation::WwwFormUrlDecoder instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void WwwFormUrlDecoder_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoder__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::WwwFormUrlDecoder>::convert(instance.as<winrt::Windows::Foundation::WwwFormUrlDecoder>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* WwwFormUrlDecoder_First(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> return_value = self->obj.First();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetAt(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Foundation::IWwwFormUrlDecoderEntry return_value = self->obj.GetAt(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = self->obj.GetFirstValueByName(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetMany(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*f*/ winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> param1 { }; // TODO: Convert incoming python parameter

            uint32_t return_value = self->obj.GetMany(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_IndexOf(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
            uint32_t param1 {  };

            bool return_value = self->obj.IndexOf(param0, param1);

            PyObject* out_return_value = py::converter<decltype(return_value)>::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::converter<decltype(param1)>::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_get_Size(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Size();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef WwwFormUrlDecoder_methods[] = {
    { "First", (PyCFunction)WwwFormUrlDecoder_First, METH_VARARGS, nullptr },
    { "GetAt", (PyCFunction)WwwFormUrlDecoder_GetAt, METH_VARARGS, nullptr },
    { "GetFirstValueByName", (PyCFunction)WwwFormUrlDecoder_GetFirstValueByName, METH_VARARGS, nullptr },
    { "GetMany", (PyCFunction)WwwFormUrlDecoder_GetMany, METH_VARARGS, nullptr },
    { "IndexOf", (PyCFunction)WwwFormUrlDecoder_IndexOf, METH_VARARGS, nullptr },
    { "get_Size", (PyCFunction)WwwFormUrlDecoder_get_Size, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)WwwFormUrlDecoder__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot WwwFormUrlDecoder_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, WwwFormUrlDecoder_dealloc },
    { Py_tp_new, WwwFormUrlDecoder_new },
    { Py_tp_methods, WwwFormUrlDecoder_methods },
    { 0, nullptr },
};

static PyType_Spec WwwFormUrlDecoder_Type_spec =
{
    "WwwFormUrlDecoder",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>),
    0,
    Py_TPFLAGS_DEFAULT,
    WwwFormUrlDecoder_Type_slots
};

// ----- WwwFormUrlDecoderEntry class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type;


PyObject* WwwFormUrlDecoderEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "WwwFormUrlDecoderEntry is not activatable");
    return nullptr;
}

static void WwwFormUrlDecoderEntry_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoderEntry__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::convert(instance.as<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* WwwFormUrlDecoderEntry_get_Name(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* WwwFormUrlDecoderEntry_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Value();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef WwwFormUrlDecoderEntry_methods[] = {
    { "get_Name", (PyCFunction)WwwFormUrlDecoderEntry_get_Name, METH_NOARGS, nullptr },
    { "get_Value", (PyCFunction)WwwFormUrlDecoderEntry_get_Value, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)WwwFormUrlDecoderEntry__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot WwwFormUrlDecoderEntry_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, WwwFormUrlDecoderEntry_dealloc },
    { Py_tp_new, WwwFormUrlDecoderEntry_new },
    { Py_tp_methods, WwwFormUrlDecoderEntry_methods },
    { 0, nullptr },
};

static PyType_Spec WwwFormUrlDecoderEntry_Type_spec =
{
    "WwwFormUrlDecoderEntry",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    WwwFormUrlDecoderEntry_Type_slots
};

// ----- IAsyncAction interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type;


PyObject* IAsyncAction_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IAsyncAction interface is not activatable");
    return nullptr;
}

static void IAsyncAction_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncAction__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IAsyncAction>::convert(instance.as<winrt::Windows::Foundation::IAsyncAction>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IAsyncAction_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncAction_Close(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncAction_GetResults(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.GetResults();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncAction_get_Completed(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncActionCompletedHandler return_value = self->obj.Completed();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IAsyncAction_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hresult return_value = self->obj.ErrorCode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IAsyncAction_get_Id(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IAsyncAction_get_Status(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncStatus return_value = self->obj.Status();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IAsyncAction_put_Completed(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::AsyncActionCompletedHandler>::convert_to(args);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IAsyncAction_methods[] = {
    { "Cancel", (PyCFunction)IAsyncAction_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IAsyncAction_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)IAsyncAction_GetResults, METH_VARARGS, nullptr },
    { "get_Completed", (PyCFunction)IAsyncAction_get_Completed, METH_NOARGS, nullptr },
    { "get_ErrorCode", (PyCFunction)IAsyncAction_get_ErrorCode, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)IAsyncAction_get_Id, METH_NOARGS, nullptr },
    { "get_Status", (PyCFunction)IAsyncAction_get_Status, METH_NOARGS, nullptr },
    { "put_Completed", (PyCFunction)IAsyncAction_put_Completed, METH_O, nullptr },
    { "_from", (PyCFunction)IAsyncAction__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncAction_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncAction_dealloc },
    { Py_tp_new, IAsyncAction_new },
    { Py_tp_methods, IAsyncAction_methods },
    { 0, nullptr },
};

static PyType_Spec IAsyncAction_Type_spec =
{
    "IAsyncAction",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncAction_Type_slots
};

// ----- IAsyncActionWithProgress interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncActionWithProgress>::python_type;


PyObject* IAsyncActionWithProgress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IAsyncActionWithProgress interface is not activatable");
    return nullptr;
}

static void IAsyncActionWithProgress_dealloc(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IAsyncActionWithProgress_Cancel(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->Cancel(args);
}

static PyObject* IAsyncActionWithProgress_Close(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->Close(args);
}

static PyObject* IAsyncActionWithProgress_GetResults(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->GetResults(args);
}

static PyObject* IAsyncActionWithProgress_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Completed(args);
}

static PyObject* IAsyncActionWithProgress_get_ErrorCode(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_ErrorCode(args);
}

static PyObject* IAsyncActionWithProgress_get_Id(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Id(args);
}

static PyObject* IAsyncActionWithProgress_get_Progress(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Progress(args);
}

static PyObject* IAsyncActionWithProgress_get_Status(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Status(args);
}

static PyObject* IAsyncActionWithProgress_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->put_Completed(args);
}

static PyObject* IAsyncActionWithProgress_put_Progress(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{ 
    return self->obj->put_Progress(args);
}

static PyMethodDef IAsyncActionWithProgress_methods[] = {
    { "Cancel", (PyCFunction)IAsyncActionWithProgress_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IAsyncActionWithProgress_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)IAsyncActionWithProgress_GetResults, METH_VARARGS, nullptr },
    { "get_Completed", (PyCFunction)IAsyncActionWithProgress_get_Completed, METH_NOARGS, nullptr },
    { "get_ErrorCode", (PyCFunction)IAsyncActionWithProgress_get_ErrorCode, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)IAsyncActionWithProgress_get_Id, METH_NOARGS, nullptr },
    { "get_Progress", (PyCFunction)IAsyncActionWithProgress_get_Progress, METH_NOARGS, nullptr },
    { "get_Status", (PyCFunction)IAsyncActionWithProgress_get_Status, METH_NOARGS, nullptr },
    { "put_Completed", (PyCFunction)IAsyncActionWithProgress_put_Completed, METH_O, nullptr },
    { "put_Progress", (PyCFunction)IAsyncActionWithProgress_put_Progress, METH_O, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncActionWithProgress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncActionWithProgress_dealloc },
    { Py_tp_new, IAsyncActionWithProgress_new },
    { Py_tp_methods, IAsyncActionWithProgress_methods },
    { 0, nullptr },
};

static PyType_Spec IAsyncActionWithProgress_Type_spec =
{
    "IAsyncActionWithProgress",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncActionWithProgress_Type_slots
};

// ----- IAsyncInfo interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type;


PyObject* IAsyncInfo_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IAsyncInfo interface is not activatable");
    return nullptr;
}

static void IAsyncInfo_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncInfo__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IAsyncInfo>::convert(instance.as<winrt::Windows::Foundation::IAsyncInfo>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IAsyncInfo_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncInfo_Close(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncInfo_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hresult return_value = self->obj.ErrorCode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IAsyncInfo_get_Id(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IAsyncInfo_get_Status(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncStatus return_value = self->obj.Status();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IAsyncInfo_methods[] = {
    { "Cancel", (PyCFunction)IAsyncInfo_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IAsyncInfo_Close, METH_VARARGS, nullptr },
    { "get_ErrorCode", (PyCFunction)IAsyncInfo_get_ErrorCode, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)IAsyncInfo_get_Id, METH_NOARGS, nullptr },
    { "get_Status", (PyCFunction)IAsyncInfo_get_Status, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IAsyncInfo__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncInfo_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncInfo_dealloc },
    { Py_tp_new, IAsyncInfo_new },
    { Py_tp_methods, IAsyncInfo_methods },
    { 0, nullptr },
};

static PyType_Spec IAsyncInfo_Type_spec =
{
    "IAsyncInfo",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncInfo_Type_slots
};

// ----- IAsyncOperationWithProgress interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncOperationWithProgress>::python_type;


PyObject* IAsyncOperationWithProgress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IAsyncOperationWithProgress interface is not activatable");
    return nullptr;
}

static void IAsyncOperationWithProgress_dealloc(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperationWithProgress_Cancel(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->Cancel(args);
}

static PyObject* IAsyncOperationWithProgress_Close(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->Close(args);
}

static PyObject* IAsyncOperationWithProgress_GetResults(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperationWithProgress_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Completed(args);
}

static PyObject* IAsyncOperationWithProgress_get_ErrorCode(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_ErrorCode(args);
}

static PyObject* IAsyncOperationWithProgress_get_Id(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Id(args);
}

static PyObject* IAsyncOperationWithProgress_get_Progress(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Progress(args);
}

static PyObject* IAsyncOperationWithProgress_get_Status(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->get_Status(args);
}

static PyObject* IAsyncOperationWithProgress_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->put_Completed(args);
}

static PyObject* IAsyncOperationWithProgress_put_Progress(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{ 
    return self->obj->put_Progress(args);
}

static PyMethodDef IAsyncOperationWithProgress_methods[] = {
    { "Cancel", (PyCFunction)IAsyncOperationWithProgress_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IAsyncOperationWithProgress_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)IAsyncOperationWithProgress_GetResults, METH_VARARGS, nullptr },
    { "get_Completed", (PyCFunction)IAsyncOperationWithProgress_get_Completed, METH_NOARGS, nullptr },
    { "get_ErrorCode", (PyCFunction)IAsyncOperationWithProgress_get_ErrorCode, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)IAsyncOperationWithProgress_get_Id, METH_NOARGS, nullptr },
    { "get_Progress", (PyCFunction)IAsyncOperationWithProgress_get_Progress, METH_NOARGS, nullptr },
    { "get_Status", (PyCFunction)IAsyncOperationWithProgress_get_Status, METH_NOARGS, nullptr },
    { "put_Completed", (PyCFunction)IAsyncOperationWithProgress_put_Completed, METH_O, nullptr },
    { "put_Progress", (PyCFunction)IAsyncOperationWithProgress_put_Progress, METH_O, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncOperationWithProgress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncOperationWithProgress_dealloc },
    { Py_tp_new, IAsyncOperationWithProgress_new },
    { Py_tp_methods, IAsyncOperationWithProgress_methods },
    { 0, nullptr },
};

static PyType_Spec IAsyncOperationWithProgress_Type_spec =
{
    "IAsyncOperationWithProgress",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncOperationWithProgress_Type_slots
};

// ----- IAsyncOperation interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncOperation>::python_type;


PyObject* IAsyncOperation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IAsyncOperation interface is not activatable");
    return nullptr;
}

static void IAsyncOperation_dealloc(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperation_Cancel(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->Cancel(args);
}

static PyObject* IAsyncOperation_Close(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->Close(args);
}

static PyObject* IAsyncOperation_GetResults(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperation_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->get_Completed(args);
}

static PyObject* IAsyncOperation_get_ErrorCode(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->get_ErrorCode(args);
}

static PyObject* IAsyncOperation_get_Id(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->get_Id(args);
}

static PyObject* IAsyncOperation_get_Status(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->get_Status(args);
}

static PyObject* IAsyncOperation_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{ 
    return self->obj->put_Completed(args);
}

static PyMethodDef IAsyncOperation_methods[] = {
    { "Cancel", (PyCFunction)IAsyncOperation_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IAsyncOperation_Close, METH_VARARGS, nullptr },
    { "GetResults", (PyCFunction)IAsyncOperation_GetResults, METH_VARARGS, nullptr },
    { "get_Completed", (PyCFunction)IAsyncOperation_get_Completed, METH_NOARGS, nullptr },
    { "get_ErrorCode", (PyCFunction)IAsyncOperation_get_ErrorCode, METH_NOARGS, nullptr },
    { "get_Id", (PyCFunction)IAsyncOperation_get_Id, METH_NOARGS, nullptr },
    { "get_Status", (PyCFunction)IAsyncOperation_get_Status, METH_NOARGS, nullptr },
    { "put_Completed", (PyCFunction)IAsyncOperation_put_Completed, METH_O, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncOperation_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncOperation_dealloc },
    { Py_tp_new, IAsyncOperation_new },
    { Py_tp_methods, IAsyncOperation_methods },
    { 0, nullptr },
};

static PyType_Spec IAsyncOperation_Type_spec =
{
    "IAsyncOperation",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncOperation>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncOperation_Type_slots
};

// ----- IClosable interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type;


PyObject* IClosable_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IClosable interface is not activatable");
    return nullptr;
}

static void IClosable_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IClosable__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IClosable>::convert(instance.as<winrt::Windows::Foundation::IClosable>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IClosable_Close(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IClosable_methods[] = {
    { "Close", (PyCFunction)IClosable_Close, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IClosable__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IClosable_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IClosable_dealloc },
    { Py_tp_new, IClosable_new },
    { Py_tp_methods, IClosable_methods },
    { 0, nullptr },
};

static PyType_Spec IClosable_Type_spec =
{
    "IClosable",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>),
    0,
    Py_TPFLAGS_DEFAULT,
    IClosable_Type_slots
};

// ----- IGetActivationFactory interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type;


PyObject* IGetActivationFactory_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IGetActivationFactory interface is not activatable");
    return nullptr;
}

static void IGetActivationFactory_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGetActivationFactory__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IGetActivationFactory>::convert(instance.as<winrt::Windows::Foundation::IGetActivationFactory>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IGetActivationFactory_GetActivationFactory(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = self->obj.GetActivationFactory(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IGetActivationFactory_methods[] = {
    { "GetActivationFactory", (PyCFunction)IGetActivationFactory_GetActivationFactory, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IGetActivationFactory__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IGetActivationFactory_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IGetActivationFactory_dealloc },
    { Py_tp_new, IGetActivationFactory_new },
    { Py_tp_methods, IGetActivationFactory_methods },
    { 0, nullptr },
};

static PyType_Spec IGetActivationFactory_Type_spec =
{
    "IGetActivationFactory",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>),
    0,
    Py_TPFLAGS_DEFAULT,
    IGetActivationFactory_Type_slots
};

// ----- IMemoryBuffer interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type;


PyObject* IMemoryBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IMemoryBuffer interface is not activatable");
    return nullptr;
}

static void IMemoryBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBuffer__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IMemoryBuffer>::convert(instance.as<winrt::Windows::Foundation::IMemoryBuffer>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IMemoryBuffer_Close(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IMemoryBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IMemoryBufferReference return_value = self->obj.CreateReference();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IMemoryBuffer_methods[] = {
    { "Close", (PyCFunction)IMemoryBuffer_Close, METH_VARARGS, nullptr },
    { "CreateReference", (PyCFunction)IMemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IMemoryBuffer__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IMemoryBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IMemoryBuffer_dealloc },
    { Py_tp_new, IMemoryBuffer_new },
    { Py_tp_methods, IMemoryBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec IMemoryBuffer_Type_spec =
{
    "IMemoryBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMemoryBuffer_Type_slots
};

// ----- IMemoryBufferReference interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type;


PyObject* IMemoryBufferReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IMemoryBufferReference interface is not activatable");
    return nullptr;
}

static void IMemoryBufferReference_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBufferReference__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IMemoryBufferReference>::convert(instance.as<winrt::Windows::Foundation::IMemoryBufferReference>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IMemoryBufferReference_Close(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IMemoryBufferReference_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IMemoryBufferReference, winrt::Windows::Foundation::IInspectable>>::convert_to(args);

            winrt::event_token return_value = self->obj.Closed(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IMemoryBufferReference_get_Capacity(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.Capacity();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IMemoryBufferReference_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IMemoryBufferReference_methods[] = {
    { "Close", (PyCFunction)IMemoryBufferReference_Close, METH_VARARGS, nullptr },
    { "add_Closed", (PyCFunction)IMemoryBufferReference_add_Closed, METH_O, nullptr },
    { "get_Capacity", (PyCFunction)IMemoryBufferReference_get_Capacity, METH_NOARGS, nullptr },
    { "remove_Closed", (PyCFunction)IMemoryBufferReference_remove_Closed, METH_O, nullptr },
    { "_from", (PyCFunction)IMemoryBufferReference__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IMemoryBufferReference_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IMemoryBufferReference_dealloc },
    { Py_tp_new, IMemoryBufferReference_new },
    { Py_tp_methods, IMemoryBufferReference_methods },
    { 0, nullptr },
};

static PyType_Spec IMemoryBufferReference_Type_spec =
{
    "IMemoryBufferReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMemoryBufferReference_Type_slots
};

// ----- IPropertyValue interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IPropertyValue>::python_type;


PyObject* IPropertyValue_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IPropertyValue interface is not activatable");
    return nullptr;
}

static void IPropertyValue_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IPropertyValue__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IPropertyValue>::convert(instance.as<winrt::Windows::Foundation::IPropertyValue>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IPropertyValue_GetBoolean(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            bool return_value = self->obj.GetBoolean();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetBooleanArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<bool> param0 { };

            self->obj.GetBooleanArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetChar16(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            char16_t return_value = self->obj.GetChar16();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetChar16Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<char16_t> param0 { };

            self->obj.GetChar16Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetDateTime(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.GetDateTime();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetDateTimeArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };

            self->obj.GetDateTimeArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetDouble(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            double return_value = self->obj.GetDouble();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetDoubleArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<double> param0 { };

            self->obj.GetDoubleArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetGuid(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = self->obj.GetGuid();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetGuidArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::guid> param0 { };

            self->obj.GetGuidArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetInspectableArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };

            self->obj.GetInspectableArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetInt16(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int16_t return_value = self->obj.GetInt16();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetInt16Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<int16_t> param0 { };

            self->obj.GetInt16Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetInt32(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int32_t return_value = self->obj.GetInt32();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetInt32Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<int32_t> param0 { };

            self->obj.GetInt32Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetInt64(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            int64_t return_value = self->obj.GetInt64();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetInt64Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<int64_t> param0 { };

            self->obj.GetInt64Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetPoint(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Point return_value = self->obj.GetPoint();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetPointArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::Windows::Foundation::Point> param0 { };

            self->obj.GetPointArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetRect(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Rect return_value = self->obj.GetRect();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetRectArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };

            self->obj.GetRectArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetSingle(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            float return_value = self->obj.GetSingle();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetSingleArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<float> param0 { };

            self->obj.GetSingleArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetSize(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Size return_value = self->obj.GetSize();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetSizeArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::Windows::Foundation::Size> param0 { };

            self->obj.GetSizeArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetString(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.GetString();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetStringArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::hstring> param0 { };

            self->obj.GetStringArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetTimeSpan(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::TimeSpan return_value = self->obj.GetTimeSpan();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetTimeSpanArray(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };

            self->obj.GetTimeSpanArray(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt16(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint16_t return_value = self->obj.GetUInt16();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt16Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<uint16_t> param0 { };

            self->obj.GetUInt16Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt32(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint32_t return_value = self->obj.GetUInt32();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt32Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<uint32_t> param0 { };

            self->obj.GetUInt32Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt64(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint64_t return_value = self->obj.GetUInt64();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt64Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<uint64_t> param0 { };

            self->obj.GetUInt64Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt8(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            uint8_t return_value = self->obj.GetUInt8();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_GetUInt8Array(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::com_array<uint8_t> param0 { };

            self->obj.GetUInt8Array(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IPropertyValue_get_IsNumericScalar(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = self->obj.IsNumericScalar();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IPropertyValue_get_Type(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::PropertyType return_value = self->obj.Type();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IPropertyValue_methods[] = {
    { "GetBoolean", (PyCFunction)IPropertyValue_GetBoolean, METH_VARARGS, nullptr },
    { "GetBooleanArray", (PyCFunction)IPropertyValue_GetBooleanArray, METH_VARARGS, nullptr },
    { "GetChar16", (PyCFunction)IPropertyValue_GetChar16, METH_VARARGS, nullptr },
    { "GetChar16Array", (PyCFunction)IPropertyValue_GetChar16Array, METH_VARARGS, nullptr },
    { "GetDateTime", (PyCFunction)IPropertyValue_GetDateTime, METH_VARARGS, nullptr },
    { "GetDateTimeArray", (PyCFunction)IPropertyValue_GetDateTimeArray, METH_VARARGS, nullptr },
    { "GetDouble", (PyCFunction)IPropertyValue_GetDouble, METH_VARARGS, nullptr },
    { "GetDoubleArray", (PyCFunction)IPropertyValue_GetDoubleArray, METH_VARARGS, nullptr },
    { "GetGuid", (PyCFunction)IPropertyValue_GetGuid, METH_VARARGS, nullptr },
    { "GetGuidArray", (PyCFunction)IPropertyValue_GetGuidArray, METH_VARARGS, nullptr },
    { "GetInspectableArray", (PyCFunction)IPropertyValue_GetInspectableArray, METH_VARARGS, nullptr },
    { "GetInt16", (PyCFunction)IPropertyValue_GetInt16, METH_VARARGS, nullptr },
    { "GetInt16Array", (PyCFunction)IPropertyValue_GetInt16Array, METH_VARARGS, nullptr },
    { "GetInt32", (PyCFunction)IPropertyValue_GetInt32, METH_VARARGS, nullptr },
    { "GetInt32Array", (PyCFunction)IPropertyValue_GetInt32Array, METH_VARARGS, nullptr },
    { "GetInt64", (PyCFunction)IPropertyValue_GetInt64, METH_VARARGS, nullptr },
    { "GetInt64Array", (PyCFunction)IPropertyValue_GetInt64Array, METH_VARARGS, nullptr },
    { "GetPoint", (PyCFunction)IPropertyValue_GetPoint, METH_VARARGS, nullptr },
    { "GetPointArray", (PyCFunction)IPropertyValue_GetPointArray, METH_VARARGS, nullptr },
    { "GetRect", (PyCFunction)IPropertyValue_GetRect, METH_VARARGS, nullptr },
    { "GetRectArray", (PyCFunction)IPropertyValue_GetRectArray, METH_VARARGS, nullptr },
    { "GetSingle", (PyCFunction)IPropertyValue_GetSingle, METH_VARARGS, nullptr },
    { "GetSingleArray", (PyCFunction)IPropertyValue_GetSingleArray, METH_VARARGS, nullptr },
    { "GetSize", (PyCFunction)IPropertyValue_GetSize, METH_VARARGS, nullptr },
    { "GetSizeArray", (PyCFunction)IPropertyValue_GetSizeArray, METH_VARARGS, nullptr },
    { "GetString", (PyCFunction)IPropertyValue_GetString, METH_VARARGS, nullptr },
    { "GetStringArray", (PyCFunction)IPropertyValue_GetStringArray, METH_VARARGS, nullptr },
    { "GetTimeSpan", (PyCFunction)IPropertyValue_GetTimeSpan, METH_VARARGS, nullptr },
    { "GetTimeSpanArray", (PyCFunction)IPropertyValue_GetTimeSpanArray, METH_VARARGS, nullptr },
    { "GetUInt16", (PyCFunction)IPropertyValue_GetUInt16, METH_VARARGS, nullptr },
    { "GetUInt16Array", (PyCFunction)IPropertyValue_GetUInt16Array, METH_VARARGS, nullptr },
    { "GetUInt32", (PyCFunction)IPropertyValue_GetUInt32, METH_VARARGS, nullptr },
    { "GetUInt32Array", (PyCFunction)IPropertyValue_GetUInt32Array, METH_VARARGS, nullptr },
    { "GetUInt64", (PyCFunction)IPropertyValue_GetUInt64, METH_VARARGS, nullptr },
    { "GetUInt64Array", (PyCFunction)IPropertyValue_GetUInt64Array, METH_VARARGS, nullptr },
    { "GetUInt8", (PyCFunction)IPropertyValue_GetUInt8, METH_VARARGS, nullptr },
    { "GetUInt8Array", (PyCFunction)IPropertyValue_GetUInt8Array, METH_VARARGS, nullptr },
    { "get_IsNumericScalar", (PyCFunction)IPropertyValue_get_IsNumericScalar, METH_NOARGS, nullptr },
    { "get_Type", (PyCFunction)IPropertyValue_get_Type, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IPropertyValue__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IPropertyValue_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IPropertyValue_dealloc },
    { Py_tp_new, IPropertyValue_new },
    { Py_tp_methods, IPropertyValue_methods },
    { 0, nullptr },
};

static PyType_Spec IPropertyValue_Type_spec =
{
    "IPropertyValue",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IPropertyValue>),
    0,
    Py_TPFLAGS_DEFAULT,
    IPropertyValue_Type_slots
};

// ----- IReferenceArray interface --------------------
PyTypeObject* py::winrt_type<pyIReferenceArray>::python_type;


PyObject* IReferenceArray_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IReferenceArray interface is not activatable");
    return nullptr;
}

static void IReferenceArray_dealloc(py::winrt_pinterface_wrapper<pyIReferenceArray>* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IReferenceArray_GetBoolean(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetBoolean(args);
}

static PyObject* IReferenceArray_GetBooleanArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetBooleanArray(args);
}

static PyObject* IReferenceArray_GetChar16(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetChar16(args);
}

static PyObject* IReferenceArray_GetChar16Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetChar16Array(args);
}

static PyObject* IReferenceArray_GetDateTime(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetDateTime(args);
}

static PyObject* IReferenceArray_GetDateTimeArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetDateTimeArray(args);
}

static PyObject* IReferenceArray_GetDouble(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetDouble(args);
}

static PyObject* IReferenceArray_GetDoubleArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetDoubleArray(args);
}

static PyObject* IReferenceArray_GetGuid(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetGuid(args);
}

static PyObject* IReferenceArray_GetGuidArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetGuidArray(args);
}

static PyObject* IReferenceArray_GetInspectableArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetInspectableArray(args);
}

static PyObject* IReferenceArray_GetInt16(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetInt16(args);
}

static PyObject* IReferenceArray_GetInt16Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetInt16Array(args);
}

static PyObject* IReferenceArray_GetInt32(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetInt32(args);
}

static PyObject* IReferenceArray_GetInt32Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetInt32Array(args);
}

static PyObject* IReferenceArray_GetInt64(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetInt64(args);
}

static PyObject* IReferenceArray_GetInt64Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetInt64Array(args);
}

static PyObject* IReferenceArray_GetPoint(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetPoint(args);
}

static PyObject* IReferenceArray_GetPointArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetPointArray(args);
}

static PyObject* IReferenceArray_GetRect(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetRect(args);
}

static PyObject* IReferenceArray_GetRectArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetRectArray(args);
}

static PyObject* IReferenceArray_GetSingle(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetSingle(args);
}

static PyObject* IReferenceArray_GetSingleArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetSingleArray(args);
}

static PyObject* IReferenceArray_GetSize(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetSize(args);
}

static PyObject* IReferenceArray_GetSizeArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetSizeArray(args);
}

static PyObject* IReferenceArray_GetString(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetString(args);
}

static PyObject* IReferenceArray_GetStringArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetStringArray(args);
}

static PyObject* IReferenceArray_GetTimeSpan(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetTimeSpan(args);
}

static PyObject* IReferenceArray_GetTimeSpanArray(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetTimeSpanArray(args);
}

static PyObject* IReferenceArray_GetUInt16(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt16(args);
}

static PyObject* IReferenceArray_GetUInt16Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt16Array(args);
}

static PyObject* IReferenceArray_GetUInt32(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt32(args);
}

static PyObject* IReferenceArray_GetUInt32Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt32Array(args);
}

static PyObject* IReferenceArray_GetUInt64(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt64(args);
}

static PyObject* IReferenceArray_GetUInt64Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt64Array(args);
}

static PyObject* IReferenceArray_GetUInt8(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt8(args);
}

static PyObject* IReferenceArray_GetUInt8Array(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->GetUInt8Array(args);
}

static PyObject* IReferenceArray_get_IsNumericScalar(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->get_IsNumericScalar(args);
}

static PyObject* IReferenceArray_get_Type(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->get_Type(args);
}

static PyObject* IReferenceArray_get_Value(py::winrt_pinterface_wrapper<pyIReferenceArray>* self, PyObject* args)
{ 
    return self->obj->get_Value(args);
}

static PyMethodDef IReferenceArray_methods[] = {
    { "GetBoolean", (PyCFunction)IReferenceArray_GetBoolean, METH_VARARGS, nullptr },
    { "GetBooleanArray", (PyCFunction)IReferenceArray_GetBooleanArray, METH_VARARGS, nullptr },
    { "GetChar16", (PyCFunction)IReferenceArray_GetChar16, METH_VARARGS, nullptr },
    { "GetChar16Array", (PyCFunction)IReferenceArray_GetChar16Array, METH_VARARGS, nullptr },
    { "GetDateTime", (PyCFunction)IReferenceArray_GetDateTime, METH_VARARGS, nullptr },
    { "GetDateTimeArray", (PyCFunction)IReferenceArray_GetDateTimeArray, METH_VARARGS, nullptr },
    { "GetDouble", (PyCFunction)IReferenceArray_GetDouble, METH_VARARGS, nullptr },
    { "GetDoubleArray", (PyCFunction)IReferenceArray_GetDoubleArray, METH_VARARGS, nullptr },
    { "GetGuid", (PyCFunction)IReferenceArray_GetGuid, METH_VARARGS, nullptr },
    { "GetGuidArray", (PyCFunction)IReferenceArray_GetGuidArray, METH_VARARGS, nullptr },
    { "GetInspectableArray", (PyCFunction)IReferenceArray_GetInspectableArray, METH_VARARGS, nullptr },
    { "GetInt16", (PyCFunction)IReferenceArray_GetInt16, METH_VARARGS, nullptr },
    { "GetInt16Array", (PyCFunction)IReferenceArray_GetInt16Array, METH_VARARGS, nullptr },
    { "GetInt32", (PyCFunction)IReferenceArray_GetInt32, METH_VARARGS, nullptr },
    { "GetInt32Array", (PyCFunction)IReferenceArray_GetInt32Array, METH_VARARGS, nullptr },
    { "GetInt64", (PyCFunction)IReferenceArray_GetInt64, METH_VARARGS, nullptr },
    { "GetInt64Array", (PyCFunction)IReferenceArray_GetInt64Array, METH_VARARGS, nullptr },
    { "GetPoint", (PyCFunction)IReferenceArray_GetPoint, METH_VARARGS, nullptr },
    { "GetPointArray", (PyCFunction)IReferenceArray_GetPointArray, METH_VARARGS, nullptr },
    { "GetRect", (PyCFunction)IReferenceArray_GetRect, METH_VARARGS, nullptr },
    { "GetRectArray", (PyCFunction)IReferenceArray_GetRectArray, METH_VARARGS, nullptr },
    { "GetSingle", (PyCFunction)IReferenceArray_GetSingle, METH_VARARGS, nullptr },
    { "GetSingleArray", (PyCFunction)IReferenceArray_GetSingleArray, METH_VARARGS, nullptr },
    { "GetSize", (PyCFunction)IReferenceArray_GetSize, METH_VARARGS, nullptr },
    { "GetSizeArray", (PyCFunction)IReferenceArray_GetSizeArray, METH_VARARGS, nullptr },
    { "GetString", (PyCFunction)IReferenceArray_GetString, METH_VARARGS, nullptr },
    { "GetStringArray", (PyCFunction)IReferenceArray_GetStringArray, METH_VARARGS, nullptr },
    { "GetTimeSpan", (PyCFunction)IReferenceArray_GetTimeSpan, METH_VARARGS, nullptr },
    { "GetTimeSpanArray", (PyCFunction)IReferenceArray_GetTimeSpanArray, METH_VARARGS, nullptr },
    { "GetUInt16", (PyCFunction)IReferenceArray_GetUInt16, METH_VARARGS, nullptr },
    { "GetUInt16Array", (PyCFunction)IReferenceArray_GetUInt16Array, METH_VARARGS, nullptr },
    { "GetUInt32", (PyCFunction)IReferenceArray_GetUInt32, METH_VARARGS, nullptr },
    { "GetUInt32Array", (PyCFunction)IReferenceArray_GetUInt32Array, METH_VARARGS, nullptr },
    { "GetUInt64", (PyCFunction)IReferenceArray_GetUInt64, METH_VARARGS, nullptr },
    { "GetUInt64Array", (PyCFunction)IReferenceArray_GetUInt64Array, METH_VARARGS, nullptr },
    { "GetUInt8", (PyCFunction)IReferenceArray_GetUInt8, METH_VARARGS, nullptr },
    { "GetUInt8Array", (PyCFunction)IReferenceArray_GetUInt8Array, METH_VARARGS, nullptr },
    { "get_IsNumericScalar", (PyCFunction)IReferenceArray_get_IsNumericScalar, METH_NOARGS, nullptr },
    { "get_Type", (PyCFunction)IReferenceArray_get_Type, METH_NOARGS, nullptr },
    { "get_Value", (PyCFunction)IReferenceArray_get_Value, METH_NOARGS, nullptr },
    { nullptr }
};

static PyType_Slot IReferenceArray_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IReferenceArray_dealloc },
    { Py_tp_new, IReferenceArray_new },
    { Py_tp_methods, IReferenceArray_methods },
    { 0, nullptr },
};

static PyType_Spec IReferenceArray_Type_spec =
{
    "IReferenceArray",
    sizeof(py::winrt_pinterface_wrapper<pyIReferenceArray>),
    0,
    Py_TPFLAGS_DEFAULT,
    IReferenceArray_Type_slots
};

// ----- IReference interface --------------------
PyTypeObject* py::winrt_type<pyIReference>::python_type;


PyObject* IReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IReference interface is not activatable");
    return nullptr;
}

static void IReference_dealloc(py::winrt_pinterface_wrapper<pyIReference>* self)
{
    auto hash_value = self->obj->hash();
    py::wrapped_instance(hash_value, nullptr);
    self->obj.release();
}

static PyObject* IReference_GetBoolean(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetBoolean(args);
}

static PyObject* IReference_GetBooleanArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetBooleanArray(args);
}

static PyObject* IReference_GetChar16(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetChar16(args);
}

static PyObject* IReference_GetChar16Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetChar16Array(args);
}

static PyObject* IReference_GetDateTime(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetDateTime(args);
}

static PyObject* IReference_GetDateTimeArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetDateTimeArray(args);
}

static PyObject* IReference_GetDouble(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetDouble(args);
}

static PyObject* IReference_GetDoubleArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetDoubleArray(args);
}

static PyObject* IReference_GetGuid(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetGuid(args);
}

static PyObject* IReference_GetGuidArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetGuidArray(args);
}

static PyObject* IReference_GetInspectableArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetInspectableArray(args);
}

static PyObject* IReference_GetInt16(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetInt16(args);
}

static PyObject* IReference_GetInt16Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetInt16Array(args);
}

static PyObject* IReference_GetInt32(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetInt32(args);
}

static PyObject* IReference_GetInt32Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetInt32Array(args);
}

static PyObject* IReference_GetInt64(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetInt64(args);
}

static PyObject* IReference_GetInt64Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetInt64Array(args);
}

static PyObject* IReference_GetPoint(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetPoint(args);
}

static PyObject* IReference_GetPointArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetPointArray(args);
}

static PyObject* IReference_GetRect(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetRect(args);
}

static PyObject* IReference_GetRectArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetRectArray(args);
}

static PyObject* IReference_GetSingle(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetSingle(args);
}

static PyObject* IReference_GetSingleArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetSingleArray(args);
}

static PyObject* IReference_GetSize(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetSize(args);
}

static PyObject* IReference_GetSizeArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetSizeArray(args);
}

static PyObject* IReference_GetString(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetString(args);
}

static PyObject* IReference_GetStringArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetStringArray(args);
}

static PyObject* IReference_GetTimeSpan(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetTimeSpan(args);
}

static PyObject* IReference_GetTimeSpanArray(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetTimeSpanArray(args);
}

static PyObject* IReference_GetUInt16(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt16(args);
}

static PyObject* IReference_GetUInt16Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt16Array(args);
}

static PyObject* IReference_GetUInt32(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt32(args);
}

static PyObject* IReference_GetUInt32Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt32Array(args);
}

static PyObject* IReference_GetUInt64(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt64(args);
}

static PyObject* IReference_GetUInt64Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt64Array(args);
}

static PyObject* IReference_GetUInt8(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt8(args);
}

static PyObject* IReference_GetUInt8Array(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->GetUInt8Array(args);
}

static PyObject* IReference_get_IsNumericScalar(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->get_IsNumericScalar(args);
}

static PyObject* IReference_get_Type(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->get_Type(args);
}

static PyObject* IReference_get_Value(py::winrt_pinterface_wrapper<pyIReference>* self, PyObject* args)
{ 
    return self->obj->get_Value(args);
}

static PyMethodDef IReference_methods[] = {
    { "GetBoolean", (PyCFunction)IReference_GetBoolean, METH_VARARGS, nullptr },
    { "GetBooleanArray", (PyCFunction)IReference_GetBooleanArray, METH_VARARGS, nullptr },
    { "GetChar16", (PyCFunction)IReference_GetChar16, METH_VARARGS, nullptr },
    { "GetChar16Array", (PyCFunction)IReference_GetChar16Array, METH_VARARGS, nullptr },
    { "GetDateTime", (PyCFunction)IReference_GetDateTime, METH_VARARGS, nullptr },
    { "GetDateTimeArray", (PyCFunction)IReference_GetDateTimeArray, METH_VARARGS, nullptr },
    { "GetDouble", (PyCFunction)IReference_GetDouble, METH_VARARGS, nullptr },
    { "GetDoubleArray", (PyCFunction)IReference_GetDoubleArray, METH_VARARGS, nullptr },
    { "GetGuid", (PyCFunction)IReference_GetGuid, METH_VARARGS, nullptr },
    { "GetGuidArray", (PyCFunction)IReference_GetGuidArray, METH_VARARGS, nullptr },
    { "GetInspectableArray", (PyCFunction)IReference_GetInspectableArray, METH_VARARGS, nullptr },
    { "GetInt16", (PyCFunction)IReference_GetInt16, METH_VARARGS, nullptr },
    { "GetInt16Array", (PyCFunction)IReference_GetInt16Array, METH_VARARGS, nullptr },
    { "GetInt32", (PyCFunction)IReference_GetInt32, METH_VARARGS, nullptr },
    { "GetInt32Array", (PyCFunction)IReference_GetInt32Array, METH_VARARGS, nullptr },
    { "GetInt64", (PyCFunction)IReference_GetInt64, METH_VARARGS, nullptr },
    { "GetInt64Array", (PyCFunction)IReference_GetInt64Array, METH_VARARGS, nullptr },
    { "GetPoint", (PyCFunction)IReference_GetPoint, METH_VARARGS, nullptr },
    { "GetPointArray", (PyCFunction)IReference_GetPointArray, METH_VARARGS, nullptr },
    { "GetRect", (PyCFunction)IReference_GetRect, METH_VARARGS, nullptr },
    { "GetRectArray", (PyCFunction)IReference_GetRectArray, METH_VARARGS, nullptr },
    { "GetSingle", (PyCFunction)IReference_GetSingle, METH_VARARGS, nullptr },
    { "GetSingleArray", (PyCFunction)IReference_GetSingleArray, METH_VARARGS, nullptr },
    { "GetSize", (PyCFunction)IReference_GetSize, METH_VARARGS, nullptr },
    { "GetSizeArray", (PyCFunction)IReference_GetSizeArray, METH_VARARGS, nullptr },
    { "GetString", (PyCFunction)IReference_GetString, METH_VARARGS, nullptr },
    { "GetStringArray", (PyCFunction)IReference_GetStringArray, METH_VARARGS, nullptr },
    { "GetTimeSpan", (PyCFunction)IReference_GetTimeSpan, METH_VARARGS, nullptr },
    { "GetTimeSpanArray", (PyCFunction)IReference_GetTimeSpanArray, METH_VARARGS, nullptr },
    { "GetUInt16", (PyCFunction)IReference_GetUInt16, METH_VARARGS, nullptr },
    { "GetUInt16Array", (PyCFunction)IReference_GetUInt16Array, METH_VARARGS, nullptr },
    { "GetUInt32", (PyCFunction)IReference_GetUInt32, METH_VARARGS, nullptr },
    { "GetUInt32Array", (PyCFunction)IReference_GetUInt32Array, METH_VARARGS, nullptr },
    { "GetUInt64", (PyCFunction)IReference_GetUInt64, METH_VARARGS, nullptr },
    { "GetUInt64Array", (PyCFunction)IReference_GetUInt64Array, METH_VARARGS, nullptr },
    { "GetUInt8", (PyCFunction)IReference_GetUInt8, METH_VARARGS, nullptr },
    { "GetUInt8Array", (PyCFunction)IReference_GetUInt8Array, METH_VARARGS, nullptr },
    { "get_IsNumericScalar", (PyCFunction)IReference_get_IsNumericScalar, METH_NOARGS, nullptr },
    { "get_Type", (PyCFunction)IReference_get_Type, METH_NOARGS, nullptr },
    { "get_Value", (PyCFunction)IReference_get_Value, METH_NOARGS, nullptr },
    { nullptr }
};

static PyType_Slot IReference_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IReference_dealloc },
    { Py_tp_new, IReference_new },
    { Py_tp_methods, IReference_methods },
    { 0, nullptr },
};

static PyType_Spec IReference_Type_spec =
{
    "IReference",
    sizeof(py::winrt_pinterface_wrapper<pyIReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IReference_Type_slots
};

// ----- IStringable interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type;


PyObject* IStringable_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IStringable interface is not activatable");
    return nullptr;
}

static void IStringable_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStringable__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IStringable>::convert(instance.as<winrt::Windows::Foundation::IStringable>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IStringable_ToString(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.ToString();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IStringable_methods[] = {
    { "ToString", (PyCFunction)IStringable_ToString, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)IStringable__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IStringable_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStringable_dealloc },
    { Py_tp_new, IStringable_new },
    { Py_tp_methods, IStringable_methods },
    { 0, nullptr },
};

static PyType_Spec IStringable_Type_spec =
{
    "IStringable",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStringable_Type_slots
};

// ----- IWwwFormUrlDecoderEntry interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type;


PyObject* IWwwFormUrlDecoderEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IWwwFormUrlDecoderEntry interface is not activatable");
    return nullptr;
}

static void IWwwFormUrlDecoderEntry_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IWwwFormUrlDecoderEntry__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::convert(instance.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Name();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Value();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IWwwFormUrlDecoderEntry_methods[] = {
    { "get_Name", (PyCFunction)IWwwFormUrlDecoderEntry_get_Name, METH_NOARGS, nullptr },
    { "get_Value", (PyCFunction)IWwwFormUrlDecoderEntry_get_Value, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IWwwFormUrlDecoderEntry__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IWwwFormUrlDecoderEntry_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IWwwFormUrlDecoderEntry_dealloc },
    { Py_tp_new, IWwwFormUrlDecoderEntry_new },
    { Py_tp_methods, IWwwFormUrlDecoderEntry_methods },
    { 0, nullptr },
};

static PyType_Spec IWwwFormUrlDecoderEntry_Type_spec =
{
    "IWwwFormUrlDecoderEntry",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    IWwwFormUrlDecoderEntry_Type_slots
};

// ----- DateTime struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::DateTime>::convert(winrt::Windows::Foundation::DateTime instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::DateTime>(instance, py::get_python_type<winrt::Windows::Foundation::DateTime>());
}

winrt::Windows::Foundation::DateTime py::converter<winrt::Windows::Foundation::DateTime>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::DateTime>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::DateTime new_value{};
    PyObject* pyUniversalTime = PyDict_GetItemString(obj, "UniversalTime");
    if (!pyUniversalTime) { throw winrt::hresult_invalid_argument(); }
    new_value = winrt::Windows::Foundation::DateTime{ winrt::Windows::Foundation::TimeSpan { converter<int64_t>::convert_to(pyUniversalTime) } };
    return new_value;
}

PyObject* DateTime_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::DateTime instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::DateTime>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int64_t _UniversalTime{};
    static char* kwlist[] = {"UniversalTime", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", kwlist, &_UniversalTime))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::DateTime instance{ winrt::Windows::Foundation::TimeSpan{ _UniversalTime } };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DateTime_get_UniversalTime(py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.time_since_epoch().count())>::convert(self->obj.time_since_epoch().count());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DateTime_set_UniversalTime(py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj = winrt::Windows::Foundation::DateTime{ winrt::Windows::Foundation::TimeSpan{ py::converter<int64_t>::convert_to(value) } };
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef DateTime_getset[] = {
    { const_cast<char*>("UniversalTime"), (getter)DateTime_get_UniversalTime, (setter)DateTime_set_UniversalTime, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot DateTime_Type_slots[] = 
{
    { Py_tp_new, DateTime_new },
    { Py_tp_getset, DateTime_getset },
    { 0, nullptr },
};

static PyType_Spec DateTime_Type_spec =
{
    "DateTime",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>),
    0,
    Py_TPFLAGS_DEFAULT,
    DateTime_Type_slots
};

// ----- EventRegistrationToken struct --------------------
PyTypeObject* py::winrt_type<winrt::event_token>::python_type;

PyObject* py::converter<winrt::event_token>::convert(winrt::event_token instance) noexcept
{
    return py::wrap_struct<winrt::event_token>(instance, py::get_python_type<winrt::event_token>());
}

winrt::event_token py::converter<winrt::event_token>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::event_token>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::event_token>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::event_token new_value{};
    PyObject* pyValue = PyDict_GetItemString(obj, "Value");
    if (!pyValue) { throw winrt::hresult_invalid_argument(); }
    new_value.value = converter<int64_t>::convert_to(pyValue);
    return new_value;
}

PyObject* EventRegistrationToken_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::event_token instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::event_token>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int64_t _Value{};
    static char* kwlist[] = {"Value", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", kwlist, &_Value))
    {
        return nullptr;
    }
    
    try
    {
        winrt::event_token instance{ _Value };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* EventRegistrationToken_get_Value(py::winrt_struct_wrapper<winrt::event_token>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.value)>::convert(self->obj.value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int EventRegistrationToken_set_Value(py::winrt_struct_wrapper<winrt::event_token>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.value = py::converter<int64_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef EventRegistrationToken_getset[] = {
    { const_cast<char*>("Value"), (getter)EventRegistrationToken_get_Value, (setter)EventRegistrationToken_set_Value, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot EventRegistrationToken_Type_slots[] = 
{
    { Py_tp_new, EventRegistrationToken_new },
    { Py_tp_getset, EventRegistrationToken_getset },
    { 0, nullptr },
};

static PyType_Spec EventRegistrationToken_Type_spec =
{
    "EventRegistrationToken",
    sizeof(py::winrt_struct_wrapper<winrt::event_token>),
    0,
    Py_TPFLAGS_DEFAULT,
    EventRegistrationToken_Type_slots
};

// ----- HResult struct --------------------
PyTypeObject* py::winrt_type<winrt::hresult>::python_type;

PyObject* py::converter<winrt::hresult>::convert(winrt::hresult instance) noexcept
{
    return py::wrap_struct<winrt::hresult>(instance, py::get_python_type<winrt::hresult>());
}

winrt::hresult py::converter<winrt::hresult>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::hresult>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::hresult>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::hresult new_value{};
    PyObject* pyValue = PyDict_GetItemString(obj, "Value");
    if (!pyValue) { throw winrt::hresult_invalid_argument(); }
    new_value = converter<int32_t>::convert_to(pyValue);
    return new_value;
}

PyObject* HResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::hresult instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::hresult>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int32_t _Value{};
    static char* kwlist[] = {"Value", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", kwlist, &_Value))
    {
        return nullptr;
    }
    
    try
    {
        winrt::hresult instance{ _Value };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* HResult_get_Value(py::winrt_struct_wrapper<winrt::hresult>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj)>::convert(self->obj);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int HResult_set_Value(py::winrt_struct_wrapper<winrt::hresult>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj = py::converter<int32_t>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef HResult_getset[] = {
    { const_cast<char*>("Value"), (getter)HResult_get_Value, (setter)HResult_set_Value, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot HResult_Type_slots[] = 
{
    { Py_tp_new, HResult_new },
    { Py_tp_getset, HResult_getset },
    { 0, nullptr },
};

static PyType_Spec HResult_Type_spec =
{
    "HResult",
    sizeof(py::winrt_struct_wrapper<winrt::hresult>),
    0,
    Py_TPFLAGS_DEFAULT,
    HResult_Type_slots
};

// ----- Point struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Point>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Point>::convert(winrt::Windows::Foundation::Point instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Point>(instance, py::get_python_type<winrt::Windows::Foundation::Point>());
}

winrt::Windows::Foundation::Point py::converter<winrt::Windows::Foundation::Point>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Point>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Point new_value{};
    PyObject* pyX = PyDict_GetItemString(obj, "X");
    if (!pyX) { throw winrt::hresult_invalid_argument(); }
    new_value.X = converter<float>::convert_to(pyX);
    PyObject* pyY = PyDict_GetItemString(obj, "Y");
    if (!pyY) { throw winrt::hresult_invalid_argument(); }
    new_value.Y = converter<float>::convert_to(pyY);
    return new_value;
}

PyObject* Point_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Point instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Point>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    float _X{};
    float _Y{};
    static char* kwlist[] = {"X", "Y", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", kwlist, &_X, &_Y))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Point instance{ _X, _Y };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Point_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.X)>::convert(self->obj.X);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Point_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.X = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Point_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Y)>::convert(self->obj.Y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Point_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Y = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Point_getset[] = {
    { const_cast<char*>("X"), (getter)Point_get_X, (setter)Point_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Point_get_Y, (setter)Point_set_Y, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Point_Type_slots[] = 
{
    { Py_tp_new, Point_new },
    { Py_tp_getset, Point_getset },
    { 0, nullptr },
};

static PyType_Spec Point_Type_spec =
{
    "Point",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>),
    0,
    Py_TPFLAGS_DEFAULT,
    Point_Type_slots
};

// ----- Rect struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Rect>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Rect>::convert(winrt::Windows::Foundation::Rect instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Rect>(instance, py::get_python_type<winrt::Windows::Foundation::Rect>());
}

winrt::Windows::Foundation::Rect py::converter<winrt::Windows::Foundation::Rect>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Rect>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Rect new_value{};
    PyObject* pyX = PyDict_GetItemString(obj, "X");
    if (!pyX) { throw winrt::hresult_invalid_argument(); }
    new_value.X = converter<float>::convert_to(pyX);
    PyObject* pyY = PyDict_GetItemString(obj, "Y");
    if (!pyY) { throw winrt::hresult_invalid_argument(); }
    new_value.Y = converter<float>::convert_to(pyY);
    PyObject* pyWidth = PyDict_GetItemString(obj, "Width");
    if (!pyWidth) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<float>::convert_to(pyWidth);
    PyObject* pyHeight = PyDict_GetItemString(obj, "Height");
    if (!pyHeight) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<float>::convert_to(pyHeight);
    return new_value;
}

PyObject* Rect_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Rect instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Rect>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    float _X{};
    float _Y{};
    float _Width{};
    float _Height{};
    static char* kwlist[] = {"X", "Y", "Width", "Height", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", kwlist, &_X, &_Y, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Rect instance{ _X, _Y, _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Rect_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.X)>::convert(self->obj.X);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.X = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Rect_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Y)>::convert(self->obj.Y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Y = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Rect_get_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Width)>::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Rect_get_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Height)>::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Rect_getset[] = {
    { const_cast<char*>("X"), (getter)Rect_get_X, (setter)Rect_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Rect_get_Y, (setter)Rect_set_Y, nullptr, nullptr },
    { const_cast<char*>("Width"), (getter)Rect_get_Width, (setter)Rect_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)Rect_get_Height, (setter)Rect_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Rect_Type_slots[] = 
{
    { Py_tp_new, Rect_new },
    { Py_tp_getset, Rect_getset },
    { 0, nullptr },
};

static PyType_Spec Rect_Type_spec =
{
    "Rect",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>),
    0,
    Py_TPFLAGS_DEFAULT,
    Rect_Type_slots
};

// ----- Size struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Size>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Size>::convert(winrt::Windows::Foundation::Size instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::Size>(instance, py::get_python_type<winrt::Windows::Foundation::Size>());
}

winrt::Windows::Foundation::Size py::converter<winrt::Windows::Foundation::Size>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Size>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::Size new_value{};
    PyObject* pyWidth = PyDict_GetItemString(obj, "Width");
    if (!pyWidth) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<float>::convert_to(pyWidth);
    PyObject* pyHeight = PyDict_GetItemString(obj, "Height");
    if (!pyHeight) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<float>::convert_to(pyHeight);
    return new_value;
}

PyObject* Size_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Size instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Size>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    float _Width{};
    float _Height{};
    static char* kwlist[] = {"Width", "Height", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", kwlist, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Size instance{ _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Size_get_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Width)>::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Size_set_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Size_get_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Height)>::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Size_set_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::converter<float>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Size_getset[] = {
    { const_cast<char*>("Width"), (getter)Size_get_Width, (setter)Size_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)Size_get_Height, (setter)Size_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Size_Type_slots[] = 
{
    { Py_tp_new, Size_new },
    { Py_tp_getset, Size_getset },
    { 0, nullptr },
};

static PyType_Spec Size_Type_spec =
{
    "Size",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>),
    0,
    Py_TPFLAGS_DEFAULT,
    Size_Type_slots
};

// ----- TimeSpan struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::TimeSpan>::convert(winrt::Windows::Foundation::TimeSpan instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Foundation::TimeSpan>(instance, py::get_python_type<winrt::Windows::Foundation::TimeSpan>());
}

winrt::Windows::Foundation::TimeSpan py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::TimeSpan>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Foundation::TimeSpan new_value{};
    PyObject* pyDuration = PyDict_GetItemString(obj, "Duration");
    if (!pyDuration) { throw winrt::hresult_invalid_argument(); }
    new_value = winrt::Windows::Foundation::TimeSpan { converter<int64_t>::convert_to(pyDuration) };
    return new_value;
}

PyObject* TimeSpan_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::TimeSpan instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int64_t _Duration{};
    static char* kwlist[] = {"Duration", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", kwlist, &_Duration))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::TimeSpan instance{ _Duration };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TimeSpan_get_Duration(py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.count())>::convert(self->obj.count());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int TimeSpan_set_Duration(py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj = winrt::Windows::Foundation::TimeSpan{ py::converter<int64_t>::convert_to(value) };
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef TimeSpan_getset[] = {
    { const_cast<char*>("Duration"), (getter)TimeSpan_get_Duration, (setter)TimeSpan_set_Duration, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TimeSpan_Type_slots[] = 
{
    { Py_tp_new, TimeSpan_new },
    { Py_tp_getset, TimeSpan_getset },
    { 0, nullptr },
};

static PyType_Spec TimeSpan_Type_spec =
{
    "TimeSpan",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>),
    0,
    Py_TPFLAGS_DEFAULT,
    TimeSpan_Type_slots
};

// ----- Windows.Foundation Initialization --------------------

int initialize_Windows_Foundation(PyObject* module)
{
    PyObject* type_object{ nullptr };


    Deferral_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Deferral_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Deferral", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Deferral>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&GuidHelper_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GuidHelper", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    MemoryBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&MemoryBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MemoryBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&PropertyValue_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PropertyValue", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::PropertyValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Uri_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Uri_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Uri", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Uri>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    WwwFormUrlDecoder_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&WwwFormUrlDecoder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "WwwFormUrlDecoder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    WwwFormUrlDecoderEntry_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&WwwFormUrlDecoderEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "WwwFormUrlDecoderEntry", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncAction_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncAction_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncAction", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncActionWithProgress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncActionWithProgress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncActionWithProgress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncActionWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncInfo_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncInfo_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncInfo", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncOperationWithProgress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncOperationWithProgress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncOperationWithProgress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncOperationWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncOperation_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncOperation_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncOperation", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncOperation>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IClosable_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IClosable_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IClosable", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IGetActivationFactory_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IGetActivationFactory_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IGetActivationFactory", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IMemoryBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IMemoryBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMemoryBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IMemoryBufferReference_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IMemoryBufferReference_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMemoryBufferReference", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IPropertyValue_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IPropertyValue_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IPropertyValue", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IPropertyValue>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IReferenceArray_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IReferenceArray_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IReferenceArray", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIReferenceArray>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IReference_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IReference_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IReference", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStringable_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStringable_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStringable", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IWwwFormUrlDecoderEntry_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IWwwFormUrlDecoderEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IWwwFormUrlDecoderEntry", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&DateTime_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "DateTime", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&EventRegistrationToken_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "EventRegistrationToken", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::event_token>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&HResult_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "HResult", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::hresult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&Point_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Point", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Point>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&Rect_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Rect", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Rect>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&Size_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Size", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Size>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&TimeSpan_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TimeSpan", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
