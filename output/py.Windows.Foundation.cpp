// WARNING: Please don't edit this file. It was generated by Python/WinRT

#if __has_include("py.Windows.Foundation.h")
#include "py.Windows.Foundation.h"
#endif

// ----- GuidHelper class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type;

PyObject* GuidHelper_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GuidHelper is not activatable");
    return nullptr;
}

static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = winrt::Windows::Foundation::GuidHelper::CreateNewGuid();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);

            bool return_value = winrt::Windows::Foundation::GuidHelper::Equals(param0, param1);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GuidHelper_Empty(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = winrt::Windows::Foundation::GuidHelper::Empty();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef GuidHelper_methods[] = {
    { "CreateNewGuid", (PyCFunction)GuidHelper_CreateNewGuid, METH_VARARGS | METH_STATIC, nullptr },
    { "Equals", (PyCFunction)GuidHelper_Equals, METH_VARARGS | METH_STATIC, nullptr },
    { "Empty", (PyCFunction)GuidHelper_Empty, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GuidHelper_Type_slots[] = 
{
    { Py_tp_new, GuidHelper_new },
    { Py_tp_methods, GuidHelper_methods },
    { 0, nullptr },
};

static PyType_Spec GuidHelper_Type_spec =
{
    "GuidHelper",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    GuidHelper_Type_slots
};

// ----- MemoryBuffer class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type;

PyObject* MemoryBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            winrt::Windows::Foundation::MemoryBuffer instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void MemoryBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MemoryBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IMemoryBufferReference return_value = self->obj.CreateReference();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* MemoryBuffer_Close(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef MemoryBuffer_methods[] = {
    { "CreateReference", (PyCFunction)MemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)MemoryBuffer_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot MemoryBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, MemoryBuffer_dealloc },
    { Py_tp_new, MemoryBuffer_new },
    { Py_tp_methods, MemoryBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec MemoryBuffer_Type_spec =
{
    "MemoryBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    MemoryBuffer_Type_slots
};

// ----- Uri class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Uri>::python_type;

PyObject* Uri_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Foundation::Uri instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            winrt::Windows::Foundation::Uri instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void Uri_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Uri_Equals(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

            bool return_value = self->obj.Equals(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_CombineUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::Uri return_value = self->obj.CombineUri(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_ToString(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.ToString();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = winrt::Windows::Foundation::Uri::UnescapeComponent(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = winrt::Windows::Foundation::Uri::EscapeComponent(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_get_AbsoluteUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AbsoluteUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_DisplayUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Domain(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Domain();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Extension(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Extension();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Fragment(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Fragment();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Host(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Host();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Password(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Password();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Path(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Port(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Port();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Query(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Query();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_QueryParsed(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.QueryParsed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_RawUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RawUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_SchemeName(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SchemeName();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Suspicious(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Suspicious();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_UserName(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UserName();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_AbsoluteCanonicalUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AbsoluteCanonicalUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_DisplayIri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayIri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Uri_methods[] = {
    { "Equals", (PyCFunction)Uri_Equals, METH_VARARGS, nullptr },
    { "CombineUri", (PyCFunction)Uri_CombineUri, METH_VARARGS, nullptr },
    { "ToString", (PyCFunction)Uri_ToString, METH_VARARGS, nullptr },
    { "UnescapeComponent", (PyCFunction)Uri_UnescapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { "EscapeComponent", (PyCFunction)Uri_EscapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Uri_getset[] = {
    { const_cast<char*>("AbsoluteUri"), (getter)Uri_get_AbsoluteUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayUri"), (getter)Uri_get_DisplayUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("Domain"), (getter)Uri_get_Domain, nullptr, nullptr, nullptr },
    { const_cast<char*>("Extension"), (getter)Uri_get_Extension, nullptr, nullptr, nullptr },
    { const_cast<char*>("Fragment"), (getter)Uri_get_Fragment, nullptr, nullptr, nullptr },
    { const_cast<char*>("Host"), (getter)Uri_get_Host, nullptr, nullptr, nullptr },
    { const_cast<char*>("Password"), (getter)Uri_get_Password, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)Uri_get_Path, nullptr, nullptr, nullptr },
    { const_cast<char*>("Port"), (getter)Uri_get_Port, nullptr, nullptr, nullptr },
    { const_cast<char*>("Query"), (getter)Uri_get_Query, nullptr, nullptr, nullptr },
    { const_cast<char*>("QueryParsed"), (getter)Uri_get_QueryParsed, nullptr, nullptr, nullptr },
    { const_cast<char*>("RawUri"), (getter)Uri_get_RawUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("SchemeName"), (getter)Uri_get_SchemeName, nullptr, nullptr, nullptr },
    { const_cast<char*>("Suspicious"), (getter)Uri_get_Suspicious, nullptr, nullptr, nullptr },
    { const_cast<char*>("UserName"), (getter)Uri_get_UserName, nullptr, nullptr, nullptr },
    { const_cast<char*>("AbsoluteCanonicalUri"), (getter)Uri_get_AbsoluteCanonicalUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayIri"), (getter)Uri_get_DisplayIri, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Uri_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Uri_dealloc },
    { Py_tp_new, Uri_new },
    { Py_tp_methods, Uri_methods },
    { Py_tp_getset, Uri_getset },
    { 0, nullptr },
};

static PyType_Spec Uri_Type_spec =
{
    "Uri",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::Uri>),
    0,
    Py_TPFLAGS_DEFAULT,
    Uri_Type_slots
};

// ----- WwwFormUrlDecoder class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type;

PyObject* WwwFormUrlDecoder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Foundation::WwwFormUrlDecoder instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void WwwFormUrlDecoder_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = self->obj.GetFirstValueByName(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_First(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> return_value = self->obj.First();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetAt(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Foundation::IWwwFormUrlDecoderEntry return_value = self->obj.GetAt(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_IndexOf(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
            uint32_t param1 {  };

            bool return_value = self->obj.IndexOf(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetMany(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*r*/ winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> param1 { };

            uint32_t return_value = self->obj.GetMany(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_get_Size(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef WwwFormUrlDecoder_methods[] = {
    { "GetFirstValueByName", (PyCFunction)WwwFormUrlDecoder_GetFirstValueByName, METH_VARARGS, nullptr },
    { "First", (PyCFunction)WwwFormUrlDecoder_First, METH_VARARGS, nullptr },
    { "GetAt", (PyCFunction)WwwFormUrlDecoder_GetAt, METH_VARARGS, nullptr },
    { "IndexOf", (PyCFunction)WwwFormUrlDecoder_IndexOf, METH_VARARGS, nullptr },
    { "GetMany", (PyCFunction)WwwFormUrlDecoder_GetMany, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef WwwFormUrlDecoder_getset[] = {
    { const_cast<char*>("Size"), (getter)WwwFormUrlDecoder_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot WwwFormUrlDecoder_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, WwwFormUrlDecoder_dealloc },
    { Py_tp_new, WwwFormUrlDecoder_new },
    { Py_tp_methods, WwwFormUrlDecoder_methods },
    { Py_tp_getset, WwwFormUrlDecoder_getset },
    { 0, nullptr },
};

static PyType_Spec WwwFormUrlDecoder_Type_spec =
{
    "WwwFormUrlDecoder",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>),
    0,
    Py_TPFLAGS_DEFAULT,
    WwwFormUrlDecoder_Type_slots
};

// ----- WwwFormUrlDecoderEntry class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type;

PyObject* WwwFormUrlDecoderEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "WwwFormUrlDecoderEntry is not activatable");
    return nullptr;
}

static void WwwFormUrlDecoderEntry_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoderEntry_get_Name(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* WwwFormUrlDecoderEntry_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Value();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef WwwFormUrlDecoderEntry_getset[] = {
    { const_cast<char*>("Name"), (getter)WwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Value"), (getter)WwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot WwwFormUrlDecoderEntry_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, WwwFormUrlDecoderEntry_dealloc },
    { Py_tp_new, WwwFormUrlDecoderEntry_new },
    { Py_tp_getset, WwwFormUrlDecoderEntry_getset },
    { 0, nullptr },
};

static PyType_Spec WwwFormUrlDecoderEntry_Type_spec =
{
    "WwwFormUrlDecoderEntry",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    WwwFormUrlDecoderEntry_Type_slots
};

// ----- IAsyncAction interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type;

PyObject* IAsyncAction_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IAsyncAction_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncAction_GetResults(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.GetResults();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncAction_get_Completed(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Completed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IAsyncAction_put_Completed(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(value);
        self->obj.Completed(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyMethodDef IAsyncAction_methods[] = {
    { "GetResults", (PyCFunction)IAsyncAction_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncAction_getset[] = {
    { const_cast<char*>("Completed"), (getter)IAsyncAction_get_Completed, (setter)IAsyncAction_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncAction_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncAction_dealloc },
    { Py_tp_new, IAsyncAction_new },
    { Py_tp_methods, IAsyncAction_methods },
    { Py_tp_getset, IAsyncAction_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncAction_Type_spec =
{
    "IAsyncAction",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncAction_Type_slots
};

// ----- IAsyncActionWithProgress parameterized interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncActionWithProgress>::python_type;

PyObject* IAsyncActionWithProgress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    // TODO implement QI in this pinterface constructor
    PyErr_SetString(PyExc_RuntimeError, "IAsyncActionWithProgress is not activatable");
    return nullptr;
}

static void IAsyncActionWithProgress_dealloc(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self)
{
    py::wrapped_instance(self->obj->hash(), nullptr);
    self->obj.release();
}

static PyObject* IAsyncActionWithProgress_GetResults(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncActionWithProgress_get_Progress(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Progress();
}

static int IAsyncActionWithProgress_put_Progress(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Progress(value);
}

static PyObject* IAsyncActionWithProgress_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncActionWithProgress_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Completed(value);
}

static PyMethodDef IAsyncActionWithProgress_methods[] = {
    { "GetResults", (PyCFunction)IAsyncActionWithProgress_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncActionWithProgress_getset[] = {
    { const_cast<char*>("Progress"), (getter)IAsyncActionWithProgress_get_Progress, (setter)IAsyncActionWithProgress_put_Progress, nullptr, nullptr },
    { const_cast<char*>("Completed"), (getter)IAsyncActionWithProgress_get_Completed, (setter)IAsyncActionWithProgress_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncActionWithProgress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncActionWithProgress_dealloc },
    { Py_tp_new, IAsyncActionWithProgress_new },
    { Py_tp_methods, IAsyncActionWithProgress_methods },
    { Py_tp_getset, IAsyncActionWithProgress_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncActionWithProgress_Type_spec =
{
    "IAsyncActionWithProgress",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncActionWithProgress_Type_slots
};

// ----- IAsyncInfo interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type;

PyObject* IAsyncInfo_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncInfo>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IAsyncInfo_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncInfo_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncInfo_Close(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncInfo_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ErrorCode();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IAsyncInfo_get_Id(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IAsyncInfo_get_Status(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Status();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IAsyncInfo_methods[] = {
    { "Cancel", (PyCFunction)IAsyncInfo_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IAsyncInfo_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncInfo_getset[] = {
    { const_cast<char*>("ErrorCode"), (getter)IAsyncInfo_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("Id"), (getter)IAsyncInfo_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("Status"), (getter)IAsyncInfo_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncInfo_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncInfo_dealloc },
    { Py_tp_new, IAsyncInfo_new },
    { Py_tp_methods, IAsyncInfo_methods },
    { Py_tp_getset, IAsyncInfo_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncInfo_Type_spec =
{
    "IAsyncInfo",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncInfo_Type_slots
};

// ----- IAsyncOperationWithProgress parameterized interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncOperationWithProgress>::python_type;

PyObject* IAsyncOperationWithProgress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    // TODO implement QI in this pinterface constructor
    PyErr_SetString(PyExc_RuntimeError, "IAsyncOperationWithProgress is not activatable");
    return nullptr;
}

static void IAsyncOperationWithProgress_dealloc(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self)
{
    py::wrapped_instance(self->obj->hash(), nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperationWithProgress_GetResults(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperationWithProgress_get_Progress(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Progress();
}

static int IAsyncOperationWithProgress_put_Progress(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Progress(value);
}

static PyObject* IAsyncOperationWithProgress_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncOperationWithProgress_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Completed(value);
}

static PyMethodDef IAsyncOperationWithProgress_methods[] = {
    { "GetResults", (PyCFunction)IAsyncOperationWithProgress_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncOperationWithProgress_getset[] = {
    { const_cast<char*>("Progress"), (getter)IAsyncOperationWithProgress_get_Progress, (setter)IAsyncOperationWithProgress_put_Progress, nullptr, nullptr },
    { const_cast<char*>("Completed"), (getter)IAsyncOperationWithProgress_get_Completed, (setter)IAsyncOperationWithProgress_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncOperationWithProgress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncOperationWithProgress_dealloc },
    { Py_tp_new, IAsyncOperationWithProgress_new },
    { Py_tp_methods, IAsyncOperationWithProgress_methods },
    { Py_tp_getset, IAsyncOperationWithProgress_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncOperationWithProgress_Type_spec =
{
    "IAsyncOperationWithProgress",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncOperationWithProgress_Type_slots
};

// ----- IAsyncOperation parameterized interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncOperation>::python_type;

PyObject* IAsyncOperation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    // TODO implement QI in this pinterface constructor
    PyErr_SetString(PyExc_RuntimeError, "IAsyncOperation is not activatable");
    return nullptr;
}

static void IAsyncOperation_dealloc(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self)
{
    py::wrapped_instance(self->obj->hash(), nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperation_GetResults(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperation_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncOperation_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Completed(value);
}

static PyMethodDef IAsyncOperation_methods[] = {
    { "GetResults", (PyCFunction)IAsyncOperation_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncOperation_getset[] = {
    { const_cast<char*>("Completed"), (getter)IAsyncOperation_get_Completed, (setter)IAsyncOperation_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncOperation_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IAsyncOperation_dealloc },
    { Py_tp_new, IAsyncOperation_new },
    { Py_tp_methods, IAsyncOperation_methods },
    { Py_tp_getset, IAsyncOperation_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncOperation_Type_spec =
{
    "IAsyncOperation",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncOperation>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncOperation_Type_slots
};

// ----- IClosable interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type;

PyObject* IClosable_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IClosable>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IClosable_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IClosable_Close(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IClosable_methods[] = {
    { "Close", (PyCFunction)IClosable_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IClosable_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IClosable_dealloc },
    { Py_tp_new, IClosable_new },
    { Py_tp_methods, IClosable_methods },
    { 0, nullptr },
};

static PyType_Spec IClosable_Type_spec =
{
    "IClosable",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>),
    0,
    Py_TPFLAGS_DEFAULT,
    IClosable_Type_slots
};

// ----- IGetActivationFactory interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type;

PyObject* IGetActivationFactory_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IGetActivationFactory>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IGetActivationFactory_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGetActivationFactory_GetActivationFactory(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = self->obj.GetActivationFactory(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IGetActivationFactory_methods[] = {
    { "GetActivationFactory", (PyCFunction)IGetActivationFactory_GetActivationFactory, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IGetActivationFactory_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IGetActivationFactory_dealloc },
    { Py_tp_new, IGetActivationFactory_new },
    { Py_tp_methods, IGetActivationFactory_methods },
    { 0, nullptr },
};

static PyType_Spec IGetActivationFactory_Type_spec =
{
    "IGetActivationFactory",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>),
    0,
    Py_TPFLAGS_DEFAULT,
    IGetActivationFactory_Type_slots
};

// ----- IMemoryBuffer interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type;

PyObject* IMemoryBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBuffer>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IMemoryBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IMemoryBufferReference return_value = self->obj.CreateReference();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IMemoryBuffer_methods[] = {
    { "CreateReference", (PyCFunction)IMemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IMemoryBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IMemoryBuffer_dealloc },
    { Py_tp_new, IMemoryBuffer_new },
    { Py_tp_methods, IMemoryBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec IMemoryBuffer_Type_spec =
{
    "IMemoryBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMemoryBuffer_Type_slots
};

// ----- IMemoryBufferReference interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type;

PyObject* IMemoryBufferReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBufferReference>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IMemoryBufferReference_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBufferReference_get_Capacity(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Capacity();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef IMemoryBufferReference_getset[] = {
    { const_cast<char*>("Capacity"), (getter)IMemoryBufferReference_get_Capacity, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IMemoryBufferReference_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IMemoryBufferReference_dealloc },
    { Py_tp_new, IMemoryBufferReference_new },
    { Py_tp_getset, IMemoryBufferReference_getset },
    { 0, nullptr },
};

static PyType_Spec IMemoryBufferReference_Type_spec =
{
    "IMemoryBufferReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMemoryBufferReference_Type_slots
};

// ----- IStringable interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type;

PyObject* IStringable_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IStringable>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IStringable_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStringable_ToString(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.ToString();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IStringable_methods[] = {
    { "ToString", (PyCFunction)IStringable_ToString, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IStringable_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IStringable_dealloc },
    { Py_tp_new, IStringable_new },
    { Py_tp_methods, IStringable_methods },
    { 0, nullptr },
};

static PyType_Spec IStringable_Type_spec =
{
    "IStringable",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStringable_Type_slots
};

// ----- IWwwFormUrlDecoderEntry interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type;

PyObject* IWwwFormUrlDecoderEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IWwwFormUrlDecoderEntry_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Value();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef IWwwFormUrlDecoderEntry_getset[] = {
    { const_cast<char*>("Name"), (getter)IWwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Value"), (getter)IWwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IWwwFormUrlDecoderEntry_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IWwwFormUrlDecoderEntry_dealloc },
    { Py_tp_new, IWwwFormUrlDecoderEntry_new },
    { Py_tp_getset, IWwwFormUrlDecoderEntry_getset },
    { 0, nullptr },
};

static PyType_Spec IWwwFormUrlDecoderEntry_Type_spec =
{
    "IWwwFormUrlDecoderEntry",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    IWwwFormUrlDecoderEntry_Type_slots
};

// ----- DateTime struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type;

winrt::Windows::Foundation::DateTime py::converter<winrt::Windows::Foundation::DateTime>::convert_to(PyObject* obj)
{
    if (!PyDict_Check(obj)) { throw winrt::hresult_invalid_argument(); }
    
    winrt::Windows::Foundation::DateTime new_value{};
    PyObject* pyUniversalTime = PyDict_GetItemString(obj, "UniversalTime");
    if (!pyUniversalTime) { throw winrt::hresult_invalid_argument(); }
    new_value = winrt::Windows::Foundation::DateTime{ winrt::Windows::Foundation::TimeSpan { converter<int64_t>::convert_to(pyUniversalTime) } };
    return new_value;
}

PyObject* DateTime_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::DateTime instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::DateTime>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int64_t _UniversalTime{};
    static char* kwlist[] = {"UniversalTime", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", kwlist, &_UniversalTime))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::DateTime instance{ winrt::Windows::Foundation::TimeSpan{ _UniversalTime } };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* DateTime_get_UniversalTime(py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.time_since_epoch().count());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int DateTime_set_UniversalTime(py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj = winrt::Windows::Foundation::DateTime{ winrt::Windows::Foundation::TimeSpan{ py::convert_to<int64_t>(value) } };
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef DateTime_getset[] = {
    { const_cast<char*>("UniversalTime"), (getter)DateTime_get_UniversalTime, (setter)DateTime_set_UniversalTime, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot DateTime_Type_slots[] = 
{
    { Py_tp_new, DateTime_new },
    { Py_tp_getset, DateTime_getset },
    { 0, nullptr },
};

static PyType_Spec DateTime_Type_spec =
{
    "DateTime",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>),
    0,
    Py_TPFLAGS_DEFAULT,
    DateTime_Type_slots
};

// ----- EventRegistrationToken struct --------------------
PyTypeObject* py::winrt_type<winrt::event_token>::python_type;

winrt::event_token py::converter<winrt::event_token>::convert_to(PyObject* obj)
{
    if (!PyDict_Check(obj)) { throw winrt::hresult_invalid_argument(); }
    
    winrt::event_token new_value{};
    PyObject* pyValue = PyDict_GetItemString(obj, "Value");
    if (!pyValue) { throw winrt::hresult_invalid_argument(); }
    new_value.value = converter<int64_t>::convert_to(pyValue);
    return new_value;
}

PyObject* EventRegistrationToken_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::event_token instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::event_token>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int64_t _Value{};
    static char* kwlist[] = {"Value", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", kwlist, &_Value))
    {
        return nullptr;
    }
    
    try
    {
        winrt::event_token instance{ _Value };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* EventRegistrationToken_get_Value(py::winrt_struct_wrapper<winrt::event_token>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int EventRegistrationToken_set_Value(py::winrt_struct_wrapper<winrt::event_token>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.value = py::convert_to<int64_t>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef EventRegistrationToken_getset[] = {
    { const_cast<char*>("Value"), (getter)EventRegistrationToken_get_Value, (setter)EventRegistrationToken_set_Value, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot EventRegistrationToken_Type_slots[] = 
{
    { Py_tp_new, EventRegistrationToken_new },
    { Py_tp_getset, EventRegistrationToken_getset },
    { 0, nullptr },
};

static PyType_Spec EventRegistrationToken_Type_spec =
{
    "EventRegistrationToken",
    sizeof(py::winrt_struct_wrapper<winrt::event_token>),
    0,
    Py_TPFLAGS_DEFAULT,
    EventRegistrationToken_Type_slots
};

// ----- HResult struct --------------------
PyTypeObject* py::winrt_type<winrt::hresult>::python_type;

winrt::hresult py::converter<winrt::hresult>::convert_to(PyObject* obj)
{
    if (!PyDict_Check(obj)) { throw winrt::hresult_invalid_argument(); }
    
    winrt::hresult new_value{};
    PyObject* pyValue = PyDict_GetItemString(obj, "Value");
    if (!pyValue) { throw winrt::hresult_invalid_argument(); }
    new_value = converter<int32_t>::convert_to(pyValue);
    return new_value;
}

PyObject* HResult_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::hresult instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::hresult>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int32_t _Value{};
    static char* kwlist[] = {"Value", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", kwlist, &_Value))
    {
        return nullptr;
    }
    
    try
    {
        winrt::hresult instance{ _Value };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* HResult_get_Value(py::winrt_struct_wrapper<winrt::hresult>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int HResult_set_Value(py::winrt_struct_wrapper<winrt::hresult>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj = py::convert_to<int32_t>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef HResult_getset[] = {
    { const_cast<char*>("Value"), (getter)HResult_get_Value, (setter)HResult_set_Value, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot HResult_Type_slots[] = 
{
    { Py_tp_new, HResult_new },
    { Py_tp_getset, HResult_getset },
    { 0, nullptr },
};

static PyType_Spec HResult_Type_spec =
{
    "HResult",
    sizeof(py::winrt_struct_wrapper<winrt::hresult>),
    0,
    Py_TPFLAGS_DEFAULT,
    HResult_Type_slots
};

// ----- Point struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Point>::python_type;

winrt::Windows::Foundation::Point py::converter<winrt::Windows::Foundation::Point>::convert_to(PyObject* obj)
{
    if (!PyDict_Check(obj)) { throw winrt::hresult_invalid_argument(); }
    
    winrt::Windows::Foundation::Point new_value{};
    PyObject* pyX = PyDict_GetItemString(obj, "X");
    if (!pyX) { throw winrt::hresult_invalid_argument(); }
    new_value.X = converter<float>::convert_to(pyX);
    PyObject* pyY = PyDict_GetItemString(obj, "Y");
    if (!pyY) { throw winrt::hresult_invalid_argument(); }
    new_value.Y = converter<float>::convert_to(pyY);
    return new_value;
}

PyObject* Point_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Point instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Point>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    float _X{};
    float _Y{};
    static char* kwlist[] = {"X", "Y", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", kwlist, &_X, &_Y))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Point instance{ _X, _Y };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Point_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.X);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Point_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.X = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Point_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Point_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Y = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Point_getset[] = {
    { const_cast<char*>("X"), (getter)Point_get_X, (setter)Point_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Point_get_Y, (setter)Point_set_Y, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Point_Type_slots[] = 
{
    { Py_tp_new, Point_new },
    { Py_tp_getset, Point_getset },
    { 0, nullptr },
};

static PyType_Spec Point_Type_spec =
{
    "Point",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>),
    0,
    Py_TPFLAGS_DEFAULT,
    Point_Type_slots
};

// ----- Rect struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Rect>::python_type;

winrt::Windows::Foundation::Rect py::converter<winrt::Windows::Foundation::Rect>::convert_to(PyObject* obj)
{
    if (!PyDict_Check(obj)) { throw winrt::hresult_invalid_argument(); }
    
    winrt::Windows::Foundation::Rect new_value{};
    PyObject* pyX = PyDict_GetItemString(obj, "X");
    if (!pyX) { throw winrt::hresult_invalid_argument(); }
    new_value.X = converter<float>::convert_to(pyX);
    PyObject* pyY = PyDict_GetItemString(obj, "Y");
    if (!pyY) { throw winrt::hresult_invalid_argument(); }
    new_value.Y = converter<float>::convert_to(pyY);
    PyObject* pyWidth = PyDict_GetItemString(obj, "Width");
    if (!pyWidth) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<float>::convert_to(pyWidth);
    PyObject* pyHeight = PyDict_GetItemString(obj, "Height");
    if (!pyHeight) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<float>::convert_to(pyHeight);
    return new_value;
}

PyObject* Rect_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Rect instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Rect>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    float _X{};
    float _Y{};
    float _Width{};
    float _Height{};
    static char* kwlist[] = {"X", "Y", "Width", "Height", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", kwlist, &_X, &_Y, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Rect instance{ _X, _Y, _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Rect_get_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.X);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_X(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.X = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Rect_get_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Y);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_Y(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Y = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Rect_get_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Rect_get_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Rect_set_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Rect_getset[] = {
    { const_cast<char*>("X"), (getter)Rect_get_X, (setter)Rect_set_X, nullptr, nullptr },
    { const_cast<char*>("Y"), (getter)Rect_get_Y, (setter)Rect_set_Y, nullptr, nullptr },
    { const_cast<char*>("Width"), (getter)Rect_get_Width, (setter)Rect_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)Rect_get_Height, (setter)Rect_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Rect_Type_slots[] = 
{
    { Py_tp_new, Rect_new },
    { Py_tp_getset, Rect_getset },
    { 0, nullptr },
};

static PyType_Spec Rect_Type_spec =
{
    "Rect",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>),
    0,
    Py_TPFLAGS_DEFAULT,
    Rect_Type_slots
};

// ----- Size struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Size>::python_type;

winrt::Windows::Foundation::Size py::converter<winrt::Windows::Foundation::Size>::convert_to(PyObject* obj)
{
    if (!PyDict_Check(obj)) { throw winrt::hresult_invalid_argument(); }
    
    winrt::Windows::Foundation::Size new_value{};
    PyObject* pyWidth = PyDict_GetItemString(obj, "Width");
    if (!pyWidth) { throw winrt::hresult_invalid_argument(); }
    new_value.Width = converter<float>::convert_to(pyWidth);
    PyObject* pyHeight = PyDict_GetItemString(obj, "Height");
    if (!pyHeight) { throw winrt::hresult_invalid_argument(); }
    new_value.Height = converter<float>::convert_to(pyHeight);
    return new_value;
}

PyObject* Size_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::Size instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::Size>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    float _Width{};
    float _Height{};
    static char* kwlist[] = {"Width", "Height", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", kwlist, &_Width, &_Height))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::Size instance{ _Width, _Height };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Size_get_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Width);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Size_set_Width(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Width = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Size_get_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.Height);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Size_set_Height(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Height = py::convert_to<float>(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef Size_getset[] = {
    { const_cast<char*>("Width"), (getter)Size_get_Width, (setter)Size_set_Width, nullptr, nullptr },
    { const_cast<char*>("Height"), (getter)Size_get_Height, (setter)Size_set_Height, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Size_Type_slots[] = 
{
    { Py_tp_new, Size_new },
    { Py_tp_getset, Size_getset },
    { 0, nullptr },
};

static PyType_Spec Size_Type_spec =
{
    "Size",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>),
    0,
    Py_TPFLAGS_DEFAULT,
    Size_Type_slots
};

// ----- TimeSpan struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type;

winrt::Windows::Foundation::TimeSpan py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(PyObject* obj)
{
    if (!PyDict_Check(obj)) { throw winrt::hresult_invalid_argument(); }
    
    winrt::Windows::Foundation::TimeSpan new_value{};
    PyObject* pyDuration = PyDict_GetItemString(obj, "Duration");
    if (!pyDuration) { throw winrt::hresult_invalid_argument(); }
    new_value = winrt::Windows::Foundation::TimeSpan { converter<int64_t>::convert_to(pyDuration) };
    return new_value;
}

PyObject* TimeSpan_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Foundation::TimeSpan instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    int64_t _Duration{};
    static char* kwlist[] = {"Duration", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", kwlist, &_Duration))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Foundation::TimeSpan instance{ _Duration };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* TimeSpan_get_Duration(py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>* self, void* /*unused*/)
{
    try
    {
        return py::convert(self->obj.count());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int TimeSpan_set_Duration(py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj = winrt::Windows::Foundation::TimeSpan{ py::convert_to<int64_t>(value) };
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef TimeSpan_getset[] = {
    { const_cast<char*>("Duration"), (getter)TimeSpan_get_Duration, (setter)TimeSpan_set_Duration, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot TimeSpan_Type_slots[] = 
{
    { Py_tp_new, TimeSpan_new },
    { Py_tp_getset, TimeSpan_getset },
    { 0, nullptr },
};

static PyType_Spec TimeSpan_Type_spec =
{
    "TimeSpan",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>),
    0,
    Py_TPFLAGS_DEFAULT,
    TimeSpan_Type_slots
};

// ----- Windows.Foundation Initialization --------------------

int initialize_Windows_Foundation(PyObject* module)
{
    PyObject* type_object{ nullptr };


    type_object = PyType_FromSpec(&GuidHelper_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GuidHelper", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    MemoryBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&MemoryBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MemoryBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Uri_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Uri_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Uri", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Uri>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    WwwFormUrlDecoder_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&WwwFormUrlDecoder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "WwwFormUrlDecoder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    WwwFormUrlDecoderEntry_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&WwwFormUrlDecoderEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "WwwFormUrlDecoderEntry", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncAction_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncAction_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncAction", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncActionWithProgress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncActionWithProgress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncActionWithProgress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncActionWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncInfo_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncInfo_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncInfo", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncOperationWithProgress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncOperationWithProgress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncOperationWithProgress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncOperationWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncOperation_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncOperation_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncOperation", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncOperation>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IClosable_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IClosable_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IClosable", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IGetActivationFactory_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IGetActivationFactory_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IGetActivationFactory", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IMemoryBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IMemoryBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMemoryBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IMemoryBufferReference_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IMemoryBufferReference_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMemoryBufferReference", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStringable_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStringable_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStringable", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IWwwFormUrlDecoderEntry_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IWwwFormUrlDecoderEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IWwwFormUrlDecoderEntry", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&DateTime_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "DateTime", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&EventRegistrationToken_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "EventRegistrationToken", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::event_token>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&HResult_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "HResult", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::hresult>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&Point_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Point", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Point>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&Rect_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Rect", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Rect>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&Size_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Size", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Size>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&TimeSpan_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "TimeSpan", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
