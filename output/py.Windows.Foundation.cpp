// WARNING: Please don't edit this file. It was generated by Python/WinRT

#if __has_include("py.Windows.Foundation.h")
#include "py.Windows.Foundation.h"
#endif

// ----- GuidHelper class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type;

PyObject* GuidHelper_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "GuidHelper is not activatable");
    return nullptr;
}

static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = winrt::Windows::Foundation::GuidHelper::CreateNewGuid();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::guid>(args, 0);
            auto param1 = py::convert_to<winrt::guid>(args, 1);

            bool return_value = winrt::Windows::Foundation::GuidHelper::Equals(param0, param1);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GuidHelper_Empty(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::guid return_value = winrt::Windows::Foundation::GuidHelper::Empty();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef GuidHelper_methods[] = {
    { "CreateNewGuid", (PyCFunction)GuidHelper_CreateNewGuid, METH_VARARGS | METH_STATIC, nullptr },
    { "Equals", (PyCFunction)GuidHelper_Equals, METH_VARARGS | METH_STATIC, nullptr },
    { "Empty", (PyCFunction)GuidHelper_Empty, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GuidHelper_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, GuidHelper_new },
    { Py_tp_methods, GuidHelper_methods },
    { 0, nullptr },
};

static PyType_Spec GuidHelper_Type_spec =
{
    "GuidHelper",
    0,
    0,
    Py_TPFLAGS_DEFAULT,
    GuidHelper_Type_slots
};

// ----- MemoryBuffer class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type;

PyObject* MemoryBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            winrt::Windows::Foundation::MemoryBuffer instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void MemoryBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* MemoryBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IMemoryBufferReference return_value = self->obj.CreateReference();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* MemoryBuffer_Close(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef MemoryBuffer_methods[] = {
    { "CreateReference", (PyCFunction)MemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)MemoryBuffer_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot MemoryBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, MemoryBuffer_new },
    { Py_tp_dealloc, MemoryBuffer_dealloc },
    { Py_tp_methods, MemoryBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec MemoryBuffer_Type_spec =
{
    "MemoryBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::MemoryBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    MemoryBuffer_Type_slots
};

// ----- Uri class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Uri>::python_type;

PyObject* Uri_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Foundation::Uri instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::hstring>(args, 1);
            winrt::Windows::Foundation::Uri instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void Uri_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Uri_Equals(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

            bool return_value = self->obj.Equals(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_CombineUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::Uri return_value = self->obj.CombineUri(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_ToString(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.ToString();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = winrt::Windows::Foundation::Uri::UnescapeComponent(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = winrt::Windows::Foundation::Uri::EscapeComponent(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Uri_get_AbsoluteUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AbsoluteUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_DisplayUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Domain(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Domain();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Extension(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Extension();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Fragment(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Fragment();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Host(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Host();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Password(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Password();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Path(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Path();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Port(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Port();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Query(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Query();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_QueryParsed(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.QueryParsed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_RawUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RawUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_SchemeName(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SchemeName();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_Suspicious(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Suspicious();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_UserName(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.UserName();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_AbsoluteCanonicalUri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AbsoluteCanonicalUri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Uri_get_DisplayIri(py::winrt_wrapper<winrt::Windows::Foundation::Uri>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DisplayIri();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef Uri_methods[] = {
    { "Equals", (PyCFunction)Uri_Equals, METH_VARARGS, nullptr },
    { "CombineUri", (PyCFunction)Uri_CombineUri, METH_VARARGS, nullptr },
    { "ToString", (PyCFunction)Uri_ToString, METH_VARARGS, nullptr },
    { "UnescapeComponent", (PyCFunction)Uri_UnescapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { "EscapeComponent", (PyCFunction)Uri_EscapeComponent, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Uri_getset[] = {
    { const_cast<char*>("AbsoluteUri"), (getter)Uri_get_AbsoluteUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayUri"), (getter)Uri_get_DisplayUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("Domain"), (getter)Uri_get_Domain, nullptr, nullptr, nullptr },
    { const_cast<char*>("Extension"), (getter)Uri_get_Extension, nullptr, nullptr, nullptr },
    { const_cast<char*>("Fragment"), (getter)Uri_get_Fragment, nullptr, nullptr, nullptr },
    { const_cast<char*>("Host"), (getter)Uri_get_Host, nullptr, nullptr, nullptr },
    { const_cast<char*>("Password"), (getter)Uri_get_Password, nullptr, nullptr, nullptr },
    { const_cast<char*>("Path"), (getter)Uri_get_Path, nullptr, nullptr, nullptr },
    { const_cast<char*>("Port"), (getter)Uri_get_Port, nullptr, nullptr, nullptr },
    { const_cast<char*>("Query"), (getter)Uri_get_Query, nullptr, nullptr, nullptr },
    { const_cast<char*>("QueryParsed"), (getter)Uri_get_QueryParsed, nullptr, nullptr, nullptr },
    { const_cast<char*>("RawUri"), (getter)Uri_get_RawUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("SchemeName"), (getter)Uri_get_SchemeName, nullptr, nullptr, nullptr },
    { const_cast<char*>("Suspicious"), (getter)Uri_get_Suspicious, nullptr, nullptr, nullptr },
    { const_cast<char*>("UserName"), (getter)Uri_get_UserName, nullptr, nullptr, nullptr },
    { const_cast<char*>("AbsoluteCanonicalUri"), (getter)Uri_get_AbsoluteCanonicalUri, nullptr, nullptr, nullptr },
    { const_cast<char*>("DisplayIri"), (getter)Uri_get_DisplayIri, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Uri_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Uri_new },
    { Py_tp_dealloc, Uri_dealloc },
    { Py_tp_methods, Uri_methods },
    { Py_tp_getset, Uri_getset },
    { 0, nullptr },
};

static PyType_Spec Uri_Type_spec =
{
    "Uri",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::Uri>),
    0,
    Py_TPFLAGS_DEFAULT,
    Uri_Type_slots
};

// ----- WwwFormUrlDecoder class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type;

PyObject* WwwFormUrlDecoder_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            winrt::Windows::Foundation::WwwFormUrlDecoder instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void WwwFormUrlDecoder_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::hstring return_value = self->obj.GetFirstValueByName(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_First(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> return_value = self->obj.First();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetAt(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            winrt::Windows::Foundation::IWwwFormUrlDecoderEntry return_value = self->obj.GetAt(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_IndexOf(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
            uint32_t param1 {  };

            bool return_value = self->obj.IndexOf(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_GetMany(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*r*/ winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> param1 { };

            uint32_t return_value = self->obj.GetMany(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* WwwFormUrlDecoder_get_Size(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Size();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef WwwFormUrlDecoder_methods[] = {
    { "GetFirstValueByName", (PyCFunction)WwwFormUrlDecoder_GetFirstValueByName, METH_VARARGS, nullptr },
    { "First", (PyCFunction)WwwFormUrlDecoder_First, METH_VARARGS, nullptr },
    { "GetAt", (PyCFunction)WwwFormUrlDecoder_GetAt, METH_VARARGS, nullptr },
    { "IndexOf", (PyCFunction)WwwFormUrlDecoder_IndexOf, METH_VARARGS, nullptr },
    { "GetMany", (PyCFunction)WwwFormUrlDecoder_GetMany, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef WwwFormUrlDecoder_getset[] = {
    { const_cast<char*>("Size"), (getter)WwwFormUrlDecoder_get_Size, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot WwwFormUrlDecoder_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, WwwFormUrlDecoder_new },
    { Py_tp_dealloc, WwwFormUrlDecoder_dealloc },
    { Py_tp_methods, WwwFormUrlDecoder_methods },
    { Py_tp_getset, WwwFormUrlDecoder_getset },
    { 0, nullptr },
};

static PyType_Spec WwwFormUrlDecoder_Type_spec =
{
    "WwwFormUrlDecoder",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoder>),
    0,
    Py_TPFLAGS_DEFAULT,
    WwwFormUrlDecoder_Type_slots
};

// ----- WwwFormUrlDecoderEntry class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type;

PyObject* WwwFormUrlDecoderEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "WwwFormUrlDecoderEntry is not activatable");
    return nullptr;
}

static void WwwFormUrlDecoderEntry_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* WwwFormUrlDecoderEntry_get_Name(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* WwwFormUrlDecoderEntry_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Value();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef WwwFormUrlDecoderEntry_getset[] = {
    { const_cast<char*>("Name"), (getter)WwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Value"), (getter)WwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot WwwFormUrlDecoderEntry_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, WwwFormUrlDecoderEntry_new },
    { Py_tp_dealloc, WwwFormUrlDecoderEntry_dealloc },
    { Py_tp_getset, WwwFormUrlDecoderEntry_getset },
    { 0, nullptr },
};

static PyType_Spec WwwFormUrlDecoderEntry_Type_spec =
{
    "WwwFormUrlDecoderEntry",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    WwwFormUrlDecoderEntry_Type_slots
};

// ----- IAsyncAction interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type;

PyObject* IAsyncAction_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncAction>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IAsyncAction_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncAction_GetResults(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.GetResults();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncAction_get_Completed(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Completed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int IAsyncAction_put_Completed(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(value);
        self->obj.Completed(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyMethodDef IAsyncAction_methods[] = {
    { "GetResults", (PyCFunction)IAsyncAction_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncAction_getset[] = {
    { const_cast<char*>("Completed"), (getter)IAsyncAction_get_Completed, (setter)IAsyncAction_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncAction_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IAsyncAction_new },
    { Py_tp_dealloc, IAsyncAction_dealloc },
    { Py_tp_methods, IAsyncAction_methods },
    { Py_tp_getset, IAsyncAction_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncAction_Type_spec =
{
    "IAsyncAction",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncAction>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncAction_Type_slots
};

// ----- IAsyncActionWithProgress parameterized interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncActionWithProgress>::python_type;

PyObject* IAsyncActionWithProgress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    // TODO implement QI in this pinterface constructor
    PyErr_SetString(PyExc_RuntimeError, "IAsyncActionWithProgress is not activatable");
    return nullptr;
}

static void IAsyncActionWithProgress_dealloc(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self)
{
    py::wrapped_instance(self->obj->hash(), nullptr);
    self->obj.release();
}

static PyObject* IAsyncActionWithProgress_GetResults(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncActionWithProgress_get_Progress(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Progress();
}

static int IAsyncActionWithProgress_put_Progress(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Progress(value);
}

static PyObject* IAsyncActionWithProgress_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncActionWithProgress_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Completed(value);
}

static PyMethodDef IAsyncActionWithProgress_methods[] = {
    { "GetResults", (PyCFunction)IAsyncActionWithProgress_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncActionWithProgress_getset[] = {
    { const_cast<char*>("Progress"), (getter)IAsyncActionWithProgress_get_Progress, (setter)IAsyncActionWithProgress_put_Progress, nullptr, nullptr },
    { const_cast<char*>("Completed"), (getter)IAsyncActionWithProgress_get_Completed, (setter)IAsyncActionWithProgress_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncActionWithProgress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IAsyncActionWithProgress_new },
    { Py_tp_dealloc, IAsyncActionWithProgress_dealloc },
    { Py_tp_methods, IAsyncActionWithProgress_methods },
    { Py_tp_getset, IAsyncActionWithProgress_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncActionWithProgress_Type_spec =
{
    "IAsyncActionWithProgress",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncActionWithProgress>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncActionWithProgress_Type_slots
};

// ----- IAsyncInfo interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type;

PyObject* IAsyncInfo_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IAsyncInfo>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IAsyncInfo_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IAsyncInfo_Cancel(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncInfo_Close(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* IAsyncInfo_get_ErrorCode(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ErrorCode();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IAsyncInfo_get_Id(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IAsyncInfo_get_Status(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Status();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef IAsyncInfo_methods[] = {
    { "Cancel", (PyCFunction)IAsyncInfo_Cancel, METH_VARARGS, nullptr },
    { "Close", (PyCFunction)IAsyncInfo_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncInfo_getset[] = {
    { const_cast<char*>("ErrorCode"), (getter)IAsyncInfo_get_ErrorCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("Id"), (getter)IAsyncInfo_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("Status"), (getter)IAsyncInfo_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncInfo_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IAsyncInfo_new },
    { Py_tp_dealloc, IAsyncInfo_dealloc },
    { Py_tp_methods, IAsyncInfo_methods },
    { Py_tp_getset, IAsyncInfo_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncInfo_Type_spec =
{
    "IAsyncInfo",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IAsyncInfo>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncInfo_Type_slots
};

// ----- IAsyncOperationWithProgress parameterized interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncOperationWithProgress>::python_type;

PyObject* IAsyncOperationWithProgress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    // TODO implement QI in this pinterface constructor
    PyErr_SetString(PyExc_RuntimeError, "IAsyncOperationWithProgress is not activatable");
    return nullptr;
}

static void IAsyncOperationWithProgress_dealloc(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self)
{
    py::wrapped_instance(self->obj->hash(), nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperationWithProgress_GetResults(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperationWithProgress_get_Progress(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Progress();
}

static int IAsyncOperationWithProgress_put_Progress(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Progress(value);
}

static PyObject* IAsyncOperationWithProgress_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncOperationWithProgress_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Completed(value);
}

static PyMethodDef IAsyncOperationWithProgress_methods[] = {
    { "GetResults", (PyCFunction)IAsyncOperationWithProgress_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncOperationWithProgress_getset[] = {
    { const_cast<char*>("Progress"), (getter)IAsyncOperationWithProgress_get_Progress, (setter)IAsyncOperationWithProgress_put_Progress, nullptr, nullptr },
    { const_cast<char*>("Completed"), (getter)IAsyncOperationWithProgress_get_Completed, (setter)IAsyncOperationWithProgress_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncOperationWithProgress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IAsyncOperationWithProgress_new },
    { Py_tp_dealloc, IAsyncOperationWithProgress_dealloc },
    { Py_tp_methods, IAsyncOperationWithProgress_methods },
    { Py_tp_getset, IAsyncOperationWithProgress_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncOperationWithProgress_Type_spec =
{
    "IAsyncOperationWithProgress",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncOperationWithProgress>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncOperationWithProgress_Type_slots
};

// ----- IAsyncOperation parameterized interface --------------------
PyTypeObject* py::winrt_type<pyIAsyncOperation>::python_type;

PyObject* IAsyncOperation_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    // TODO implement QI in this pinterface constructor
    PyErr_SetString(PyExc_RuntimeError, "IAsyncOperation is not activatable");
    return nullptr;
}

static void IAsyncOperation_dealloc(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self)
{
    py::wrapped_instance(self->obj->hash(), nullptr);
    self->obj.release();
}

static PyObject* IAsyncOperation_GetResults(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* args)
{
    return self->obj->GetResults(args);
}

static PyObject* IAsyncOperation_get_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, void* /*unused*/)
{
    return self->obj->get_Completed();
}

static int IAsyncOperation_put_Completed(py::winrt_pinterface_wrapper<pyIAsyncOperation>* self, PyObject* value, void* /*unused*/)
{
    return self->obj->put_Completed(value);
}

static PyMethodDef IAsyncOperation_methods[] = {
    { "GetResults", (PyCFunction)IAsyncOperation_GetResults, METH_VARARGS, nullptr },
    { nullptr }
};

static PyGetSetDef IAsyncOperation_getset[] = {
    { const_cast<char*>("Completed"), (getter)IAsyncOperation_get_Completed, (setter)IAsyncOperation_put_Completed, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IAsyncOperation_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IAsyncOperation_new },
    { Py_tp_dealloc, IAsyncOperation_dealloc },
    { Py_tp_methods, IAsyncOperation_methods },
    { Py_tp_getset, IAsyncOperation_getset },
    { 0, nullptr },
};

static PyType_Spec IAsyncOperation_Type_spec =
{
    "IAsyncOperation",
    sizeof(py::winrt_pinterface_wrapper<pyIAsyncOperation>),
    0,
    Py_TPFLAGS_DEFAULT,
    IAsyncOperation_Type_slots
};

// ----- IClosable interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type;

PyObject* IClosable_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IClosable>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IClosable_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IClosable_Close(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IClosable_methods[] = {
    { "Close", (PyCFunction)IClosable_Close, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IClosable_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IClosable_new },
    { Py_tp_dealloc, IClosable_dealloc },
    { Py_tp_methods, IClosable_methods },
    { 0, nullptr },
};

static PyType_Spec IClosable_Type_spec =
{
    "IClosable",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IClosable>),
    0,
    Py_TPFLAGS_DEFAULT,
    IClosable_Type_slots
};

// ----- IGetActivationFactory interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type;

PyObject* IGetActivationFactory_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IGetActivationFactory>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IGetActivationFactory_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGetActivationFactory_GetActivationFactory(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);

            winrt::Windows::Foundation::IInspectable return_value = self->obj.GetActivationFactory(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IGetActivationFactory_methods[] = {
    { "GetActivationFactory", (PyCFunction)IGetActivationFactory_GetActivationFactory, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IGetActivationFactory_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IGetActivationFactory_new },
    { Py_tp_dealloc, IGetActivationFactory_dealloc },
    { Py_tp_methods, IGetActivationFactory_methods },
    { 0, nullptr },
};

static PyType_Spec IGetActivationFactory_Type_spec =
{
    "IGetActivationFactory",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IGetActivationFactory>),
    0,
    Py_TPFLAGS_DEFAULT,
    IGetActivationFactory_Type_slots
};

// ----- IMemoryBuffer interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type;

PyObject* IMemoryBuffer_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBuffer>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IMemoryBuffer_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBuffer_CreateReference(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IMemoryBufferReference return_value = self->obj.CreateReference();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IMemoryBuffer_methods[] = {
    { "CreateReference", (PyCFunction)IMemoryBuffer_CreateReference, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IMemoryBuffer_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IMemoryBuffer_new },
    { Py_tp_dealloc, IMemoryBuffer_dealloc },
    { Py_tp_methods, IMemoryBuffer_methods },
    { 0, nullptr },
};

static PyType_Spec IMemoryBuffer_Type_spec =
{
    "IMemoryBuffer",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBuffer>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMemoryBuffer_Type_slots
};

// ----- IMemoryBufferReference interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type;

PyObject* IMemoryBufferReference_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBufferReference>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IMemoryBufferReference_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IMemoryBufferReference_get_Capacity(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Capacity();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef IMemoryBufferReference_getset[] = {
    { const_cast<char*>("Capacity"), (getter)IMemoryBufferReference_get_Capacity, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IMemoryBufferReference_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IMemoryBufferReference_new },
    { Py_tp_dealloc, IMemoryBufferReference_dealloc },
    { Py_tp_getset, IMemoryBufferReference_getset },
    { 0, nullptr },
};

static PyType_Spec IMemoryBufferReference_Type_spec =
{
    "IMemoryBufferReference",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IMemoryBufferReference>),
    0,
    Py_TPFLAGS_DEFAULT,
    IMemoryBufferReference_Type_slots
};

// ----- IStringable interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type;

PyObject* IStringable_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IStringable>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IStringable_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IStringable_ToString(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::hstring return_value = self->obj.ToString();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef IStringable_methods[] = {
    { "ToString", (PyCFunction)IStringable_ToString, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot IStringable_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IStringable_new },
    { Py_tp_dealloc, IStringable_dealloc },
    { Py_tp_methods, IStringable_methods },
    { 0, nullptr },
};

static PyType_Spec IStringable_Type_spec =
{
    "IStringable",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IStringable>),
    0,
    Py_TPFLAGS_DEFAULT,
    IStringable_Type_slots
};

// ----- IWwwFormUrlDecoderEntry interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type;

PyObject* IWwwFormUrlDecoderEntry_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IWwwFormUrlDecoderEntry_dealloc(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Name();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Value();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef IWwwFormUrlDecoderEntry_getset[] = {
    { const_cast<char*>("Name"), (getter)IWwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
    { const_cast<char*>("Value"), (getter)IWwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IWwwFormUrlDecoderEntry_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IWwwFormUrlDecoderEntry_new },
    { Py_tp_dealloc, IWwwFormUrlDecoderEntry_dealloc },
    { Py_tp_getset, IWwwFormUrlDecoderEntry_getset },
    { 0, nullptr },
};

static PyType_Spec IWwwFormUrlDecoderEntry_Type_spec =
{
    "IWwwFormUrlDecoderEntry",
    sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>),
    0,
    Py_TPFLAGS_DEFAULT,
    IWwwFormUrlDecoderEntry_Type_slots
};

// ----- Windows.Foundation Initialization --------------------

int initialize_Windows_Foundation(PyObject* module)
{
    PyObject* type_object{ nullptr };

    GuidHelper_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GuidHelper_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GuidHelper", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    MemoryBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&MemoryBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "MemoryBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Uri_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Uri_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Uri", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::Uri>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    WwwFormUrlDecoder_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&WwwFormUrlDecoder_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "WwwFormUrlDecoder", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    WwwFormUrlDecoderEntry_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&WwwFormUrlDecoderEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "WwwFormUrlDecoderEntry", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncAction_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncAction_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncAction", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncActionWithProgress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncActionWithProgress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncActionWithProgress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncActionWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncInfo_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncInfo_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncInfo", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncOperationWithProgress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncOperationWithProgress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncOperationWithProgress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncOperationWithProgress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IAsyncOperation_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IAsyncOperation_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IAsyncOperation", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<pyIAsyncOperation>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IClosable_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IClosable_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IClosable", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IGetActivationFactory_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IGetActivationFactory_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IGetActivationFactory", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IMemoryBuffer_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IMemoryBuffer_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMemoryBuffer", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IMemoryBufferReference_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IMemoryBufferReference_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IMemoryBufferReference", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IStringable_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IStringable_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IStringable", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IWwwFormUrlDecoderEntry_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IWwwFormUrlDecoderEntry_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IWwwFormUrlDecoderEntry", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    return 0;
}
