// WARNING: Please don't edit this file. It was generated by Python/WinRT

#if __has_include("py.Windows.Devices.Geolocation.h")
#include "py.Windows.Devices.Geolocation.h"
#endif

// ----- CivicAddress class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type;

PyObject* CivicAddress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "CivicAddress is not activatable");
    return nullptr;
}

static void CivicAddress_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* CivicAddress_get_City(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.City();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_Country(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Country();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_PostalCode(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PostalCode();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_State(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.State();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Timestamp();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef CivicAddress_getset[] = {
    { const_cast<char*>("City"), (getter)CivicAddress_get_City, nullptr, nullptr, nullptr },
    { const_cast<char*>("Country"), (getter)CivicAddress_get_Country, nullptr, nullptr, nullptr },
    { const_cast<char*>("PostalCode"), (getter)CivicAddress_get_PostalCode, nullptr, nullptr, nullptr },
    { const_cast<char*>("State"), (getter)CivicAddress_get_State, nullptr, nullptr, nullptr },
    { const_cast<char*>("Timestamp"), (getter)CivicAddress_get_Timestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot CivicAddress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, CivicAddress_new },
    { Py_tp_dealloc, CivicAddress_dealloc },
    { Py_tp_getset, CivicAddress_getset },
    { 0, nullptr },
};

static PyType_Spec CivicAddress_Type_spec =
{
    "CivicAddress",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>),
    0,
    Py_TPFLAGS_DEFAULT,
    CivicAddress_Type_slots
};

// ----- GeoboundingBox class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type;

PyObject* GeoboundingBox_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void GeoboundingBox_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeoboundingBox_TryCompute(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);

            winrt::Windows::Devices::Geolocation::GeoboundingBox return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

            winrt::Windows::Devices::Geolocation::GeoboundingBox return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            winrt::Windows::Devices::Geolocation::GeoboundingBox return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1, param2);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeoboundingBox_get_Center(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Center();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_MaxAltitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MaxAltitude();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_MinAltitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MinAltitude();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_NorthwestCorner(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.NorthwestCorner();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_SoutheastCorner(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SoutheastCorner();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeoboundingBox_methods[] = {
    { "TryCompute", (PyCFunction)GeoboundingBox_TryCompute, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeoboundingBox_getset[] = {
    { const_cast<char*>("Center"), (getter)GeoboundingBox_get_Center, nullptr, nullptr, nullptr },
    { const_cast<char*>("MaxAltitude"), (getter)GeoboundingBox_get_MaxAltitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("MinAltitude"), (getter)GeoboundingBox_get_MinAltitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("NorthwestCorner"), (getter)GeoboundingBox_get_NorthwestCorner, nullptr, nullptr, nullptr },
    { const_cast<char*>("SoutheastCorner"), (getter)GeoboundingBox_get_SoutheastCorner, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)GeoboundingBox_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)GeoboundingBox_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)GeoboundingBox_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeoboundingBox_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, GeoboundingBox_new },
    { Py_tp_dealloc, GeoboundingBox_dealloc },
    { Py_tp_methods, GeoboundingBox_methods },
    { Py_tp_getset, GeoboundingBox_getset },
    { 0, nullptr },
};

static PyType_Spec GeoboundingBox_Type_spec =
{
    "GeoboundingBox",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeoboundingBox_Type_slots
};

// ----- Geocircle class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type;

PyObject* Geocircle_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void Geocircle_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocircle_get_Center(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Center();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_Radius(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Radius();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef Geocircle_getset[] = {
    { const_cast<char*>("Center"), (getter)Geocircle_get_Center, nullptr, nullptr, nullptr },
    { const_cast<char*>("Radius"), (getter)Geocircle_get_Radius, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)Geocircle_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)Geocircle_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)Geocircle_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geocircle_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Geocircle_new },
    { Py_tp_dealloc, Geocircle_dealloc },
    { Py_tp_getset, Geocircle_getset },
    { 0, nullptr },
};

static PyType_Spec Geocircle_Type_spec =
{
    "Geocircle",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geocircle_Type_slots
};

// ----- Geocoordinate class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type;

PyObject* Geocoordinate_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "Geocoordinate is not activatable");
    return nullptr;
}

static void Geocoordinate_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocoordinate_get_Accuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Accuracy();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Altitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Altitude();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_AltitudeAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeAccuracy();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Heading(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Heading();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Latitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Latitude();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Longitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Longitude();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Speed(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Speed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Timestamp();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Point(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Point();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_PositionSource(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PositionSource();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_SatelliteData(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SatelliteData();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_PositionSourceTimestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PositionSourceTimestamp();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef Geocoordinate_getset[] = {
    { const_cast<char*>("Accuracy"), (getter)Geocoordinate_get_Accuracy, nullptr, nullptr, nullptr },
    { const_cast<char*>("Altitude"), (getter)Geocoordinate_get_Altitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeAccuracy"), (getter)Geocoordinate_get_AltitudeAccuracy, nullptr, nullptr, nullptr },
    { const_cast<char*>("Heading"), (getter)Geocoordinate_get_Heading, nullptr, nullptr, nullptr },
    { const_cast<char*>("Latitude"), (getter)Geocoordinate_get_Latitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("Longitude"), (getter)Geocoordinate_get_Longitude, nullptr, nullptr, nullptr },
    { const_cast<char*>("Speed"), (getter)Geocoordinate_get_Speed, nullptr, nullptr, nullptr },
    { const_cast<char*>("Timestamp"), (getter)Geocoordinate_get_Timestamp, nullptr, nullptr, nullptr },
    { const_cast<char*>("Point"), (getter)Geocoordinate_get_Point, nullptr, nullptr, nullptr },
    { const_cast<char*>("PositionSource"), (getter)Geocoordinate_get_PositionSource, nullptr, nullptr, nullptr },
    { const_cast<char*>("SatelliteData"), (getter)Geocoordinate_get_SatelliteData, nullptr, nullptr, nullptr },
    { const_cast<char*>("PositionSourceTimestamp"), (getter)Geocoordinate_get_PositionSourceTimestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geocoordinate_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Geocoordinate_new },
    { Py_tp_dealloc, Geocoordinate_dealloc },
    { Py_tp_getset, Geocoordinate_getset },
    { 0, nullptr },
};

static PyType_Spec Geocoordinate_Type_spec =
{
    "Geocoordinate",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geocoordinate_Type_slots
};

// ----- GeocoordinateSatelliteData class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type;

PyObject* GeocoordinateSatelliteData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "GeocoordinateSatelliteData is not activatable");
    return nullptr;
}

static void GeocoordinateSatelliteData_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.HorizontalDilutionOfPrecision();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeocoordinateSatelliteData_get_PositionDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.PositionDilutionOfPrecision();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.VerticalDilutionOfPrecision();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef GeocoordinateSatelliteData_getset[] = {
    { const_cast<char*>("HorizontalDilutionOfPrecision"), (getter)GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision, nullptr, nullptr, nullptr },
    { const_cast<char*>("PositionDilutionOfPrecision"), (getter)GeocoordinateSatelliteData_get_PositionDilutionOfPrecision, nullptr, nullptr, nullptr },
    { const_cast<char*>("VerticalDilutionOfPrecision"), (getter)GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeocoordinateSatelliteData_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, GeocoordinateSatelliteData_new },
    { Py_tp_dealloc, GeocoordinateSatelliteData_dealloc },
    { Py_tp_getset, GeocoordinateSatelliteData_getset },
    { 0, nullptr },
};

static PyType_Spec GeocoordinateSatelliteData_Type_spec =
{
    "GeocoordinateSatelliteData",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeocoordinateSatelliteData_Type_slots
};

// ----- Geolocator class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type;

PyObject* Geolocator_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Devices::Geolocation::Geolocator instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void Geolocator_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geolocator_GetGeopositionAsync(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::Geoposition> return_value = self->obj.GetGeopositionAsync();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::Geoposition> return_value = self->obj.GetGeopositionAsync(param0, param1);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_AllowFallbackToConsentlessPositions(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.AllowFallbackToConsentlessPositions();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_RequestAccessAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::GeolocationAccessStatus> return_value = winrt::Windows::Devices::Geolocation::Geolocator::RequestAccessAsync();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_GetGeopositionHistoryAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::Geoposition>> return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::Geoposition>> return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0, param1);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_DefaultGeoposition(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition> return_value = winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);

            winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_IsDefaultGeopositionRecommended(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            bool return_value = winrt::Windows::Devices::Geolocation::Geolocator::IsDefaultGeopositionRecommended();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_get_ReportInterval(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.ReportInterval();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_ReportInterval(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<uint32_t>(value);
        self->obj.ReportInterval(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Geolocator_get_MovementThreshold(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MovementThreshold();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_MovementThreshold(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<double>(value);
        self->obj.MovementThreshold(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Geolocator_get_DesiredAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DesiredAccuracy();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_DesiredAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::PositionAccuracy>(value);
        self->obj.DesiredAccuracy(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* Geolocator_get_LocationStatus(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LocationStatus();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_get_DesiredAccuracyInMeters(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DesiredAccuracyInMeters();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int Geolocator_put_DesiredAccuracyInMeters(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(value);
        self->obj.DesiredAccuracyInMeters(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyMethodDef Geolocator_methods[] = {
    { "GetGeopositionAsync", (PyCFunction)Geolocator_GetGeopositionAsync, METH_VARARGS, nullptr },
    { "AllowFallbackToConsentlessPositions", (PyCFunction)Geolocator_AllowFallbackToConsentlessPositions, METH_VARARGS, nullptr },
    { "RequestAccessAsync", (PyCFunction)Geolocator_RequestAccessAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "GetGeopositionHistoryAsync", (PyCFunction)Geolocator_GetGeopositionHistoryAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "DefaultGeoposition", (PyCFunction)Geolocator_DefaultGeoposition, METH_VARARGS | METH_STATIC, nullptr },
    { "IsDefaultGeopositionRecommended", (PyCFunction)Geolocator_IsDefaultGeopositionRecommended, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef Geolocator_getset[] = {
    { const_cast<char*>("ReportInterval"), (getter)Geolocator_get_ReportInterval, (setter)Geolocator_put_ReportInterval, nullptr, nullptr },
    { const_cast<char*>("MovementThreshold"), (getter)Geolocator_get_MovementThreshold, (setter)Geolocator_put_MovementThreshold, nullptr, nullptr },
    { const_cast<char*>("DesiredAccuracy"), (getter)Geolocator_get_DesiredAccuracy, (setter)Geolocator_put_DesiredAccuracy, nullptr, nullptr },
    { const_cast<char*>("LocationStatus"), (getter)Geolocator_get_LocationStatus, nullptr, nullptr, nullptr },
    { const_cast<char*>("DesiredAccuracyInMeters"), (getter)Geolocator_get_DesiredAccuracyInMeters, (setter)Geolocator_put_DesiredAccuracyInMeters, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geolocator_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Geolocator_new },
    { Py_tp_dealloc, Geolocator_dealloc },
    { Py_tp_methods, Geolocator_methods },
    { Py_tp_getset, Geolocator_getset },
    { 0, nullptr },
};

static PyType_Spec Geolocator_Type_spec =
{
    "Geolocator",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geolocator_Type_slots
};

// ----- Geopath class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type;

PyObject* Geopath_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void Geopath_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopath_get_Positions(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Positions();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopath_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopath_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopath_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef Geopath_getset[] = {
    { const_cast<char*>("Positions"), (getter)Geopath_get_Positions, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)Geopath_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)Geopath_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)Geopath_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geopath_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Geopath_new },
    { Py_tp_dealloc, Geopath_dealloc },
    { Py_tp_getset, Geopath_getset },
    { 0, nullptr },
};

static PyType_Spec Geopath_Type_spec =
{
    "Geopath",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geopath_Type_slots
};

// ----- Geopoint class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type;

PyObject* Geopoint_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void Geopoint_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopoint_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopoint_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopoint_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopoint_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef Geopoint_getset[] = {
    { const_cast<char*>("Position"), (getter)Geopoint_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)Geopoint_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)Geopoint_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)Geopoint_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geopoint_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Geopoint_new },
    { Py_tp_dealloc, Geopoint_dealloc },
    { Py_tp_getset, Geopoint_getset },
    { 0, nullptr },
};

static PyType_Spec Geopoint_Type_spec =
{
    "Geopoint",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geopoint_Type_slots
};

// ----- Geoposition class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type;

PyObject* Geoposition_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "Geoposition is not activatable");
    return nullptr;
}

static void Geoposition_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geoposition_get_CivicAddress(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.CivicAddress();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geoposition_get_Coordinate(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Coordinate();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geoposition_get_VenueData(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.VenueData();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef Geoposition_getset[] = {
    { const_cast<char*>("CivicAddress"), (getter)Geoposition_get_CivicAddress, nullptr, nullptr, nullptr },
    { const_cast<char*>("Coordinate"), (getter)Geoposition_get_Coordinate, nullptr, nullptr, nullptr },
    { const_cast<char*>("VenueData"), (getter)Geoposition_get_VenueData, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geoposition_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Geoposition_new },
    { Py_tp_dealloc, Geoposition_dealloc },
    { Py_tp_getset, Geoposition_getset },
    { 0, nullptr },
};

static PyType_Spec Geoposition_Type_spec =
{
    "Geoposition",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geoposition_Type_slots
};

// ----- Geovisit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type;

PyObject* Geovisit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "Geovisit is not activatable");
    return nullptr;
}

static void Geovisit_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geovisit_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geovisit_get_StateChange(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.StateChange();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geovisit_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Timestamp();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef Geovisit_getset[] = {
    { const_cast<char*>("Position"), (getter)Geovisit_get_Position, nullptr, nullptr, nullptr },
    { const_cast<char*>("StateChange"), (getter)Geovisit_get_StateChange, nullptr, nullptr, nullptr },
    { const_cast<char*>("Timestamp"), (getter)Geovisit_get_Timestamp, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geovisit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, Geovisit_new },
    { Py_tp_dealloc, Geovisit_dealloc },
    { Py_tp_getset, Geovisit_getset },
    { 0, nullptr },
};

static PyType_Spec Geovisit_Type_spec =
{
    "Geovisit",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geovisit_Type_slots
};

// ----- GeovisitMonitor class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type;

PyObject* GeovisitMonitor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Devices::Geolocation::GeovisitMonitor instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void GeovisitMonitor_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitMonitor_Start(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(args, 0);

            self->obj.Start(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeovisitMonitor_Stop(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Stop();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeovisitMonitor_GetLastReportAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::Geovisit> return_value = winrt::Windows::Devices::Geolocation::GeovisitMonitor::GetLastReportAsync();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeovisitMonitor_get_MonitoringScope(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MonitoringScope();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeovisitMonitor_methods[] = {
    { "Start", (PyCFunction)GeovisitMonitor_Start, METH_VARARGS, nullptr },
    { "Stop", (PyCFunction)GeovisitMonitor_Stop, METH_VARARGS, nullptr },
    { "GetLastReportAsync", (PyCFunction)GeovisitMonitor_GetLastReportAsync, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeovisitMonitor_getset[] = {
    { const_cast<char*>("MonitoringScope"), (getter)GeovisitMonitor_get_MonitoringScope, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitMonitor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, GeovisitMonitor_new },
    { Py_tp_dealloc, GeovisitMonitor_dealloc },
    { Py_tp_methods, GeovisitMonitor_methods },
    { Py_tp_getset, GeovisitMonitor_getset },
    { 0, nullptr },
};

static PyType_Spec GeovisitMonitor_Type_spec =
{
    "GeovisitMonitor",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitMonitor_Type_slots
};

// ----- GeovisitStateChangedEventArgs class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type;

PyObject* GeovisitStateChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "GeovisitStateChangedEventArgs is not activatable");
    return nullptr;
}

static void GeovisitStateChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitStateChangedEventArgs_get_Visit(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Visit();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef GeovisitStateChangedEventArgs_getset[] = {
    { const_cast<char*>("Visit"), (getter)GeovisitStateChangedEventArgs_get_Visit, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitStateChangedEventArgs_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, GeovisitStateChangedEventArgs_new },
    { Py_tp_dealloc, GeovisitStateChangedEventArgs_dealloc },
    { Py_tp_getset, GeovisitStateChangedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec GeovisitStateChangedEventArgs_Type_spec =
{
    "GeovisitStateChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitStateChangedEventArgs_Type_slots
};

// ----- GeovisitTriggerDetails class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type;

PyObject* GeovisitTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "GeovisitTriggerDetails is not activatable");
    return nullptr;
}

static void GeovisitTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitTriggerDetails_ReadReports(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::Geovisit> return_value = self->obj.ReadReports();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef GeovisitTriggerDetails_methods[] = {
    { "ReadReports", (PyCFunction)GeovisitTriggerDetails_ReadReports, METH_VARARGS, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitTriggerDetails_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, GeovisitTriggerDetails_new },
    { Py_tp_dealloc, GeovisitTriggerDetails_dealloc },
    { Py_tp_methods, GeovisitTriggerDetails_methods },
    { 0, nullptr },
};

static PyType_Spec GeovisitTriggerDetails_Type_spec =
{
    "GeovisitTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitTriggerDetails_Type_slots
};

// ----- PositionChangedEventArgs class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type;

PyObject* PositionChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "PositionChangedEventArgs is not activatable");
    return nullptr;
}

static void PositionChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PositionChangedEventArgs_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Position();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef PositionChangedEventArgs_getset[] = {
    { const_cast<char*>("Position"), (getter)PositionChangedEventArgs_get_Position, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot PositionChangedEventArgs_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, PositionChangedEventArgs_new },
    { Py_tp_dealloc, PositionChangedEventArgs_dealloc },
    { Py_tp_getset, PositionChangedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec PositionChangedEventArgs_Type_spec =
{
    "PositionChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    PositionChangedEventArgs_Type_slots
};

// ----- StatusChangedEventArgs class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type;

PyObject* StatusChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "StatusChangedEventArgs is not activatable");
    return nullptr;
}

static void StatusChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StatusChangedEventArgs_get_Status(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Status();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef StatusChangedEventArgs_getset[] = {
    { const_cast<char*>("Status"), (getter)StatusChangedEventArgs_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot StatusChangedEventArgs_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, StatusChangedEventArgs_new },
    { Py_tp_dealloc, StatusChangedEventArgs_dealloc },
    { Py_tp_getset, StatusChangedEventArgs_getset },
    { 0, nullptr },
};

static PyType_Spec StatusChangedEventArgs_Type_spec =
{
    "StatusChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    StatusChangedEventArgs_Type_slots
};

// ----- VenueData class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type;

PyObject* VenueData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_RuntimeError, "VenueData is not activatable");
    return nullptr;
}

static void VenueData_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* VenueData_get_Id(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* VenueData_get_Level(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Level();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef VenueData_getset[] = {
    { const_cast<char*>("Id"), (getter)VenueData_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("Level"), (getter)VenueData_get_Level, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot VenueData_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, VenueData_new },
    { Py_tp_dealloc, VenueData_dealloc },
    { Py_tp_getset, VenueData_getset },
    { 0, nullptr },
};

static PyType_Spec VenueData_Type_spec =
{
    "VenueData",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>),
    0,
    Py_TPFLAGS_DEFAULT,
    VenueData_Type_slots
};

// ----- IGeoshape interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type;

PyObject* IGeoshape_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 0);
            return py::wrap(param0, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void IGeoshape_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGeoshape_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.AltitudeReferenceSystem();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IGeoshape_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.GeoshapeType();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IGeoshape_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SpatialReferenceId();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef IGeoshape_getset[] = {
    { const_cast<char*>("AltitudeReferenceSystem"), (getter)IGeoshape_get_AltitudeReferenceSystem, nullptr, nullptr, nullptr },
    { const_cast<char*>("GeoshapeType"), (getter)IGeoshape_get_GeoshapeType, nullptr, nullptr, nullptr },
    { const_cast<char*>("SpatialReferenceId"), (getter)IGeoshape_get_SpatialReferenceId, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot IGeoshape_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_new, IGeoshape_new },
    { Py_tp_dealloc, IGeoshape_dealloc },
    { Py_tp_getset, IGeoshape_getset },
    { 0, nullptr },
};

static PyType_Spec IGeoshape_Type_spec =
{
    "IGeoshape",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>),
    0,
    Py_TPFLAGS_DEFAULT,
    IGeoshape_Type_slots
};

// ----- Windows.Devices.Geolocation Initialization --------------------

int initialize_Windows_Devices_Geolocation(PyObject* module)
{
    PyObject* type_object{ nullptr };

    CivicAddress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&CivicAddress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "CivicAddress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeoboundingBox_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeoboundingBox_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeoboundingBox", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geocircle_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geocircle_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geocircle", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geocoordinate_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geocoordinate_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geocoordinate", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeocoordinateSatelliteData_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeocoordinateSatelliteData_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeocoordinateSatelliteData", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geolocator_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geolocator_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geolocator", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geopath_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geopath_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geopath", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geopoint_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geopoint_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geopoint", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geoposition_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geoposition_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geoposition", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geovisit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geovisit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geovisit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeovisitMonitor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeovisitMonitor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitMonitor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeovisitStateChangedEventArgs_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeovisitStateChangedEventArgs_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitStateChangedEventArgs", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeovisitTriggerDetails_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeovisitTriggerDetails_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitTriggerDetails", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    PositionChangedEventArgs_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&PositionChangedEventArgs_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PositionChangedEventArgs", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StatusChangedEventArgs_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StatusChangedEventArgs_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StatusChangedEventArgs", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    VenueData_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&VenueData_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "VenueData", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IGeoshape_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IGeoshape_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IGeoshape", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    return 0;
}
