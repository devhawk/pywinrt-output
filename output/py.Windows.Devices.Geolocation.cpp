// WARNING: Please don't edit this file. It was generated by Python/WinRT

#include "py.Windows.Devices.Geolocation.h"

// ----- CivicAddress class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type;


PyObject* CivicAddress_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "CivicAddress is not activatable");
    return nullptr;
}

static void CivicAddress_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* CivicAddress__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::CivicAddress>::convert(instance.as<winrt::Windows::Devices::Geolocation::CivicAddress>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* CivicAddress_get_City(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.City();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* CivicAddress_get_Country(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Country();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* CivicAddress_get_PostalCode(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.PostalCode();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* CivicAddress_get_State(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.State();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* CivicAddress_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.Timestamp();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef CivicAddress_methods[] = {
    { "get_City", (PyCFunction)CivicAddress_get_City, METH_NOARGS, nullptr },
    { "get_Country", (PyCFunction)CivicAddress_get_Country, METH_NOARGS, nullptr },
    { "get_PostalCode", (PyCFunction)CivicAddress_get_PostalCode, METH_NOARGS, nullptr },
    { "get_State", (PyCFunction)CivicAddress_get_State, METH_NOARGS, nullptr },
    { "get_Timestamp", (PyCFunction)CivicAddress_get_Timestamp, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)CivicAddress__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot CivicAddress_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, CivicAddress_dealloc },
    { Py_tp_new, CivicAddress_new },
    { Py_tp_methods, CivicAddress_methods },
    { 0, nullptr },
};

static PyType_Spec CivicAddress_Type_spec =
{
    "CivicAddress",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::CivicAddress>),
    0,
    Py_TPFLAGS_DEFAULT,
    CivicAddress_Type_slots
};

// ----- GeoboundingBox class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type;


PyObject* GeoboundingBox_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void GeoboundingBox_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeoboundingBox__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::GeoboundingBox>::convert(instance.as<winrt::Windows::Devices::Geolocation::GeoboundingBox>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeoboundingBox_TryCompute(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);

            winrt::Windows::Devices::Geolocation::GeoboundingBox return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

            winrt::Windows::Devices::Geolocation::GeoboundingBox return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);

            winrt::Windows::Devices::Geolocation::GeoboundingBox return_value = winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1, param2);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeoboundingBox_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem return_value = self->obj.AltitudeReferenceSystem();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeoboundingBox_get_Center(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition return_value = self->obj.Center();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeoboundingBox_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::GeoshapeType return_value = self->obj.GeoshapeType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeoboundingBox_get_MaxAltitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.MaxAltitude();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeoboundingBox_get_MinAltitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.MinAltitude();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeoboundingBox_get_NorthwestCorner(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition return_value = self->obj.NorthwestCorner();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeoboundingBox_get_SoutheastCorner(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition return_value = self->obj.SoutheastCorner();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeoboundingBox_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.SpatialReferenceId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef GeoboundingBox_methods[] = {
    { "TryCompute", (PyCFunction)GeoboundingBox_TryCompute, METH_VARARGS | METH_STATIC, nullptr },
    { "get_AltitudeReferenceSystem", (PyCFunction)GeoboundingBox_get_AltitudeReferenceSystem, METH_NOARGS, nullptr },
    { "get_Center", (PyCFunction)GeoboundingBox_get_Center, METH_NOARGS, nullptr },
    { "get_GeoshapeType", (PyCFunction)GeoboundingBox_get_GeoshapeType, METH_NOARGS, nullptr },
    { "get_MaxAltitude", (PyCFunction)GeoboundingBox_get_MaxAltitude, METH_NOARGS, nullptr },
    { "get_MinAltitude", (PyCFunction)GeoboundingBox_get_MinAltitude, METH_NOARGS, nullptr },
    { "get_NorthwestCorner", (PyCFunction)GeoboundingBox_get_NorthwestCorner, METH_NOARGS, nullptr },
    { "get_SoutheastCorner", (PyCFunction)GeoboundingBox_get_SoutheastCorner, METH_NOARGS, nullptr },
    { "get_SpatialReferenceId", (PyCFunction)GeoboundingBox_get_SpatialReferenceId, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)GeoboundingBox__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GeoboundingBox_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, GeoboundingBox_dealloc },
    { Py_tp_new, GeoboundingBox_new },
    { Py_tp_methods, GeoboundingBox_methods },
    { 0, nullptr },
};

static PyType_Spec GeoboundingBox_Type_spec =
{
    "GeoboundingBox",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeoboundingBox>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeoboundingBox_Type_slots
};

// ----- Geocircle class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type;


PyObject* Geocircle_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<double>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
            auto param3 = py::convert_to<uint32_t>(args, 3);
            winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void Geocircle_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocircle__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::Geocircle>::convert(instance.as<winrt::Windows::Devices::Geolocation::Geocircle>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocircle_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem return_value = self->obj.AltitudeReferenceSystem();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocircle_get_Center(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition return_value = self->obj.Center();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocircle_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::GeoshapeType return_value = self->obj.GeoshapeType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocircle_get_Radius(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.Radius();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocircle_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.SpatialReferenceId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Geocircle_methods[] = {
    { "get_AltitudeReferenceSystem", (PyCFunction)Geocircle_get_AltitudeReferenceSystem, METH_NOARGS, nullptr },
    { "get_Center", (PyCFunction)Geocircle_get_Center, METH_NOARGS, nullptr },
    { "get_GeoshapeType", (PyCFunction)Geocircle_get_GeoshapeType, METH_NOARGS, nullptr },
    { "get_Radius", (PyCFunction)Geocircle_get_Radius, METH_NOARGS, nullptr },
    { "get_SpatialReferenceId", (PyCFunction)Geocircle_get_SpatialReferenceId, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)Geocircle__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Geocircle_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geocircle_dealloc },
    { Py_tp_new, Geocircle_new },
    { Py_tp_methods, Geocircle_methods },
    { 0, nullptr },
};

static PyType_Spec Geocircle_Type_spec =
{
    "Geocircle",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocircle>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geocircle_Type_slots
};

// ----- Geocoordinate class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type;


PyObject* Geocoordinate_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "Geocoordinate is not activatable");
    return nullptr;
}

static void Geocoordinate_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geocoordinate__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::Geocoordinate>::convert(instance.as<winrt::Windows::Devices::Geolocation::Geocoordinate>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geocoordinate_get_Accuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.Accuracy();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_Altitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<double> return_value = self->obj.Altitude();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_AltitudeAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<double> return_value = self->obj.AltitudeAccuracy();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_Heading(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<double> return_value = self->obj.Heading();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_Latitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.Latitude();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_Longitude(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.Longitude();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_Point(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::Geopoint return_value = self->obj.Point();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_PositionSource(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::PositionSource return_value = self->obj.PositionSource();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_PositionSourceTimestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime> return_value = self->obj.PositionSourceTimestamp();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_SatelliteData(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData return_value = self->obj.SatelliteData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_Speed(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<double> return_value = self->obj.Speed();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geocoordinate_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.Timestamp();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Geocoordinate_methods[] = {
    { "get_Accuracy", (PyCFunction)Geocoordinate_get_Accuracy, METH_NOARGS, nullptr },
    { "get_Altitude", (PyCFunction)Geocoordinate_get_Altitude, METH_NOARGS, nullptr },
    { "get_AltitudeAccuracy", (PyCFunction)Geocoordinate_get_AltitudeAccuracy, METH_NOARGS, nullptr },
    { "get_Heading", (PyCFunction)Geocoordinate_get_Heading, METH_NOARGS, nullptr },
    { "get_Latitude", (PyCFunction)Geocoordinate_get_Latitude, METH_NOARGS, nullptr },
    { "get_Longitude", (PyCFunction)Geocoordinate_get_Longitude, METH_NOARGS, nullptr },
    { "get_Point", (PyCFunction)Geocoordinate_get_Point, METH_NOARGS, nullptr },
    { "get_PositionSource", (PyCFunction)Geocoordinate_get_PositionSource, METH_NOARGS, nullptr },
    { "get_PositionSourceTimestamp", (PyCFunction)Geocoordinate_get_PositionSourceTimestamp, METH_NOARGS, nullptr },
    { "get_SatelliteData", (PyCFunction)Geocoordinate_get_SatelliteData, METH_NOARGS, nullptr },
    { "get_Speed", (PyCFunction)Geocoordinate_get_Speed, METH_NOARGS, nullptr },
    { "get_Timestamp", (PyCFunction)Geocoordinate_get_Timestamp, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)Geocoordinate__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Geocoordinate_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geocoordinate_dealloc },
    { Py_tp_new, Geocoordinate_new },
    { Py_tp_methods, Geocoordinate_methods },
    { 0, nullptr },
};

static PyType_Spec Geocoordinate_Type_spec =
{
    "Geocoordinate",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geocoordinate>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geocoordinate_Type_slots
};

// ----- GeocoordinateSatelliteData class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type;


PyObject* GeocoordinateSatelliteData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeocoordinateSatelliteData is not activatable");
    return nullptr;
}

static void GeocoordinateSatelliteData_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeocoordinateSatelliteData__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::convert(instance.as<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<double> return_value = self->obj.HorizontalDilutionOfPrecision();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeocoordinateSatelliteData_get_PositionDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<double> return_value = self->obj.PositionDilutionOfPrecision();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<double> return_value = self->obj.VerticalDilutionOfPrecision();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef GeocoordinateSatelliteData_methods[] = {
    { "get_HorizontalDilutionOfPrecision", (PyCFunction)GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision, METH_NOARGS, nullptr },
    { "get_PositionDilutionOfPrecision", (PyCFunction)GeocoordinateSatelliteData_get_PositionDilutionOfPrecision, METH_NOARGS, nullptr },
    { "get_VerticalDilutionOfPrecision", (PyCFunction)GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)GeocoordinateSatelliteData__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GeocoordinateSatelliteData_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, GeocoordinateSatelliteData_dealloc },
    { Py_tp_new, GeocoordinateSatelliteData_new },
    { Py_tp_methods, GeocoordinateSatelliteData_methods },
    { 0, nullptr },
};

static PyType_Spec GeocoordinateSatelliteData_Type_spec =
{
    "GeocoordinateSatelliteData",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeocoordinateSatelliteData_Type_slots
};

// ----- Geolocator class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type;


PyObject* Geolocator_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Devices::Geolocation::Geolocator instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void Geolocator_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geolocator__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::Geolocator>::convert(instance.as<winrt::Windows::Devices::Geolocation::Geolocator>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geolocator_AllowFallbackToConsentlessPositions(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.AllowFallbackToConsentlessPositions();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_GetGeopositionAsync(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::Geoposition> return_value = self->obj.GetGeopositionAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::Geoposition> return_value = self->obj.GetGeopositionAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_GetGeopositionHistoryAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::Geoposition>> return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::Geoposition>> return_value = winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0, param1);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_RequestAccessAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::GeolocationAccessStatus> return_value = winrt::Windows::Devices::Geolocation::Geolocator::RequestAccessAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* Geolocator_add_PositionChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>>::convert_to(args);

            winrt::event_token return_value = self->obj.PositionChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_add_StatusChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>>::convert_to(args);

            winrt::event_token return_value = self->obj.StatusChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_get_DefaultGeoposition(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition> return_value = winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_get_DesiredAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::PositionAccuracy return_value = self->obj.DesiredAccuracy();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_get_DesiredAccuracyInMeters(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::IReference<uint32_t> return_value = self->obj.DesiredAccuracyInMeters();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_get_IsDefaultGeopositionRecommended(PyObject* /*unused*/, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            bool return_value = winrt::Windows::Devices::Geolocation::Geolocator::IsDefaultGeopositionRecommended();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_get_LocationStatus(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::PositionStatus return_value = self->obj.LocationStatus();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_get_MovementThreshold(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            double return_value = self->obj.MovementThreshold();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_get_ReportInterval(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.ReportInterval();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_put_DefaultGeoposition(PyObject* /*unused*/, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition>>::convert_to(args);

            winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_put_DesiredAccuracy(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Devices::Geolocation::PositionAccuracy>::convert_to(args);

            self->obj.DesiredAccuracy(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_put_DesiredAccuracyInMeters(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::IReference<uint32_t>>::convert_to(args);

            self->obj.DesiredAccuracyInMeters(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_put_MovementThreshold(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<double>::convert_to(args);

            self->obj.MovementThreshold(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_put_ReportInterval(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<uint32_t>::convert_to(args);

            self->obj.ReportInterval(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_remove_PositionChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geolocator_remove_StatusChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Geolocator_methods[] = {
    { "AllowFallbackToConsentlessPositions", (PyCFunction)Geolocator_AllowFallbackToConsentlessPositions, METH_VARARGS, nullptr },
    { "GetGeopositionAsync", (PyCFunction)Geolocator_GetGeopositionAsync, METH_VARARGS, nullptr },
    { "GetGeopositionHistoryAsync", (PyCFunction)Geolocator_GetGeopositionHistoryAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "RequestAccessAsync", (PyCFunction)Geolocator_RequestAccessAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "add_PositionChanged", (PyCFunction)Geolocator_add_PositionChanged, METH_O, nullptr },
    { "add_StatusChanged", (PyCFunction)Geolocator_add_StatusChanged, METH_O, nullptr },
    { "get_DefaultGeoposition", (PyCFunction)Geolocator_get_DefaultGeoposition, METH_NOARGS | METH_STATIC, nullptr },
    { "get_DesiredAccuracy", (PyCFunction)Geolocator_get_DesiredAccuracy, METH_NOARGS, nullptr },
    { "get_DesiredAccuracyInMeters", (PyCFunction)Geolocator_get_DesiredAccuracyInMeters, METH_NOARGS, nullptr },
    { "get_IsDefaultGeopositionRecommended", (PyCFunction)Geolocator_get_IsDefaultGeopositionRecommended, METH_NOARGS | METH_STATIC, nullptr },
    { "get_LocationStatus", (PyCFunction)Geolocator_get_LocationStatus, METH_NOARGS, nullptr },
    { "get_MovementThreshold", (PyCFunction)Geolocator_get_MovementThreshold, METH_NOARGS, nullptr },
    { "get_ReportInterval", (PyCFunction)Geolocator_get_ReportInterval, METH_NOARGS, nullptr },
    { "put_DefaultGeoposition", (PyCFunction)Geolocator_put_DefaultGeoposition, METH_O | METH_STATIC, nullptr },
    { "put_DesiredAccuracy", (PyCFunction)Geolocator_put_DesiredAccuracy, METH_O, nullptr },
    { "put_DesiredAccuracyInMeters", (PyCFunction)Geolocator_put_DesiredAccuracyInMeters, METH_O, nullptr },
    { "put_MovementThreshold", (PyCFunction)Geolocator_put_MovementThreshold, METH_O, nullptr },
    { "put_ReportInterval", (PyCFunction)Geolocator_put_ReportInterval, METH_O, nullptr },
    { "remove_PositionChanged", (PyCFunction)Geolocator_remove_PositionChanged, METH_O, nullptr },
    { "remove_StatusChanged", (PyCFunction)Geolocator_remove_StatusChanged, METH_O, nullptr },
    { "_from", (PyCFunction)Geolocator__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Geolocator_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geolocator_dealloc },
    { Py_tp_new, Geolocator_new },
    { Py_tp_methods, Geolocator_methods },
    { 0, nullptr },
};

static PyType_Spec Geolocator_Type_spec =
{
    "Geolocator",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geolocator>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geolocator_Type_slots
};

// ----- Geopath class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type;


PyObject* Geopath_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void Geopath_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopath__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::Geopath>::convert(instance.as<winrt::Windows::Devices::Geolocation::Geopath>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopath_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem return_value = self->obj.AltitudeReferenceSystem();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geopath_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::GeoshapeType return_value = self->obj.GeoshapeType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geopath_get_Positions(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::BasicGeoposition> return_value = self->obj.Positions();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geopath_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.SpatialReferenceId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Geopath_methods[] = {
    { "get_AltitudeReferenceSystem", (PyCFunction)Geopath_get_AltitudeReferenceSystem, METH_NOARGS, nullptr },
    { "get_GeoshapeType", (PyCFunction)Geopath_get_GeoshapeType, METH_NOARGS, nullptr },
    { "get_Positions", (PyCFunction)Geopath_get_Positions, METH_NOARGS, nullptr },
    { "get_SpatialReferenceId", (PyCFunction)Geopath_get_SpatialReferenceId, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)Geopath__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Geopath_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geopath_dealloc },
    { Py_tp_new, Geopath_new },
    { Py_tp_methods, Geopath_methods },
    { 0, nullptr },
};

static PyType_Spec Geopath_Type_spec =
{
    "Geopath",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopath>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geopath_Type_slots
};

// ----- Geopoint class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type;


PyObject* Geopoint_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 3)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
            auto param2 = py::convert_to<uint32_t>(args, 2);
            winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1, param2 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void Geopoint_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geopoint__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::Geopoint>::convert(instance.as<winrt::Windows::Devices::Geolocation::Geopoint>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geopoint_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem return_value = self->obj.AltitudeReferenceSystem();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geopoint_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::GeoshapeType return_value = self->obj.GeoshapeType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geopoint_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geopoint_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.SpatialReferenceId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Geopoint_methods[] = {
    { "get_AltitudeReferenceSystem", (PyCFunction)Geopoint_get_AltitudeReferenceSystem, METH_NOARGS, nullptr },
    { "get_GeoshapeType", (PyCFunction)Geopoint_get_GeoshapeType, METH_NOARGS, nullptr },
    { "get_Position", (PyCFunction)Geopoint_get_Position, METH_NOARGS, nullptr },
    { "get_SpatialReferenceId", (PyCFunction)Geopoint_get_SpatialReferenceId, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)Geopoint__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Geopoint_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geopoint_dealloc },
    { Py_tp_new, Geopoint_new },
    { Py_tp_methods, Geopoint_methods },
    { 0, nullptr },
};

static PyType_Spec Geopoint_Type_spec =
{
    "Geopoint",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geopoint>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geopoint_Type_slots
};

// ----- Geoposition class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type;


PyObject* Geoposition_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "Geoposition is not activatable");
    return nullptr;
}

static void Geoposition_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geoposition__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::Geoposition>::convert(instance.as<winrt::Windows::Devices::Geolocation::Geoposition>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geoposition_get_CivicAddress(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::CivicAddress return_value = self->obj.CivicAddress();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geoposition_get_Coordinate(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::Geocoordinate return_value = self->obj.Coordinate();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geoposition_get_VenueData(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::VenueData return_value = self->obj.VenueData();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Geoposition_methods[] = {
    { "get_CivicAddress", (PyCFunction)Geoposition_get_CivicAddress, METH_NOARGS, nullptr },
    { "get_Coordinate", (PyCFunction)Geoposition_get_Coordinate, METH_NOARGS, nullptr },
    { "get_VenueData", (PyCFunction)Geoposition_get_VenueData, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)Geoposition__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Geoposition_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geoposition_dealloc },
    { Py_tp_new, Geoposition_new },
    { Py_tp_methods, Geoposition_methods },
    { 0, nullptr },
};

static PyType_Spec Geoposition_Type_spec =
{
    "Geoposition",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geoposition>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geoposition_Type_slots
};

// ----- Geovisit class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type;


PyObject* Geovisit_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "Geovisit is not activatable");
    return nullptr;
}

static void Geovisit_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geovisit__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::Geovisit>::convert(instance.as<winrt::Windows::Devices::Geolocation::Geovisit>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geovisit_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::Geoposition return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geovisit_get_StateChange(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::VisitStateChange return_value = self->obj.StateChange();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* Geovisit_get_Timestamp(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::DateTime return_value = self->obj.Timestamp();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef Geovisit_methods[] = {
    { "get_Position", (PyCFunction)Geovisit_get_Position, METH_NOARGS, nullptr },
    { "get_StateChange", (PyCFunction)Geovisit_get_StateChange, METH_NOARGS, nullptr },
    { "get_Timestamp", (PyCFunction)Geovisit_get_Timestamp, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)Geovisit__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot Geovisit_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geovisit_dealloc },
    { Py_tp_new, Geovisit_new },
    { Py_tp_methods, Geovisit_methods },
    { 0, nullptr },
};

static PyType_Spec Geovisit_Type_spec =
{
    "Geovisit",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geovisit>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geovisit_Type_slots
};

// ----- GeovisitMonitor class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type;


PyObject* GeovisitMonitor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Devices::Geolocation::GeovisitMonitor instance{  };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static void GeovisitMonitor_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitMonitor__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::convert(instance.as<winrt::Windows::Devices::Geolocation::GeovisitMonitor>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeovisitMonitor_GetLastReportAsync(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Devices::Geolocation::Geovisit> return_value = winrt::Windows::Devices::Geolocation::GeovisitMonitor::GetLastReportAsync();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeovisitMonitor_Start(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(args, 0);

            self->obj.Start(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeovisitMonitor_Stop(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            self->obj.Stop();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeovisitMonitor_add_VisitStateChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::GeovisitMonitor, winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>>::convert_to(args);

            winrt::event_token return_value = self->obj.VisitStateChanged(param0);

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeovisitMonitor_get_MonitoringScope(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::VisitMonitoringScope return_value = self->obj.MonitoringScope();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* GeovisitMonitor_remove_VisitStateChanged(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>* self, PyObject* args)
{ 
        try
        {
            auto param0 = py::converter<winrt::event_token>::convert_to(args);

            self->obj.VisitStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef GeovisitMonitor_methods[] = {
    { "GetLastReportAsync", (PyCFunction)GeovisitMonitor_GetLastReportAsync, METH_VARARGS | METH_STATIC, nullptr },
    { "Start", (PyCFunction)GeovisitMonitor_Start, METH_VARARGS, nullptr },
    { "Stop", (PyCFunction)GeovisitMonitor_Stop, METH_VARARGS, nullptr },
    { "add_VisitStateChanged", (PyCFunction)GeovisitMonitor_add_VisitStateChanged, METH_O, nullptr },
    { "get_MonitoringScope", (PyCFunction)GeovisitMonitor_get_MonitoringScope, METH_NOARGS, nullptr },
    { "remove_VisitStateChanged", (PyCFunction)GeovisitMonitor_remove_VisitStateChanged, METH_O, nullptr },
    { "_from", (PyCFunction)GeovisitMonitor__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitMonitor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, GeovisitMonitor_dealloc },
    { Py_tp_new, GeovisitMonitor_new },
    { Py_tp_methods, GeovisitMonitor_methods },
    { 0, nullptr },
};

static PyType_Spec GeovisitMonitor_Type_spec =
{
    "GeovisitMonitor",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitMonitor>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitMonitor_Type_slots
};

// ----- GeovisitStateChangedEventArgs class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type;


PyObject* GeovisitStateChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeovisitStateChangedEventArgs is not activatable");
    return nullptr;
}

static void GeovisitStateChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitStateChangedEventArgs__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::convert(instance.as<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeovisitStateChangedEventArgs_get_Visit(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::Geovisit return_value = self->obj.Visit();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef GeovisitStateChangedEventArgs_methods[] = {
    { "get_Visit", (PyCFunction)GeovisitStateChangedEventArgs_get_Visit, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)GeovisitStateChangedEventArgs__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitStateChangedEventArgs_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, GeovisitStateChangedEventArgs_dealloc },
    { Py_tp_new, GeovisitStateChangedEventArgs_new },
    { Py_tp_methods, GeovisitStateChangedEventArgs_methods },
    { 0, nullptr },
};

static PyType_Spec GeovisitStateChangedEventArgs_Type_spec =
{
    "GeovisitStateChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitStateChangedEventArgs_Type_slots
};

// ----- GeovisitTriggerDetails class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type;


PyObject* GeovisitTriggerDetails_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeovisitTriggerDetails is not activatable");
    return nullptr;
}

static void GeovisitTriggerDetails_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeovisitTriggerDetails__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::convert(instance.as<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeovisitTriggerDetails_ReadReports(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::Geovisit> return_value = self->obj.ReadReports();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

static PyMethodDef GeovisitTriggerDetails_methods[] = {
    { "ReadReports", (PyCFunction)GeovisitTriggerDetails_ReadReports, METH_VARARGS, nullptr },
    { "_from", (PyCFunction)GeovisitTriggerDetails__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot GeovisitTriggerDetails_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, GeovisitTriggerDetails_dealloc },
    { Py_tp_new, GeovisitTriggerDetails_new },
    { Py_tp_methods, GeovisitTriggerDetails_methods },
    { 0, nullptr },
};

static PyType_Spec GeovisitTriggerDetails_Type_spec =
{
    "GeovisitTriggerDetails",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeovisitTriggerDetails_Type_slots
};

// ----- PositionChangedEventArgs class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type;


PyObject* PositionChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "PositionChangedEventArgs is not activatable");
    return nullptr;
}

static void PositionChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* PositionChangedEventArgs__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::convert(instance.as<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* PositionChangedEventArgs_get_Position(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::Geoposition return_value = self->obj.Position();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef PositionChangedEventArgs_methods[] = {
    { "get_Position", (PyCFunction)PositionChangedEventArgs_get_Position, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)PositionChangedEventArgs__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot PositionChangedEventArgs_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, PositionChangedEventArgs_dealloc },
    { Py_tp_new, PositionChangedEventArgs_new },
    { Py_tp_methods, PositionChangedEventArgs_methods },
    { 0, nullptr },
};

static PyType_Spec PositionChangedEventArgs_Type_spec =
{
    "PositionChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    PositionChangedEventArgs_Type_slots
};

// ----- StatusChangedEventArgs class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type;


PyObject* StatusChangedEventArgs_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "StatusChangedEventArgs is not activatable");
    return nullptr;
}

static void StatusChangedEventArgs_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* StatusChangedEventArgs__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::convert(instance.as<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* StatusChangedEventArgs_get_Status(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::PositionStatus return_value = self->obj.Status();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef StatusChangedEventArgs_methods[] = {
    { "get_Status", (PyCFunction)StatusChangedEventArgs_get_Status, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)StatusChangedEventArgs__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot StatusChangedEventArgs_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, StatusChangedEventArgs_dealloc },
    { Py_tp_new, StatusChangedEventArgs_new },
    { Py_tp_methods, StatusChangedEventArgs_methods },
    { 0, nullptr },
};

static PyType_Spec StatusChangedEventArgs_Type_spec =
{
    "StatusChangedEventArgs",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>),
    0,
    Py_TPFLAGS_DEFAULT,
    StatusChangedEventArgs_Type_slots
};

// ----- VenueData class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type;


PyObject* VenueData_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "VenueData is not activatable");
    return nullptr;
}

static void VenueData_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* VenueData__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::VenueData>::convert(instance.as<winrt::Windows::Devices::Geolocation::VenueData>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* VenueData_get_Id(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Id();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* VenueData_get_Level(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hstring return_value = self->obj.Level();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef VenueData_methods[] = {
    { "get_Id", (PyCFunction)VenueData_get_Id, METH_NOARGS, nullptr },
    { "get_Level", (PyCFunction)VenueData_get_Level, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)VenueData__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot VenueData_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, VenueData_dealloc },
    { Py_tp_new, VenueData_new },
    { Py_tp_methods, VenueData_methods },
    { 0, nullptr },
};

static PyType_Spec VenueData_Type_spec =
{
    "VenueData",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::VenueData>),
    0,
    Py_TPFLAGS_DEFAULT,
    VenueData_Type_slots
};

// ----- IGeoshape interface --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type;


PyObject* IGeoshape_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "IGeoshape interface is not activatable");
    return nullptr;
}

static void IGeoshape_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* IGeoshape__from(PyObject* /*unused*/, PyObject* arg)
{
    try
    {
        auto instance = py::converter<winrt::Windows::Foundation::IInspectable>::convert_to(arg);
        return py::converter<winrt::Windows::Devices::Geolocation::IGeoshape>::convert(instance.as<winrt::Windows::Devices::Geolocation::IGeoshape>());
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* IGeoshape_get_AltitudeReferenceSystem(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem return_value = self->obj.AltitudeReferenceSystem();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IGeoshape_get_GeoshapeType(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Devices::Geolocation::GeoshapeType return_value = self->obj.GeoshapeType();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyObject* IGeoshape_get_SpatialReferenceId(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>* self, PyObject* args)
{ 
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = self->obj.SpatialReferenceId();

            return py::converter<decltype(return_value)>::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

static PyMethodDef IGeoshape_methods[] = {
    { "get_AltitudeReferenceSystem", (PyCFunction)IGeoshape_get_AltitudeReferenceSystem, METH_NOARGS, nullptr },
    { "get_GeoshapeType", (PyCFunction)IGeoshape_get_GeoshapeType, METH_NOARGS, nullptr },
    { "get_SpatialReferenceId", (PyCFunction)IGeoshape_get_SpatialReferenceId, METH_NOARGS, nullptr },
    { "_from", (PyCFunction)IGeoshape__from, METH_O | METH_STATIC, nullptr },
    { nullptr }
};

static PyType_Slot IGeoshape_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, IGeoshape_dealloc },
    { Py_tp_new, IGeoshape_new },
    { Py_tp_methods, IGeoshape_methods },
    { 0, nullptr },
};

static PyType_Spec IGeoshape_Type_spec =
{
    "IGeoshape",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::IGeoshape>),
    0,
    Py_TPFLAGS_DEFAULT,
    IGeoshape_Type_slots
};

// ----- BasicGeoposition struct --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert(winrt::Windows::Devices::Geolocation::BasicGeoposition instance) noexcept
{
    return py::wrap_struct<winrt::Windows::Devices::Geolocation::BasicGeoposition>(instance, py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>());
}

winrt::Windows::Devices::Geolocation::BasicGeoposition py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);
    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>*>(obj)->obj;
    }
    
    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }
    
    winrt::Windows::Devices::Geolocation::BasicGeoposition new_value{};
    PyObject* pyLatitude = PyDict_GetItemString(obj, "Latitude");
    if (!pyLatitude) { throw winrt::hresult_invalid_argument(); }
    new_value.Latitude = converter<double>::convert_to(pyLatitude);
    PyObject* pyLongitude = PyDict_GetItemString(obj, "Longitude");
    if (!pyLongitude) { throw winrt::hresult_invalid_argument(); }
    new_value.Longitude = converter<double>::convert_to(pyLongitude);
    PyObject* pyAltitude = PyDict_GetItemString(obj, "Altitude");
    if (!pyAltitude) { throw winrt::hresult_invalid_argument(); }
    new_value.Altitude = converter<double>::convert_to(pyAltitude);
    return new_value;
}

PyObject* BasicGeoposition_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    auto tuple_size = PyTuple_Size(args);
    if ((tuple_size == 0) && (kwds == nullptr))
    {
        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition instance{};
            return py::wrap_struct(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    
    if ((tuple_size == 1) && (kwds == nullptr))
    {
        auto arg = PyTuple_GetItem(args, 0);
        if (PyDict_Check(arg))
        {
            try
            {
                auto instance = py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert_to(arg); 
                return py::wrap_struct(instance, type);
            }
            catch (...)
            {
                return py::to_PyErr();
            }
        }
    }
    
    double _Latitude{};
    double _Longitude{};
    double _Altitude{};
    static char* kwlist[] = {"Latitude", "Longitude", "Altitude", nullptr};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", kwlist, &_Latitude, &_Longitude, &_Altitude))
    {
        return nullptr;
    }
    
    try
    {
        winrt::Windows::Devices::Geolocation::BasicGeoposition instance{ _Latitude, _Longitude, _Altitude };
        return py::wrap_struct(instance, type);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* BasicGeoposition_get_Latitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Latitude)>::convert(self->obj.Latitude);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BasicGeoposition_set_Latitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Latitude = py::converter<double>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BasicGeoposition_get_Longitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Longitude)>::convert(self->obj.Longitude);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BasicGeoposition_set_Longitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Longitude = py::converter<double>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyObject* BasicGeoposition_get_Altitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, void* /*unused*/)
{
    try
    {
        return py::converter<decltype(self->obj.Altitude)>::convert(self->obj.Altitude);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static int BasicGeoposition_set_Altitude(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>* self, PyObject* value, void* /*unused*/)
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        self->obj.Altitude = py::converter<double>::convert_to(value);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

static PyGetSetDef BasicGeoposition_getset[] = {
    { const_cast<char*>("Latitude"), (getter)BasicGeoposition_get_Latitude, (setter)BasicGeoposition_set_Latitude, nullptr, nullptr },
    { const_cast<char*>("Longitude"), (getter)BasicGeoposition_get_Longitude, (setter)BasicGeoposition_set_Longitude, nullptr, nullptr },
    { const_cast<char*>("Altitude"), (getter)BasicGeoposition_get_Altitude, (setter)BasicGeoposition_set_Altitude, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot BasicGeoposition_Type_slots[] = 
{
    { Py_tp_new, BasicGeoposition_new },
    { Py_tp_getset, BasicGeoposition_getset },
    { 0, nullptr },
};

static PyType_Spec BasicGeoposition_Type_spec =
{
    "BasicGeoposition",
    sizeof(py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>),
    0,
    Py_TPFLAGS_DEFAULT,
    BasicGeoposition_Type_slots
};

// ----- Windows.Devices.Geolocation Initialization --------------------

int initialize_Windows_Devices_Geolocation(PyObject* module)
{
    PyObject* type_object{ nullptr };


    CivicAddress_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&CivicAddress_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "CivicAddress", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeoboundingBox_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeoboundingBox_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeoboundingBox", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geocircle_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geocircle_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geocircle", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geocoordinate_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geocoordinate_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geocoordinate", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeocoordinateSatelliteData_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeocoordinateSatelliteData_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeocoordinateSatelliteData", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geolocator_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geolocator_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geolocator", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geopath_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geopath_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geopath", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geopoint_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geopoint_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geopoint", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geoposition_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geoposition_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geoposition", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    Geovisit_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geovisit_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geovisit", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeovisitMonitor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeovisitMonitor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitMonitor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeovisitStateChangedEventArgs_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeovisitStateChangedEventArgs_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitStateChangedEventArgs", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeovisitTriggerDetails_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeovisitTriggerDetails_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeovisitTriggerDetails", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    PositionChangedEventArgs_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&PositionChangedEventArgs_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "PositionChangedEventArgs", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    StatusChangedEventArgs_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&StatusChangedEventArgs_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "StatusChangedEventArgs", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    VenueData_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&VenueData_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "VenueData", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    IGeoshape_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&IGeoshape_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "IGeoshape", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    type_object = PyType_FromSpec(&BasicGeoposition_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "BasicGeoposition", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
