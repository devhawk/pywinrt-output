// WARNING: Please don't edit this file. It was generated by Python/WinRT

#if __has_include("py.Windows.Devices.Geolocation.Geofencing.h")
#include "py.Windows.Devices.Geolocation.Geofencing.h"
#endif

// ----- Geofence class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>::python_type;

PyObject* Geofence_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    if (kwds != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "keyword arguments not supported");
        return nullptr;
    }

    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 4)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::Geofencing::MonitoredGeofenceStates>(args, 2);
            auto param3 = py::convert_to<bool>(args, 3);
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1, param2, param3 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 5)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::Geofencing::MonitoredGeofenceStates>(args, 2);
            auto param3 = py::convert_to<bool>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 4);
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1, param2, param3, param4 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == 7)
    {
        try
        {
            auto param0 = py::convert_to<winrt::hstring>(args, 0);
            auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::IGeoshape>(args, 1);
            auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::Geofencing::MonitoredGeofenceStates>(args, 2);
            auto param3 = py::convert_to<bool>(args, 3);
            auto param4 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 4);
            auto param5 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 5);
            auto param6 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 6);
            winrt::Windows::Devices::Geolocation::Geofencing::Geofence instance{ param0, param1, param2, param3, param4, param5, param6 };
            return py::wrap(instance, type);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static void Geofence_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* Geofence_get_Duration(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Duration();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geofence_get_DwellTime(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.DwellTime();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geofence_get_Geoshape(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Geoshape();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geofence_get_Id(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Id();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geofence_get_MonitoredStates(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.MonitoredStates();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geofence_get_SingleUse(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.SingleUse();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* Geofence_get_StartTime(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.StartTime();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef Geofence_getset[] = {
    { const_cast<char*>("Duration"), (getter)Geofence_get_Duration, nullptr, nullptr, nullptr },
    { const_cast<char*>("DwellTime"), (getter)Geofence_get_DwellTime, nullptr, nullptr, nullptr },
    { const_cast<char*>("Geoshape"), (getter)Geofence_get_Geoshape, nullptr, nullptr, nullptr },
    { const_cast<char*>("Id"), (getter)Geofence_get_Id, nullptr, nullptr, nullptr },
    { const_cast<char*>("MonitoredStates"), (getter)Geofence_get_MonitoredStates, nullptr, nullptr, nullptr },
    { const_cast<char*>("SingleUse"), (getter)Geofence_get_SingleUse, nullptr, nullptr, nullptr },
    { const_cast<char*>("StartTime"), (getter)Geofence_get_StartTime, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot Geofence_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, Geofence_dealloc },
    { Py_tp_new, Geofence_new },
    { Py_tp_getset, Geofence_getset },
    { 0, nullptr },
};

static PyType_Spec Geofence_Type_spec =
{
    "Geofence",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>),
    0,
    Py_TPFLAGS_DEFAULT,
    Geofence_Type_slots
};

// ----- GeofenceMonitor class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>::python_type;

PyObject* GeofenceMonitor_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeofenceMonitor is not activatable");
    return nullptr;
}

static void GeofenceMonitor_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeofenceMonitor_ReadReports(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>* self, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport> return_value = self->obj.ReadReports();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeofenceMonitor_Current(PyObject* /*unused*/, PyObject* args)
{ 
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor return_value = winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor::Current();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

static PyObject* GeofenceMonitor_get_Geofences(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Geofences();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeofenceMonitor_get_LastKnownGeoposition(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.LastKnownGeoposition();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeofenceMonitor_get_Status(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Status();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyMethodDef GeofenceMonitor_methods[] = {
    { "ReadReports", (PyCFunction)GeofenceMonitor_ReadReports, METH_VARARGS, nullptr },
    { "Current", (PyCFunction)GeofenceMonitor_Current, METH_VARARGS | METH_STATIC, nullptr },
    { nullptr }
};

static PyGetSetDef GeofenceMonitor_getset[] = {
    { const_cast<char*>("Geofences"), (getter)GeofenceMonitor_get_Geofences, nullptr, nullptr, nullptr },
    { const_cast<char*>("LastKnownGeoposition"), (getter)GeofenceMonitor_get_LastKnownGeoposition, nullptr, nullptr, nullptr },
    { const_cast<char*>("Status"), (getter)GeofenceMonitor_get_Status, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeofenceMonitor_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, GeofenceMonitor_dealloc },
    { Py_tp_new, GeofenceMonitor_new },
    { Py_tp_methods, GeofenceMonitor_methods },
    { Py_tp_getset, GeofenceMonitor_getset },
    { 0, nullptr },
};

static PyType_Spec GeofenceMonitor_Type_spec =
{
    "GeofenceMonitor",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeofenceMonitor_Type_slots
};

// ----- GeofenceStateChangeReport class --------------------
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>::python_type;

PyObject* GeofenceStateChangeReport_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
{
    PyErr_SetString(PyExc_TypeError, "GeofenceStateChangeReport is not activatable");
    return nullptr;
}

static void GeofenceStateChangeReport_dealloc(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>* self)
{
    auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
    py::wrapped_instance(hash_value, nullptr);
    self->obj = nullptr;
}

static PyObject* GeofenceStateChangeReport_get_Geofence(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Geofence();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeofenceStateChangeReport_get_Geoposition(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.Geoposition();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeofenceStateChangeReport_get_NewState(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.NewState();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyObject* GeofenceStateChangeReport_get_RemovalReason(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>* self, void* /*unused*/)
{
    try
    {
        auto return_value = self->obj.RemovalReason();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

static PyGetSetDef GeofenceStateChangeReport_getset[] = {
    { const_cast<char*>("Geofence"), (getter)GeofenceStateChangeReport_get_Geofence, nullptr, nullptr, nullptr },
    { const_cast<char*>("Geoposition"), (getter)GeofenceStateChangeReport_get_Geoposition, nullptr, nullptr, nullptr },
    { const_cast<char*>("NewState"), (getter)GeofenceStateChangeReport_get_NewState, nullptr, nullptr, nullptr },
    { const_cast<char*>("RemovalReason"), (getter)GeofenceStateChangeReport_get_RemovalReason, nullptr, nullptr, nullptr },
    { nullptr }
};

static PyType_Slot GeofenceStateChangeReport_Type_slots[] = 
{
    { Py_tp_base, nullptr }, // filled out in module init
    { Py_tp_dealloc, GeofenceStateChangeReport_dealloc },
    { Py_tp_new, GeofenceStateChangeReport_new },
    { Py_tp_getset, GeofenceStateChangeReport_getset },
    { 0, nullptr },
};

static PyType_Spec GeofenceStateChangeReport_Type_spec =
{
    "GeofenceStateChangeReport",
    sizeof(py::winrt_wrapper<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>),
    0,
    Py_TPFLAGS_DEFAULT,
    GeofenceStateChangeReport_Type_slots
};

// ----- Windows.Devices.Geolocation.Geofencing Initialization --------------------

int initialize_Windows_Devices_Geolocation_Geofencing(PyObject* module)
{
    PyObject* type_object{ nullptr };


    Geofence_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&Geofence_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "Geofence", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::Geofence>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeofenceMonitor_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeofenceMonitor_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeofenceMonitor", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceMonitor>::python_type = reinterpret_cast<PyTypeObject*>(type_object);

    GeofenceStateChangeReport_Type_slots[0].pfunc = py::winrt_type<py::winrt_base>::python_type;
    type_object = PyType_FromSpec(&GeofenceStateChangeReport_Type_spec);
    if (type_object == nullptr)
    {
        return -1;
    }
    if (PyModule_AddObject(module, "GeofenceStateChangeReport", type_object) != 0)
    {
        return -1;
    }
    py::winrt_type<winrt::Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport>::python_type = reinterpret_cast<PyTypeObject*>(type_object);
    
    return 0;
}
