// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"
#if __has_include("py.Windows.Foundation.Collections.h")
#include "py.Windows.Foundation.Collections.h"
#endif

#include <winrt/Windows.Foundation.h>

int initialize_Windows_Foundation(PyObject* module);

struct pyAsyncActionCompletedHandler
{
    static winrt::Windows::Foundation::AsyncActionCompletedHandler get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TProgress>
struct pyAsyncActionProgressHandler
{
    static winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TProgress>
struct pyAsyncActionWithProgressCompletedHandler
{
    static winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TResult>
struct pyAsyncOperationCompletedHandler
{
    static winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TResult, typename TProgress>
struct pyAsyncOperationProgressHandler
{
    static winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TResult, typename TProgress>
struct pyAsyncOperationWithProgressCompletedHandler
{
    static winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename T>
struct pyEventHandler
{
    static winrt::Windows::Foundation::EventHandler<T> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TSender, typename TResult>
struct pyTypedEventHandler
{
    static winrt::Windows::Foundation::TypedEventHandler<TSender, TResult> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

struct pyIAsyncActionWithProgress
{
    virtual ~pyIAsyncActionWithProgress() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Progress() = 0;
    virtual int put_Progress(PyObject* arg) = 0;
    virtual PyObject* get_Completed() = 0;
    virtual int put_Completed(PyObject* arg) = 0;
};

struct pyIAsyncOperationWithProgress
{
    virtual ~pyIAsyncOperationWithProgress() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Progress() = 0;
    virtual int put_Progress(PyObject* arg) = 0;
    virtual PyObject* get_Completed() = 0;
    virtual int put_Completed(PyObject* arg) = 0;
};

struct pyIAsyncOperation
{
    virtual ~pyIAsyncOperation() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Completed() = 0;
    virtual int put_Completed(PyObject* arg) = 0;
};

template<typename TProgress>
struct pyIAsyncActionWithProgressImpl : public pyIAsyncActionWithProgress
{
pyIAsyncActionWithProgressImpl(winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* GetResults(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.GetResults();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Progress() override
{
    try
    {
        auto return_value = obj.Progress();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

int put_Progress(PyObject* value) override
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>(value);
        obj.Progress(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

PyObject* get_Completed() override
{
    try
    {
        auto return_value = obj.Completed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

int put_Completed(PyObject* value) override
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>(value);
        obj.Completed(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

    winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> obj{ nullptr };
};

template<typename TResult, typename TProgress>
struct pyIAsyncOperationWithProgressImpl : public pyIAsyncOperationWithProgress
{
pyIAsyncOperationWithProgressImpl(winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* GetResults(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            TResult return_value = obj.GetResults();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Progress() override
{
    try
    {
        auto return_value = obj.Progress();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

int put_Progress(PyObject* value) override
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>(value);
        obj.Progress(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

PyObject* get_Completed() override
{
    try
    {
        auto return_value = obj.Completed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

int put_Completed(PyObject* value) override
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>(value);
        obj.Completed(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

    winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> obj{ nullptr };
};

template<typename TResult>
struct pyIAsyncOperationImpl : public pyIAsyncOperation
{
pyIAsyncOperationImpl(winrt::Windows::Foundation::IAsyncOperation<TResult> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* GetResults(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            TResult return_value = obj.GetResults();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Completed() override
{
    try
    {
        auto return_value = obj.Completed();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

int put_Completed(PyObject* value) override
{
    if (value == nullptr)
    {
        PyErr_SetString(PyExc_RuntimeError, "property delete not supported");
        return -1;
    }
    
    try
    {
        auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>(value);
        obj.Completed(param0);
        return 0;
    }
    catch (...)
    {
        return -1;
    }
}

    winrt::Windows::Foundation::IAsyncOperation<TResult> obj{ nullptr };
};

namespace py
{
    template <typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress>>
    {
        using abstract = ::pyIAsyncActionWithProgress;
        using concrete = ::pyIAsyncActionWithProgressImpl<TProgress>;
    };

    template <typename TResult, typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress>>
    {
        using abstract = ::pyIAsyncOperationWithProgress;
        using concrete = ::pyIAsyncOperationWithProgressImpl<TResult, TProgress>;
    };

    template <typename TResult>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperation<TResult>>
    {
        using abstract = ::pyIAsyncOperation;
        using concrete = ::pyIAsyncOperationImpl<TResult>;
    };

    template <>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionCompletedHandler>
    {
        using type = ::pyAsyncActionCompletedHandler;
    };

    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>
    {
        using type = ::pyAsyncActionProgressHandler<TProgress>;
    };

    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>
    {
        using type = ::pyAsyncActionWithProgressCompletedHandler<TProgress>;
    };

    template <typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>
    {
        using type = ::pyAsyncOperationCompletedHandler<TResult>;
    };

    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>
    {
        using type = ::pyAsyncOperationProgressHandler<TResult, TProgress>;
    };

    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>
    {
        using type = ::pyAsyncOperationWithProgressCompletedHandler<TResult, TProgress>;
    };

    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::EventHandler<T>>
    {
        using type = ::pyEventHandler<T>;
    };

    template <typename TSender, typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::TypedEventHandler<TSender, TResult>>
    {
        using type = ::pyTypedEventHandler<TSender, TResult>;
    };

}
