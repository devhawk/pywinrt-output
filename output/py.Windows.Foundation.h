// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"
#if __has_include("py.Windows.Foundation.Collections.h")
#include "py.Windows.Foundation.Collections.h"
#endif

#include <winrt/Windows.Foundation.h>

int initialize_Windows_Foundation(PyObject* module);

struct pyAsyncActionCompletedHandler
{
    static winrt::Windows::Foundation::AsyncActionCompletedHandler get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TProgress>
struct pyAsyncActionProgressHandler
{
    static winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TProgress>
struct pyAsyncActionWithProgressCompletedHandler
{
    static winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TResult>
struct pyAsyncOperationCompletedHandler
{
    static winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TResult, typename TProgress>
struct pyAsyncOperationProgressHandler
{
    static winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TResult, typename TProgress>
struct pyAsyncOperationWithProgressCompletedHandler
{
    static winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename T>
struct pyEventHandler
{
    static winrt::Windows::Foundation::EventHandler<T> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename TSender, typename TResult>
struct pyTypedEventHandler
{
    static winrt::Windows::Foundation::TypedEventHandler<TSender, TResult> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

struct pyIAsyncActionWithProgress
{
    virtual ~pyIAsyncActionWithProgress() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* Cancel(PyObject* args) = 0;
    virtual PyObject* Close(PyObject* args) = 0;
    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Completed(PyObject* args) = 0;
    virtual PyObject* get_ErrorCode(PyObject* args) = 0;
    virtual PyObject* get_Id(PyObject* args) = 0;
    virtual PyObject* get_Progress(PyObject* args) = 0;
    virtual PyObject* get_Status(PyObject* args) = 0;
    virtual PyObject* put_Completed(PyObject* args) = 0;
    virtual PyObject* put_Progress(PyObject* args) = 0;
};

struct pyIAsyncOperationWithProgress
{
    virtual ~pyIAsyncOperationWithProgress() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* Cancel(PyObject* args) = 0;
    virtual PyObject* Close(PyObject* args) = 0;
    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Completed(PyObject* args) = 0;
    virtual PyObject* get_ErrorCode(PyObject* args) = 0;
    virtual PyObject* get_Id(PyObject* args) = 0;
    virtual PyObject* get_Progress(PyObject* args) = 0;
    virtual PyObject* get_Status(PyObject* args) = 0;
    virtual PyObject* put_Completed(PyObject* args) = 0;
    virtual PyObject* put_Progress(PyObject* args) = 0;
};

struct pyIAsyncOperation
{
    virtual ~pyIAsyncOperation() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* Cancel(PyObject* args) = 0;
    virtual PyObject* Close(PyObject* args) = 0;
    virtual PyObject* GetResults(PyObject* args) = 0;
    virtual PyObject* get_Completed(PyObject* args) = 0;
    virtual PyObject* get_ErrorCode(PyObject* args) = 0;
    virtual PyObject* get_Id(PyObject* args) = 0;
    virtual PyObject* get_Status(PyObject* args) = 0;
    virtual PyObject* put_Completed(PyObject* args) = 0;
};

template<typename TProgress>
struct pyIAsyncActionWithProgressImpl : public pyIAsyncActionWithProgress
{
pyIAsyncActionWithProgressImpl(winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* Cancel(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Close(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetResults(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.GetResults();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Completed(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress> return_value = obj.Completed();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_ErrorCode(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hresult return_value = obj.ErrorCode();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Id(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = obj.Id();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Progress(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress> return_value = obj.Progress();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Status(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncStatus return_value = obj.Status();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* put_Completed(PyObject* args) override
{
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>(args);

            obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* put_Progress(PyObject* args) override
{
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>(args);

            obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

    winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress> obj{ nullptr };
};

template<typename TResult, typename TProgress>
struct pyIAsyncOperationWithProgressImpl : public pyIAsyncOperationWithProgress
{
pyIAsyncOperationWithProgressImpl(winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* Cancel(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Close(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetResults(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            TResult return_value = obj.GetResults();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Completed(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress> return_value = obj.Completed();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_ErrorCode(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hresult return_value = obj.ErrorCode();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Id(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = obj.Id();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Progress(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress> return_value = obj.Progress();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Status(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncStatus return_value = obj.Status();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* put_Completed(PyObject* args) override
{
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>(args);

            obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* put_Progress(PyObject* args) override
{
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>(args);

            obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

    winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress> obj{ nullptr };
};

template<typename TResult>
struct pyIAsyncOperationImpl : public pyIAsyncOperation
{
pyIAsyncOperationImpl(winrt::Windows::Foundation::IAsyncOperation<TResult> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* Cancel(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Cancel();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Close(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Close();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetResults(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            TResult return_value = obj.GetResults();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_TypeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Completed(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult> return_value = obj.Completed();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_ErrorCode(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::hresult return_value = obj.ErrorCode();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Id(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            uint32_t return_value = obj.Id();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* get_Status(PyObject* args) override
{
    if (args != nullptr)
    {
        PyErr_SetString(PyExc_TypeError, "arguments not supported for get methods");
        return nullptr;
    }
        try
        {
            winrt::Windows::Foundation::AsyncStatus return_value = obj.Status();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

PyObject* put_Completed(PyObject* args) override
{
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>(args);

            obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
}

    winrt::Windows::Foundation::IAsyncOperation<TResult> obj{ nullptr };
};

namespace py
{
    template<>
    struct converter<winrt::Windows::Foundation::DateTime>
    {
        static winrt::Windows::Foundation::DateTime convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::event_token>
    {
        static winrt::event_token convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::hresult>
    {
        static winrt::hresult convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Point>
    {
        static winrt::Windows::Foundation::Point convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Rect>
    {
        static winrt::Windows::Foundation::Rect convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::Size>
    {
        static winrt::Windows::Foundation::Size convert_to(PyObject* obj);
    };
    
    template<>
    struct converter<winrt::Windows::Foundation::TimeSpan>
    {
        static winrt::Windows::Foundation::TimeSpan convert_to(PyObject* obj);
    };
    
    template <typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncActionWithProgress<TProgress>>
    {
        using abstract = ::pyIAsyncActionWithProgress;
        using concrete = ::pyIAsyncActionWithProgressImpl<TProgress>;
    };

    template <typename TResult, typename TProgress>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperationWithProgress<TResult, TProgress>>
    {
        using abstract = ::pyIAsyncOperationWithProgress;
        using concrete = ::pyIAsyncOperationWithProgressImpl<TResult, TProgress>;
    };

    template <typename TResult>
    struct pinterface_python_type<winrt::Windows::Foundation::IAsyncOperation<TResult>>
    {
        using abstract = ::pyIAsyncOperation;
        using concrete = ::pyIAsyncOperationImpl<TResult>;
    };

    template <>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionCompletedHandler>
    {
        using type = ::pyAsyncActionCompletedHandler;
    };

    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionProgressHandler<TProgress>>
    {
        using type = ::pyAsyncActionProgressHandler<TProgress>;
    };

    template <typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncActionWithProgressCompletedHandler<TProgress>>
    {
        using type = ::pyAsyncActionWithProgressCompletedHandler<TProgress>;
    };

    template <typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationCompletedHandler<TResult>>
    {
        using type = ::pyAsyncOperationCompletedHandler<TResult>;
    };

    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationProgressHandler<TResult, TProgress>>
    {
        using type = ::pyAsyncOperationProgressHandler<TResult, TProgress>;
    };

    template <typename TResult, typename TProgress>
    struct delegate_python_type<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>
    {
        using type = ::pyAsyncOperationWithProgressCompletedHandler<TResult, TProgress>;
    };

    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::EventHandler<T>>
    {
        using type = ::pyEventHandler<T>;
    };

    template <typename TSender, typename TResult>
    struct delegate_python_type<winrt::Windows::Foundation::TypedEventHandler<TSender, TResult>>
    {
        using type = ::pyTypedEventHandler<TSender, TResult>;
    };

}
