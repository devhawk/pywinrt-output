// WARNING: Please don't edit this file. It was generated by Python/WinRT

#pragma once

#include "pybase.h"

#include <winrt/Windows.Foundation.Collections.h>

int initialize_Windows_Foundation_Collections(PyObject* module);

template <typename K, typename V>
struct pyMapChangedEventHandler
{
    static winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

template <typename T>
struct pyVectorChangedEventHandler
{
    static winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T> get(PyObject* callable)
    {
        if (PyFunction_Check(callable) == 0)
        {
            throw winrt::hresult_invalid_argument();
        }

        // TODO: How do I manage callable lifetime here?
        return [callable](auto param1, auto param2)
        {
            PyObject* pyObj1 = py::convert(param1);
            PyObject* pyObj2 = py::convert(param2);

            PyObject* args = PyTuple_Pack(2, pyObj1, pyObj2);

            // TODO: RAII for GILState
            PyGILState_STATE gstate;
            gstate = PyGILState_Ensure();
            PyObject_CallObject(callable, args);
            PyGILState_Release(gstate);
        };
    }
};

struct pyIIterable
{
    virtual ~pyIIterable() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* First(PyObject* args) = 0;
};

struct pyIIterator
{
    virtual ~pyIIterator() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* MoveNext(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* get_Current() = 0;
    virtual PyObject* get_HasCurrent() = 0;
};

struct pyIKeyValuePair
{
    virtual ~pyIKeyValuePair() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* get_Key() = 0;
    virtual PyObject* get_Value() = 0;
};

struct pyIMapChangedEventArgs
{
    virtual ~pyIMapChangedEventArgs() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* get_CollectionChange() = 0;
    virtual PyObject* get_Key() = 0;
};

struct pyIMapView
{
    virtual ~pyIMapView() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* Split(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

struct pyIMap
{
    virtual ~pyIMap() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* Lookup(PyObject* args) = 0;
    virtual PyObject* HasKey(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* Insert(PyObject* args) = 0;
    virtual PyObject* Remove(PyObject* args) = 0;
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

struct pyIObservableMap
{
    virtual ~pyIObservableMap() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

};

struct pyIObservableVector
{
    virtual ~pyIObservableVector() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

};

struct pyIVectorView
{
    virtual ~pyIVectorView() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

struct pyIVector
{
    virtual ~pyIVector() {};
    virtual winrt::Windows::Foundation::IUnknown const& get_unknown() = 0;
    virtual std::size_t hash() = 0;

    virtual PyObject* GetAt(PyObject* args) = 0;
    virtual PyObject* GetView(PyObject* args) = 0;
    virtual PyObject* IndexOf(PyObject* args) = 0;
    virtual PyObject* SetAt(PyObject* args) = 0;
    virtual PyObject* InsertAt(PyObject* args) = 0;
    virtual PyObject* RemoveAt(PyObject* args) = 0;
    virtual PyObject* Append(PyObject* args) = 0;
    virtual PyObject* RemoveAtEnd(PyObject* args) = 0;
    virtual PyObject* Clear(PyObject* args) = 0;
    virtual PyObject* GetMany(PyObject* args) = 0;
    virtual PyObject* ReplaceAll(PyObject* args) = 0;
    virtual PyObject* get_Size() = 0;
};

template<typename T>
struct pyIIterableImpl : public pyIIterable
{
pyIIterableImpl(winrt::Windows::Foundation::Collections::IIterable<T> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* First(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IIterator<T> return_value = obj.First();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

    winrt::Windows::Foundation::Collections::IIterable<T> obj{ nullptr };
};

template<typename T>
struct pyIIteratorImpl : public pyIIterator
{
pyIIteratorImpl(winrt::Windows::Foundation::Collections::IIterator<T> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* MoveNext(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            bool return_value = obj.MoveNext();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetMany(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            /*r*/ winrt::array_view<T> param0 { };

            uint32_t return_value = obj.GetMany(param0);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out0 = py::convert(param0);
            if (!out0) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out0);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Current() override
{
    try
    {
        auto return_value = obj.Current();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

PyObject* get_HasCurrent() override
{
    try
    {
        auto return_value = obj.HasCurrent();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

    winrt::Windows::Foundation::Collections::IIterator<T> obj{ nullptr };
};

template<typename K, typename V>
struct pyIKeyValuePairImpl : public pyIKeyValuePair
{
pyIKeyValuePairImpl(winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* get_Key() override
{
    try
    {
        auto return_value = obj.Key();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

PyObject* get_Value() override
{
    try
    {
        auto return_value = obj.Value();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

    winrt::Windows::Foundation::Collections::IKeyValuePair<K, V> obj{ nullptr };
};

template<typename K>
struct pyIMapChangedEventArgsImpl : public pyIMapChangedEventArgs
{
pyIMapChangedEventArgsImpl(winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* get_CollectionChange() override
{
    try
    {
        auto return_value = obj.CollectionChange();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

PyObject* get_Key() override
{
    try
    {
        auto return_value = obj.Key();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

    winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K> obj{ nullptr };
};

template<typename K, typename V>
struct pyIMapViewImpl : public pyIMapView
{
pyIMapViewImpl(winrt::Windows::Foundation::Collections::IMapView<K, V> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* Lookup(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);

            V return_value = obj.Lookup(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* HasKey(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);

            bool return_value = obj.HasKey(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Split(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<K, V> param0 { nullptr };
            winrt::Windows::Foundation::Collections::IMapView<K, V> param1 { nullptr };

            obj.Split(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Size() override
{
    try
    {
        auto return_value = obj.Size();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

    winrt::Windows::Foundation::Collections::IMapView<K, V> obj{ nullptr };
};

template<typename K, typename V>
struct pyIMapImpl : public pyIMap
{
pyIMapImpl(winrt::Windows::Foundation::Collections::IMap<K, V> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* Lookup(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);

            V return_value = obj.Lookup(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* HasKey(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);

            bool return_value = obj.HasKey(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetView(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IMapView<K, V> return_value = obj.GetView();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Insert(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);
            auto param1 = py::convert_to<V>(args, 1);

            bool return_value = obj.Insert(param0, param1);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Remove(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<K>(args, 0);

            obj.Remove(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Clear(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Clear();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Size() override
{
    try
    {
        auto return_value = obj.Size();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

    winrt::Windows::Foundation::Collections::IMap<K, V> obj{ nullptr };
};

template<typename K, typename V>
struct pyIObservableMapImpl : public pyIObservableMap
{
pyIObservableMapImpl(winrt::Windows::Foundation::Collections::IObservableMap<K, V> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

    winrt::Windows::Foundation::Collections::IObservableMap<K, V> obj{ nullptr };
};

template<typename T>
struct pyIObservableVectorImpl : public pyIObservableVector
{
pyIObservableVectorImpl(winrt::Windows::Foundation::Collections::IObservableVector<T> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

    winrt::Windows::Foundation::Collections::IObservableVector<T> obj{ nullptr };
};

template<typename T>
struct pyIVectorViewImpl : public pyIVectorView
{
pyIVectorViewImpl(winrt::Windows::Foundation::Collections::IVectorView<T> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* GetAt(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            T return_value = obj.GetAt(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* IndexOf(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);
            uint32_t param1 {  };

            bool return_value = obj.IndexOf(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetMany(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*r*/ winrt::array_view<T> param1 { };

            uint32_t return_value = obj.GetMany(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Size() override
{
    try
    {
        auto return_value = obj.Size();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

    winrt::Windows::Foundation::Collections::IVectorView<T> obj{ nullptr };
};

template<typename T>
struct pyIVectorImpl : public pyIVector
{
pyIVectorImpl(winrt::Windows::Foundation::Collections::IVector<T> o) : obj(o) {}
winrt::Windows::Foundation::IUnknown const& get_unknown() override { return obj; }
std::size_t hash() override { return py::get_instance_hash(obj); }

PyObject* GetAt(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            T return_value = obj.GetAt(param0);

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetView(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            winrt::Windows::Foundation::Collections::IVectorView<T> return_value = obj.GetView();

            return py::convert(return_value);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* IndexOf(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);
            uint32_t param1 {  };

            bool return_value = obj.IndexOf(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* SetAt(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<T>(args, 1);

            obj.SetAt(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* InsertAt(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 2)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            auto param1 = py::convert_to<T>(args, 1);

            obj.InsertAt(param0, param1);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* RemoveAt(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);

            obj.RemoveAt(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Append(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<T>(args, 0);

            obj.Append(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* RemoveAtEnd(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.RemoveAtEnd();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* Clear(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 0)
    {
        try
        {
            obj.Clear();
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* GetMany(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            auto param0 = py::convert_to<uint32_t>(args, 0);
            /*r*/ winrt::array_view<T> param1 { };

            uint32_t return_value = obj.GetMany(param0, param1);

            PyObject* out_return_value = py::convert(return_value);
            if (!out_return_value) 
            { 
                return nullptr;
            };

            PyObject* out1 = py::convert(param1);
            if (!out1) 
            {
                return nullptr;
            }

            return PyTuple_Pack(2, out_return_value, out1);
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* ReplaceAll(PyObject* args) override
{
    Py_ssize_t arg_count = PyTuple_Size(args);

    if (arg_count == 1)
    {
        try
        {
            /*p*/ winrt::array_view<T const> param0 {}; //= py::convert_to<winrt::array_view<T const>>(args, 0);

            obj.ReplaceAll(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            return py::to_PyErr();
        }
    }
    else if (arg_count == -1)
    {
        return nullptr; 
    }

    PyErr_SetString(PyExc_RuntimeError, "Invalid parameter count");
    return nullptr;
}

PyObject* get_Size() override
{
    try
    {
        auto return_value = obj.Size();
        return py::convert(return_value);
    }
    catch (...)
    {
        return py::to_PyErr();
    }
}

    winrt::Windows::Foundation::Collections::IVector<T> obj{ nullptr };
};

namespace py
{
    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        using abstract = ::pyIIterable;
        using concrete = ::pyIIterableImpl<T>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IIterator<T>>
    {
        using abstract = ::pyIIterator;
        using concrete = ::pyIIteratorImpl<T>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>
    {
        using abstract = ::pyIKeyValuePair;
        using concrete = ::pyIKeyValuePairImpl<K, V>;
    };

    template <typename K>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>>
    {
        using abstract = ::pyIMapChangedEventArgs;
        using concrete = ::pyIMapChangedEventArgsImpl<K>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMapView<K, V>>
    {
        using abstract = ::pyIMapView;
        using concrete = ::pyIMapViewImpl<K, V>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IMap<K, V>>
    {
        using abstract = ::pyIMap;
        using concrete = ::pyIMapImpl<K, V>;
    };

    template <typename K, typename V>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableMap<K, V>>
    {
        using abstract = ::pyIObservableMap;
        using concrete = ::pyIObservableMapImpl<K, V>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IObservableVector<T>>
    {
        using abstract = ::pyIObservableVector;
        using concrete = ::pyIObservableVectorImpl<T>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVectorView<T>>
    {
        using abstract = ::pyIVectorView;
        using concrete = ::pyIVectorViewImpl<T>;
    };

    template <typename T>
    struct pinterface_python_type<winrt::Windows::Foundation::Collections::IVector<T>>
    {
        using abstract = ::pyIVector;
        using concrete = ::pyIVectorImpl<T>;
    };

    template <typename K, typename V>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::MapChangedEventHandler<K, V>>
    {
        using type = ::pyMapChangedEventHandler<K, V>;
    };

    template <typename T>
    struct delegate_python_type<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<T>>
    {
        using type = ::pyVectorChangedEventHandler<T>;
    };

}
